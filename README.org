#+TITLE: The future home of the L4 DSL
#+STARTUP: content

This specification is in EARLY DRAFT stage right now, and is expected to evolve throughout the remainder of 2020. The only people writing L4 according to this spec are the core development team, and it doesn't even always work for them.

* Draft Language Specification v0.3.0

We review a simple case. Then we detail the rest of the language.

** Quickstart: L4 By Example

*** Hello, Cabbage

Suppose cabbages may be sold only on the day a full moon occurs -- unless an exemption was granted by the Director of Agriculture. Buyers have the right, within three weeks of purchase, to return their cabbages for a 90% refund, which the seller must issue within 3 days of the return.

How might we say it in L4?

#+begin_src sql :noweb-ref l4-rules
  RULE  1 SaleRestricted
           :en:"The Sale of Cabbages is Restricted."
           :se:"Försäljning av kål är begränsad."
    PARTY NOBODY      AS P1
      MAY sell Item   AS sale
     WHEN Item IS cabbage
   UNLESS sale IS onLegalDate
       OR UNLIKELY P1 HAS Exemption.from ~ [DirectorOfAgriculture]
    HENCE ReturnPolicy
    WHERE sale IS onLegalDate
            WHEN sale.date ~ LegalDates
            WHERE LegalDates = external(url="https://www.almanac.com/astronomy/moon/full/")
#+end_src

We picked this example because it embeds a simple mini-contract in the sale-and-return part.

The "NOBODY" syntax is a bit of a special case -- it desugars to
1. ANY PARTY P1 MAY sell Item WHEN Item IS Cabbage AND ( sale IS onLegalDate OR P1 HAS Exemption )
2. but, if the preceding rule doesn't match, then by default, "ANY PARTY P1 SHANT sell Item WHEN Item IS Cabbage".

The rest of this document explains the syntax and shows the BNF language definition.

*** Rule Headers

A "RULE" stanza is labeled with a numeric identifier, a name, or both, followed by zero or more language strings.

#+begin_src bnfc :noweb-ref l4bnfc
  Rule.      Rule      ::= "RULE" RuleDef RuleName Asof MetaLimb RuleBody;

  RID.       RuleDef   ::=         ObjAttr ;
  RNumID.    RuleDef   ::= Integer ObjAttr ;
  RNum.      RuleDef   ::= Integer ;
  RName.     RuleName  ::= OptLangStrings ;

  rules      OptLangStrings ::= | LangStrings;

#+end_src

The optional langstrings provide hints for natural language generation.

The "Meta" limb facilitates rule prioritization.

Subsequently, the rule body. There are several subtypes of rule bodies.

*** The Core Rule Bodies: DEFINEs and Modals

Every rule body is one of the following:

**** <<<DEFINE rule>>> or (ENTITY rule)

A constitutive rule, also known as a Deem rule, or a Define rule.

Thing A is deemed to be a Thing B when conditions C are met. The "A" and "B" parts appear within the /constraint/ part:

- constraint :: one or more subjects of the deem: that an A counts as B in some way, or has some value, or some inequality

#+begin_src sql :noweb-ref l4-rules
  RULE   4 Cabbage
    DEFINE Item IS cabbage
      WHEN Item.species ~ ["Brassica chinensis" | "Brassica oleracea"]
#+end_src

The BNF:

#+begin_src bnfc :noweb-ref l4bnfc
  -- a constitutive rule
  RuleDeem.     RuleBody  ::= GivenUpon [DefineLimb] WhenHenceWhere ;
  separator nonempty DefineLimb "";

  GU0.          GivenUpon ::= ;
  GUGiven.      GivenUpon ::= GivenLimb UponLimb;
  GUUpon.       GivenUpon ::= UponLimb GivenLimb;

  WHW.          WhenHenceWhere ::= WhenLimb HenceLimb WhereLimb ;

  DefLimb.    DefineLimb ::= DefineWord [Constraint] WithLimb Asof;
  
  DefDefine.  DefineWord ::= "DEFINE" ;
  DefDeem.    DefineWord ::= "DEEM" ;
  DefDeclare. DefineWord ::= "DECLARE" ;
  DefEntity.  DefineWord ::= "ENTITY" ;
#+end_src

A DEFINE rule can have optional limbs:
- with limb :: further attributes of the subject(s)
- asof limb :: when the definition came into force -- this should desugar multiple definitions of the same thing, to decorate each with a WHEN constraint to partition

Deem rules are a good place to shoehorn your function definitions.

The Entity Rule is a special case of a DEFINE.

**** Modals: welcome to the PARTY

A modal stanza defines a node in the obligation graph. These express what Ken Adams calls

- language of performance
- language of obligation
- language of discretion
- language of prohibition

#+begin_src sql :noweb-ref l4-rules
  RULE  2 ReturnPolicy  // the "hence" target of rule 1 above
    GIVEN sale          // defined in rule 1 above
    PARTY Buyer
      MAY return Item
   BEFORE sale.date + 3 WEEKS
    HENCE Net3          // targets rule 3 below

  RULE  3 Net3          // the "hence" target of rule 2 above
    GIVEN return        // defined in rule 2 above
    PARTY Seller
     MUST refund Amount
   BEFORE return.date + 3 DAYS
    WHERE Amount = $sale.cash * 90%
#+end_src

In short,
- given some context (usually one or more references to ancestors to that node)
- when some set of conditions holds (see also Coode on Legislative Expression)
- some party
- must, may, or shan't
- perform some action (satisfying some set of parameters)
- by some deadline

And if they perform as specified, the state graph proceeds to the node specified in the "hence" limb.

If they fail to perform, the state graph proceeds to the node specified in the "lest" limb.

The "GIVEN" and "UPON" limbs can be swapped, synonymously.

#+begin_src bnfc :noweb-ref l4bnfc
  RModal.   RuleBody    ::= GivenUpon ModalLimb WhenHenceWhere ;

  MD1.      ModalLimb   ::= PartyLimb DeonticLimb DeadlineLimb;

  Parties.   PartyLimb   ::= "PARTIES" AsAlias;
  PartyLimb. PartyLimb   ::= "PARTY" PartyDef AsAlias;
  PSome.   PartyDef    ::= ObjAttr ;
  PEvery.  PartyDef    ::= PEvery ;
  rules    PEvery      ::=          "EVERYBODY" | "ANYBODY" | "EVERYONE" | "ANYONE" ;
  PNobody. PartyDef    ::= PNobody;
  rules    PNobody     ::=          "NOBODY" | "NO-ONE" | "NOONE" | "NONE" ;
#+end_src

There's some syntactic sugar for "everybody" and "nobody" as special cases of parties.

See [[https://drive.google.com/file/d/1sLmVMZqHhQDzj8dikKt-8CNemF-nGCn1/view?usp=sharing][page 41 of Hvitved's PhD Thesis]].

#+begin_src bnfc :noweb-ref l4bnfc
  rules    AsAlias     ::= | "AS" ObjAttr ;
#+end_src

As-aliases provide variable bindings to elements of the rule. In Haskell they are like the "@" in a pattern match.

***** Deontics and the Action Limb

In a modal stanza, some party is seen doing some thing, to some standard. This limb talks about the thing and the standard.

#+begin_src bnfc :noweb-ref l4bnfc
  rules    DeonticLimb ::= DeonticExpr OptLangStrings ActionLimb;
  DEMust.  DeonticExpr ::= "MUST" ;
  DEMay.   DeonticExpr ::= "MAY"  ;
  DEShant. DeonticExpr ::= "SHANT" ;
#+end_src

The syntax for actions is not terribly well specified at the moment. You can say pretty much whatever you want.

#+begin_src bnfc :noweb-ref l4bnfc
  ActionMulti.    ActionLimb  ::= LstExp    [Blah] AsAlias ;
  ActionSingle.   ActionLimb  ::= ObjMethod [Blah] AsAlias ;
#+end_src

***** Deadlines

Every deontic modal needs a deadline -- if you don't have to do something by a certain time, do you really have to do it at all?

#+begin_src bnfc :noweb-ref l4bnfc
  DL0.         DeadlineLimb ::= ;
  DLLimb.      DeadlineLimb ::= TempRel TemporalExpr AsAlias ;
  TRBefore.    TempRel      ::= "BEFORE";
  TRPrior.     TempRel      ::= "PRIORTO"; -- immediately prior to
  TRAfter.     TempRel      ::= "AFTER";
  TRUntil.     TempRel      ::= "UNTIL";
#+end_src

We need to improve the conceptual clarity of the deadline syntax.

#+begin_src bnfc :noweb-ref l4bnfc
  rules     TemporalExpr ::= DateTime DurationExpr | ObjAttr DurationExpr
                          | "EARLIEST" LstExp
                          | "LATEST"   LstExp;
  rules     DurationExpr ::= | "+" Duration ;
  TDY.      Duration     ::= Integer "YEARS" ;
  TDM.      Duration     ::= Integer "MONTHS" ;
  TDW.      Duration     ::= Integer "WEEKS" ;
  TDD.      Duration     ::= Integer "DAYS" ;
  TDBD.     Duration     ::= Integer "BUSINESS" "DAYS" ;
  TDDH.     Duration     ::= Integer "DAYS" "AND" Integer "HOURS" ;
  DNoHence. HenceLimb    ::= ;
  DHence.   HenceLimb    ::= "HENCE" Goto Args OptLangStrings;
  DHeLe.    HenceLimb    ::= "HENCE" Goto Args OptLangStrings "LEST" Goto Args OptLangStrings ;
  DLest.    HenceLimb    ::=                                  "LEST" Goto Args OptLangStrings ;
  RGoto.          Goto   ::= RuleDef ;
  RFulfilled.     Goto   ::= "FULFILLED" ;
  RBreach.        Goto   ::= "BREACH" ;
#+end_src

LegalRuleML distinguishes between /maintenance/ obligations and /achievement/ obligations.

If we had a maintenance obligation to hold true until the contract terminated, we could say:

#+begin_example
  RULE NonDisclosure
    PARTY P1, P2
    SHANT disclose confidentialInfo
    BEFORE contract.terminationDate
    WHERE confidentialInfo = such.and.such
#+end_example

From this we see that a maintenance obligation to not do a thing, is an obligation to not achieve the thing before a certain time.

A maintenance obligation that should always hold, is an obligation to not achieve that it not hold.

This is expressible in usual temporal modal logic, LTL.


**** Performative Utterances

Similar to deontic rules, except instead of saying that a party MUST do something, the party simply HEREBY does it.

Representations and warranties are given in the form of such statements.

#+begin_src bnfc :noweb-ref l4bnfc
  RulePerform.  RuleBody  ::= GivenUpon PartyLimb PerformWord [Constraint] WithLimb WhenHenceWhere;
  
  PerHereby.    PerformWord ::= "HEREBY" ;
  PerAgree.     PerformWord ::= "AGREE" ;
  PerRep.       PerformWord ::= "REPRESENT" ;
  PerWar.       PerformWord ::= "WARRANT" ;
  PerRepWar.    PerformWord ::= "REPRANT" ;
#+end_src
  
**** See Also
- Advanced Rule Bodies.

*** <<<ENTITY rule>>>: to define individuals.

These stanzas express what Ken Adams calls Language of Declaration -- about entities, at least.

#+begin_src haskell :noweb-ref l4entity
  RULE mkSpud1
    ENTITY spud10 ISA Item
    ENTITY spud1 ISA Item
      WITH species  = "Solanum tuberosum"
           isEdible = true
#+end_src

ENTITY stanzas are a special case of a DEFINE. While DEFINE statements create classes, ENTITY stanzas create individuals, or instances, of those classes. One uses an ENTITY rule to parameterize an abstract contract to a concrete contract.

The syntax for an ENTITY stanza is largely the same as for a DEFINE stanza, with just the words changed. The following limbs are not expected in an ENTITY stanza:
- Hence

Other kinds of top-level stanzas are described below.

This converts to Prolog:

#+begin_src prolog
  species(spud1, "Solanum tuberosum").
  isEdible(spud1).
  isA(spud1, Item).
#+end_src

If we were converting to Flora-2 we would be more intelligent about classes and inheritance, but we're just trying to get our feet wet with logic programming, so we'll do that another time.

Incidentally, astute readers may remark: "surely ~IS~ and ~ISA~ syntax here is a special case of some more generic n-place arity relational syntax for FOL" -- and you would be right. ~IS~ and ~ISA~ should be macros. This refactoring of the language will happen soon.

** Limbs

The body of a rule may include one or more limbs. In the above examples, we have already seen some limbs in action.

- upon :: an event or pattern that triggers the rule
- given :: context parameters, analogous to function arguments
- when :: pre-conditions for the rule to operate
- where :: subsidiary definitions

*** <<<UPON limb>>>: a rule is triggered by events

"UPON" matches events. Refinements to the "UPON" can be one of the following:

| Kleisli | Time    | means                                                              |
|---------+---------+--------------------------------------------------------------------|
| EACH    | PAST    | run once for each matching event occuring before the main GIVEN    |
| EACH    | CURRENT | run once for each matching event contemporaneous with main GIVEN   |
| EACH    | FUTURE  | run once for each matching event subsequent to the main GIVEN      |
| EACH    | EVER    | run once for each matching event before, during, or after GIVEN    |
| ANY     | PAST    | run once, if there were one or more matching events before GIVEN   |
| ANY     | CURRENT | run once, if there are one or more matching events alongside GIVEN |
| ANY     | FUTURE  | run once for the first future event, but not subsequently          |
| ANY     | EVER    | combination of PAST, CURRENT, FUTURE.                              |

If left unspecified, the default refinement is "ANY FUTURE".

If there is no GIVEN, then the thread begins at the start of the contract.

#+begin_src bnfc :noweb-ref l4bnfc
  rules       UponLimb       ::= | "UPON" UponRefinement GivenExpr ;
  Upon0.      UponRefinement ::= ;
  Upon2.      UponRefinement ::= UponKleisli UponTime;
  UponEach.   UponKleisli    ::= "EACH"; -- fires once for each matching event
  UponAny.    UponKleisli    ::= "ANY";  -- collects all matching events, fires once
  UponPast.    UponTime      ::= "PAST"; -- match events prior to the UPON event
  UponFuture.  UponTime      ::= "FUTURE"; -- default; match events after the UPON
  UponCurrent. UponTime      ::= "CURRENT"; -- match events contemporaneous with UPON
  UponEver.    UponTime      ::= "EVER";    -- match past, current, and future
#+end_src

*** <<<GIVEN limb>>>: brings context into scope

Usually the "Given" expression is one or more names of a previous deontic rule, in which case all the variables in scope for the previous rule are imported into the current state.

The "Given" expression can also be specific variable names, in which case only those variables are brought into scope. The compiler needs to test if there are any possible execution paths which allow an undefined variable to appear in the Given.

#+begin_src bnfc :noweb-ref l4bnfc
  GivenLimb0.     GivenLimb ::= ;
  GivenLimb1.     GivenLimb ::= "GIVEN"  GivenExpr ;
  rules      GivenExpr ::=   Exp
                           | Exp HavingLimb ;
#+end_src

The HAVING part places a condition on the GIVEN. It desugars to an AND against the WHEN limb, but is scoped to the terms uttered in the GIVEN.

#+begin_src bnfc :noweb-ref l4bnfc
  rules     HavingLimb ::= "HAVING" "{" [HavingBoolExp] "}";
  rules     HavingBoolExp ::= Exp;
  separator nonempty HavingBoolExp ";";
#+end_src

The scope of a GivenExpr is the entire ancestry of that node in the obligation graph. If some previous thing happened, the GivenExpr can bring it into scope by referring to it.

*** <<<WHEN limb>>>: Boolean preconditions for the rule

Boolean Expressions are used in a WHEN limb to evaluate truth values as part of a reasoning operation.

Example:
#+begin_src text :noweb-ref l4-rules
  RULE    Quorum
   DEFINE OrdinaryMeeting IS Quorate
     WHEN SUM(OrdinaryMeeting.attendees.votingShares) > 50% * SUM(company.members.All.votingShares)
    WHERE company = OrdinaryMeeting.company
#+end_src

BNF:

#+begin_src bnfc :noweb-ref l4bnfc
  WhenLimb0.      WhenLimb   ::= ;
  WhenLimb1.      WhenLimb   ::= "WHEN"   Exp;
#+end_src

They are very similar to the constraint expressions we've already seen in DEFINE rules.

The When Limb has an optional When part and an optional Unless part.

Here's the truth table for how the parts interact

| When    | Unless  | Result          |
|---------+---------+-----------------|
| absent  | absent  | true            |
| absent  | present | evaluate unless |
| present | absent  | evaluate when   |
| present | present | as below        |

Here's a possible truth table for how the When/Unless limbs desugar. The size of this table is a sign that maybe we need to rethink this.

| Party     | DeonticExpr | WHEN  | UNLESS | means           | HENCE |
|-----------+-------------+-------+--------+-----------------+-------|
| Some P    | MAY         | true  | true   | -               |       |
| Some P    | MAY         | true  | false  | P MAY           |       |
| Some P    | MAY         | false | true   | -               |       |
| Some P    | MAY         | false | false  | -               |       |
|-----------+-------------+-------+--------+-----------------+-------|
| Some P    | MUST        | true  | true   | -               |       |
| Some P    | MUST        | true  | false  | P MUST          |       |
| Some P    | MUST        | false | true   | -               |       |
| Some P    | MUST        | false | false  | -               |       |
|-----------+-------------+-------+--------+-----------------+-------|
| Some P    | SHANT       | true  | true   | -               |       |
| Some P    | SHANT       | true  | false  | P SHANT         |       |
| Some P    | SHANT       | false | true   | -               |       |
| Some P    | SHANT       | false | false  | -               |       |
|-----------+-------------+-------+--------+-----------------+-------|
| Everybody | MAY         | true  | true   | -               |       |
| Everybody | MAY         | true  | false  | Everybody MAY   |       |
| Everybody | MAY         | false | true   | -               |       |
| Everybody | MAY         | false | false  | -               |       |
|-----------+-------------+-------+--------+-----------------+-------|
| Everybody | MUST        | true  | true   | -               |       |
| Everybody | MUST        | true  | false  | Everybody MUST  |       |
| Everybody | MUST        | false | true   | -               |       |
| Everybody | MUST        | false | false  | -               |       |
|-----------+-------------+-------+--------+-----------------+-------|
| Everybody | SHANT       | true  | true   | P MAY           |       |
| Everybody | SHANT       | true  | false  | Everybody Shant |       |
| Everybody | SHANT       | false | true   | P MAY           |       |
| Everybody | SHANT       | false | false  | -               |       |
|-----------+-------------+-------+--------+-----------------+-------|
| Nobody    | MAY         | true  | true   | P MAY           |       |
| Nobody    | MAY         | true  | false  | Nobody MAY      |       |
| Nobody    | MAY         | false | true   | P MAY           |       |
| Nobody    | MAY         | false | false  | -               |       |
|-----------+-------------+-------+--------+-----------------+-------|
| Nobody    | MUST        | true  | true   | -               |       |
| Nobody    | MUST        | true  | false  | Nobody must     |       |
| Nobody    | MUST        | false | true   | -               |       |
| Nobody    | MUST        | false | false  | -               |       |
|-----------+-------------+-------+--------+-----------------+-------|
| Nobody    | SHANT       | true  | true   | Everybody MAY   |       |
| Nobody    | SHANT       | true  | false  | Nobody SHANT    |       |
| Nobody    | SHANT       | false | true   | P MAY           |       |
| Nobody    | SHANT       | false | false  | -               |       |

*** <<<WITH limb>>>: attributes
The "With" limb assigns attributes to the subject of an ENTITY, DEFINE, or WHERE clause.

#+begin_src bnfc :noweb-ref l4bnfc
  rules      WithLimb  ::= | WithHas "{" [WithIn] "}";
  rules      WithHas   ::= "WITH" | "HAS" | "TYPE" ;
  rules      WithIn    ::= [Constraint] | TraceExpr;
  separator nonempty WithIn ";";
#+end_src

A lower-case entity is an individual -- a concrete "instance".

#+begin_src haskell :noweb-ref l4entity
  RULE mkVeggieBar
    ENTITY veggieBar
       ISA Business
      WITH address = [ "1 Veggie Way" ]
           id      = { idtype = "UEN", idval = "202000000A" }
           name    = "The Veggie Bar Pte. Ltd."
#+end_src

But you can also use WITH to define the abstract form -- you might call it a record type, or an interface, or a class; it starts with an upper-case letter.

If you have any OOP experience, e.g. TypeScript or Python, this should look familiar. Heck, this should make sense even if you're from Haskell world.

#+begin_src haskell :noweb-ref l4entity
  RULE    Business
    DEFINE Business
       ISA Record
      WITH address = [ String ]
           id      = [ { idtype = "UEN" , idval = UENString }
                     | { idtype = String, idval = String } ]
           name    = String
           owner   = Person
#+end_src

#+begin_src haskell :noweb-ref l4entity
  RULE     Person
    DEFINE Person
       ISA Record
      WITH address = [ String ]
           id      = [ { idtype = "UEN" , idval = UENString }
                     | { idtype = String, idval = String }
                     ]
           name    = String
           type    = [ "Natural" , "Corporate" | "Trust" ]
  
  RULE Human     DEFINE Human     ISA Person WITH type = "Natural"
  RULE Company   DEFINE Company   ISA Person WITH type = "Corporate"
  RULE Signatory DEFINE Signatory ISA Human  WITH principal = [ Person ]

  RULE     Signatories
    DEFINE Document
       ISA Record
      WITH parties     = [ Person ]
           signatories = [ Signatory ]
           witnesses   = [ Human ]
      WHEN [ "each signatory has a principal which is a party"
           , "each party is a principal of a signatory"
           , "number of witnesses >= 2"
           & "no witness is a party" ]
 
#+end_src

(Yes, the "id" attribute above has two alternative shapes -- think of it as a sum type.)

You can also use a DEFINE rule to define a type whose values must obey a certain regex:

#+begin_src haskell :noweb-ref l4entity
  RULE     UENString
    DEFINE String
       ISA UENString
      WHEN . ~ regex.pcre("^\"\\d{9,10}[[:alpha:]]$\"")
#+end_src

Failure to obey that regex is a compile-time error.

It is real tempting to say, "hey, if we can do regex, why not go all the way with dependent types?"

*** <<<ASOF Limb>>>: system time

Relevant to multitemporality ---

The "ASOF" limb is syntactic shorthand for indicating a default system time.

It can attach to "WITH" facts declared immediately prior.

It can also attach to a top-level rule immediately before the "META" limb. This is intended to support legislative and contractual amendments.

#+begin_src bnfc :noweb-ref l4bnfc
  Asof.      Asof      ::= "ASOF" DateTime ;
  AsofNull.  Asof      ::= ;
  rules      DateTime  ::= Iso8601 | "PRESENT" | "NOW" ;
  rules      Iso8601   ::= YYYYMMDD | YYYYMMDDTHHMM;

  token YYYYMMDD      ( digit digit digit digit '-'? digit digit '-'? digit digit );
  token YYYYMMDDTHHMM ( digit digit digit digit '-'? digit digit '-'? digit digit 'T' digit digit digit digit );
#+end_src

We support ISO8601 formats for dates and times.

In the future a more comprehensive time library will make it possible to say things like "the fifth Friday of every month, failing which the third Thursday."

*** <<<META Limb>>>: for priority rules

An optional rule that establishes priority when other rules conflict.

#+begin_src bnfc :noweb-ref l4bnfc
Meta0.       MetaLimb ::= ;
#+end_src

**** Notwithstanding

#+begin_src bnfc :noweb-ref l4bnfc
MetaNOTW.    MetaLimb ::= "NOTW" RuleDef ;
#+end_src

**** Subject To

#+begin_src bnfc :noweb-ref l4bnfc
MetaSubj.    MetaLimb ::= "SUBJ" RuleDef ;
#+end_src

**** TODO Scope

We should probably handle scoping restrictions within DEFINE expressions, using the GIVEN limb to inspect the call stack.

**** TODO For the purposes of

This can probably be done as a floating DEFINE.

*** WHERE

"Where" offers bindings similar to those found in Haskell. This is a convenient place to go into detail about concepts which are mentioned briefly in the main body.

#+begin_src bnfc :noweb-ref l4bnfc
  WhereLimb0.     WhereLimb ::= ;
  WhereLimb1.     WhereLimb ::= "WHERE" "{" [WhereExp] "}" ;
  rules     WhereExp  ::= GivenLimb Constraint WithLimb WhenLimb WhereLimb ;

  separator nonempty WhereExp ";";
#+end_src

A "where" limb is very similar structurally to a DEFINE rule.

** <<<Advanced Rule Bodies>>>
**** CLOSE

A CLOSE rule terminates one or more rules that the contract may have been "listening" for.

#+begin_src bnfc :noweb-ref l4bnfc
  RClose1.     RuleBody       ::= UponLimb GivenLimb CloseLimb WhenLimb HenceLimb WhereLimb;
  CloseLimb1.  CloseLimb      ::= "CLOSE" [Exp] ;
#+end_src bnfc :noweb-ref l4bnfc

**** TODO ASSERT

A rule that describes, using LTL/CTL, certain properties of the obligation graph.

Violations of these properties can be found by a model checker.

The syntax for assertion rules has not yet been defined.

See [[https://www.seas.upenn.edu/~lee/09cis480/lec-part-4-uppaal-input.pdf][UPPAAL's syntax]] for an inspiration.

**** TODO EPIRULE or META or HOrule

A rule that activates or deactivates other rules.

**** Debug: Matchtype

The "MATCHTYPE" rule body is for debugging purposes only.

#+begin_src bnfc :noweb-ref l4bnfc
  RMatch.  RuleBody  ::= "MATCHTYPE" "{" [MatchVars] "}";
  rules    MatchVars ::= "Constraint"  Constraint
                       | "ObjMethod"   ObjMethod
                       | "ObjAttr"     ObjAttr
                       | "ObjAttrElem" ObjAttrElem
                       | "UnifyExpr"   UnifyExpr
                       | "UnifyElem"   [UnifyElem]
                       | "Exp"         Exp
                       | "LstExp"      LstExp
                       | "BinExp"      BinExp
                       | "CaseExpr"    CaseExpr
                       | "WhenLimb"    WhenLimb
                       | "WhereLimb"   WhereLimb
                       | "DeonticLimb" DeonticLimb
                       | "DefineLimb"  DefineLimb
                       | "BraceList"   BraceList
                       | "HenceLimb"   HenceLimb
                       | "MatchQualifier"  MatchQualifier
                       | "MatchQuantifier" MatchQuantifier
                       | "MatchRelation"   MatchRelation
                       | "MatchFlag"       MatchFlag
                       | "RuleBody"    RuleBody
                       | "Rule"        Rule;

  separator nonempty MatchVars ";";
#+end_src


**** NOOP

A rule body that does nothing. This is just for dev testing. By convention this rule is always considered satisfied when evaluated -- it is vacuously true.

#+begin_src bnfc :noweb-ref l4bnfc
  RBNoop.    RuleBody  ::= "NOOP";
#+end_src

This doesn't appear in real contracts.

** Other Top-Level Keywords

*** Module declaration

Modules are how we do namespaces. The import and export syntax borrows from Haskell.

An L4 Module is a file.

The /default name/ of the module is derived from its import statement, minus any ~.l4*~ extension.

The following import statements result in the following default module names:

| import                                          | default name |
|-------------------------------------------------+--------------|
| ~import "Foo/Bar/Baz.l4"~                       | Foo.Bar.Baz  |
| ~import "/usr/local/share/L4/./Foo/Bar/Baz.l4"~ | Foo.Bar.Baz  |
| ~import "test/./Foo/Bar/Baz.l4"~                | Foo.Bar.Baz  |

The default name is made by
- deleting any prefix matching the regex ~^.*/\.+/~
- deleting any suffix matching the suffix ~\.l4\w*$~
- converting any directory separators to dots

A module can explicitly give itself a name by saying

#+begin_src haskell :noweb-ref l4-example1
  module Foo.Bar.Baz where
#+end_src

#+begin_src bnfc :noweb-ref l4bnfc
  ModuleDecl. Module ::= "module" ObjAttr "where";
#+end_src

An L4 Module contains a list of directives and statements.

#+begin_src bnfc :noweb-ref l4bnfc
  Toplevel.  Tops      ::= [Toplevels];
  rules      Toplevels ::= Module | Import | Pragma
                         | Rule | Scenario
                         | Group | Section ;
  terminator Toplevels ";";

  layout toplevel;
  layout "WITH", "TRACE", "WHERE", "MATCHTYPE", "HAVING", "CASE", "GROUP", "SECTION", "THEN", "ELSE";
  entrypoints Tops;
#+end_src

*** import statement

Suppose we have a ContractLaw library:

#+begin_src haskell :noweb yes :tangle bnfc/l4/ContractLaw.l4
  module ContractLaw where
#+end_src

Other modules are welcome to import this module.

#+begin_src haskell :noweb-ref l4-example1
  import ContractLaw
#+end_src

Syntax for an import expression:

#+begin_src bnfc :noweb-ref l4bnfc
  Import. Import ::= "import" ObjAttr ;
#+end_src

They would end up with ~elements~ in the namespace, explicitly referenceable as ContractLaw.Rule.1

*** group: 

Statement Groups collect multiple other top-levels

#+begin_src bnfc :noweb-ref l4bnfc
  rules Group ::= "GROUP" RuleDef RuleName [Toplevels] ;

  rules Section ::= "SECTION" RuleDef RuleName WithLimb WhereLimb ;
#+end_src

*** pragma: version

Pragma directives give hints to the compiler.

#+begin_src bnfc :noweb-ref l4bnfc
  rules Pragma ::= "pragma" [Exp] ;
#+end_src

*** Top-level SCENARIO stanzas represent traces of events

#+begin_src bnfc :noweb-ref l4bnfc
  RScenario. Scenario ::= "SCENARIO" ObjAttr WithLimb TraceExpr Asof WhereLimb ;
#+end_src

A "Trace" is syntactic sugar for a "With" limb for perdurants -- facts about an individual or a scenario that are bounded in time.

#+begin_src bnfc :noweb-ref l4bnfc
  rules      TraceExpr ::= "TRACE" "{" [LogEvent] "}";
  rules      LogEvent ::= Iso8601 ObjAttr ObjAttr [Blah] ;
  separator  nonempty LogEvent ";";
  separator  Blah "";
  rules      Blah     ::= Exp;
#+end_src

*** History

A "HISTORY" stanza outlines the version history of a particular file, and indicates where previous versions of this ruleset may be found. Because this ruleset may refer to previous versions.

*** Metaprogramming with pattern macros

Basically, macro expansions and function definitions.

#+begin_src l4
  PATTERN myfirstpattern
  WHEREVER RuleMatchExpr // a lens-style? regex-style? pattern match against one or more rules
  TRANSFORM  AliasExpr
  TO         ReplacementExpr
  ...
#+end_src

TODO For example we expand a rule about potatoes to also apply to cabbages, expanding ~item.isPotato~ to ~(item.isPotato OR item.isCabbage)~ in the body of any Horn clause.

** Syntax
*** Comments

C-style and Javascript-style comments are both supported. Also Haskell-style, as a nod to our implementation language.

#+begin_src bnfc :noweb-ref l4bnfc
    comment "//" ;
    comment "--" ;
    comment "/*" "*/" ;
#+end_src

*** String Expressions

A normal string looks "like this" and obeys the usual conventions around escaped backslashes, quotes, and newlines.

*** Language Stringset

Language strings assist with NLG. They start with a colon-bracketed language ID prefix, like ":en:". Technically, one or more comma-separated ISO639-1 language codes, where dashes and underscores are accepted. The first letter must be lowercase.

Any place you can have one language string, you can have more, forming a /stringset/:

#+begin_example
:en:"potato"
:fr:"pomme de terre"
#+end_example

BNF:

#+begin_src bnfc :noweb-ref l4expressions
ELangStrings. LangStrings  ::= [LangString] ;
    separator nonempty LangString " ";
ELangString.  LangString   ::= LangID String ;
rules         LangID       ::= ":" [LangLabel] ":";
rules         LangLabel    ::= Ident ;
    separator nonempty LangLabel "," ;
#+end_src

Currency strings are the same but uppercase, like "USD".

*** Currency expressions

Currencies are expressed specifically as ~:SGD: 1400~ or generically as ~$~. When it's a currency variable you gotta prefix it, sorry. It'll go away when we have better type inferencing later.

Many contracts deal with dollar calculations. L4 supports composable primitives and functional idioms for mathematical expressions.

For now the parser reads currency and math expressions together.

*** A Simply Typed Abstract Syntax

Martin suggested around 2020-09-24 a more polymorphic abstract syntax for L4. The below representation doesn't have type parameters, so work will rebalance from the parser to the type checker.

#+begin_src bnfc :noweb-ref l4bnfc
  coercions Exp 9;
  ConstE. Exp8 ::= ConstVal;
  CaseE.  Exp7 ::= CaseExpr ;
  ListE.  Exp7 ::= LstExp ;
  BracesE. Exp7 ::= BraceList ;
  TempE.  Exp7 ::= DateTime ;
  UnifyE. Exp6 ::= UnifyExpr;
  ObjME.   Exp6 ::= ObjMethod ;
  Op1E.   Exp5 ::= UnaOp   Exp ;
  Op2E.   Exp4 ::=         BinExp ;
  Op3E.   Exp3 ::= TriOp   Exp7 Exp7 Exp7; ;
  Op3ETern1.  Exp2 ::=         Exp "?"    Exp ":"    Exp;
  Op3ETern2.  Exp2 ::=    "IF" Exp "THEN" [ExpStm] ; -- classic "dangling else" reduce conflict here
  Op3ETern3.  Exp2 ::=    "IF" Exp "THEN" [ExpStm] "ELSE" [ExpStm];

  ExpStm1.    ExpStm ::= Exp;
  ExpStmLet.  ExpStm ::= "LET" Exp;
  separator nonempty ExpStm ";"; -- used inside THEN and ELSE

  ListComp1.   LstExp ::=    "[" Exp "FOR" ObjAttr "IN" Exp "]" ;
  ListComp2.   LstExp ::=    "[" Exp "FOR" ObjAttr "IN" Exp "IF" Exp "]" ;
  ListComp3.   LstExp ::=    "["           ObjAttr "IN" Exp "IF" Exp "]" ;
  ListComp4.   LstExp ::=    "["           ObjAttr "IN" Exp          "]" ;
  ListComma.  LstExp ::=    "[" [Exp]         "]" ;
  ListAnd.    LstExp ::=    "[" [Exp] "&" Exp "]" ;
  ListOr.     LstExp ::=    "[" [Exp] "|" Exp "]" ;
  separator nonempty Exp "," ;

  TriOpITE. TriOp ::= "ITE" ;

  BoolV_T. ConstVal ::=  TrueBool ;
  BoolV_F. ConstVal ::= FalseBool ;
  BoolV_N. ConstVal ::= NothingBl ;
  IntV.    ConstVal ::= Integer ;
  FloatV.  ConstVal ::= Double ;
  StringV. ConstVal ::= String ;
  FloatPercent.  ConstVal ::= Double  "%" ;
  IntPercent.    ConstVal ::= Integer "%" ;

  coercions BinExp 8;
  BArith_Pow.  BinExp7   ::= Exp5 "**"   Exp6;
  BArith_Mul.  BinExp4   ::= Exp4 "*"    Exp5;
  BArith_Div.  BinExp4   ::= Exp4 "/"    Exp5;
  BL_In.       BinExp4   ::= Exp4 "IN"   Exp5;
  BL_Modulo1.  BinExp4   ::= Exp4 "%"    Exp5;
  BL_Modulo2.  BinExp4   ::= Exp4 "%%"   Exp5 "->" Exp5; -- rewrite
  BArith_Plus. BinExp3   ::= Exp4 "+"    Exp5;
  BArith_Sub.  BinExp3   ::= Exp4 "-"    Exp5;
  L_Join.      BinExp3   ::= Exp4 "++"   Exp5;
  BCmp_LT.     BinExp2   ::= Exp4 "<"    Exp5;
  BCmp_LTE.    BinExp2   ::= Exp4 "<="   Exp5;
  BCmp_GT.     BinExp2   ::= Exp4 ">"    Exp5;
  BCmp_GTE.    BinExp2   ::= Exp4 ">="   Exp5;
  BCmp_Eq1.    BinExp2   ::= Exp4 "="    Exp5; -- constraint unification
  BCmp_Eq2.    BinExp2   ::= Exp4 "=="   Exp5; -- constraint unification
  BCmp_Eq3.    BinExp2   ::= Exp4 "==="  Exp5; -- object reference identity
  BCmp_Neq1.   BinExp2   ::= Exp4 "/="   Exp5;
  BCmp_Neq2.   BinExp2   ::= Exp4 "!="   Exp5;
  BAssign2.    BinExp2   ::= Exp4 ":="   Exp5;
  BCmp_Match1. BinExp2   ::= Exp4 "~"    Exp5;
  BCmp_NMatch. BinExp2   ::= Exp4 "!~"   Exp5;
  BRel_Is.     BinExp1   ::= Exp4 "IS"   Exp5;
  BRel_Isa.    BinExp1   ::= Exp4 "ISA"  Exp5;
  BRel_Has.    BinExp1   ::= Exp4 "HAS"  Exp5;
  BRel_Are.    BinExp1   ::= Exp4 "ARE"  Exp5;
  BRel_To.     BinExp1   ::= Exp4 "TO"   Exp5;
  BBool_And1.  BinExp    ::= Exp4  "∧"   Exp4;
  BBool_And2.  BinExp    ::= Exp4  "&&"  Exp4;
  BBool_And3.  BinExp    ::= Exp4  "AND" Exp4;

  BBool_Or1.   BinExp    ::= Exp  "∨"   Exp;
  BBool_Or2.   BinExp    ::= Exp  "||"  Exp;
  BBool_Or3.   BinExp    ::= Exp  "OR"  Exp;

  Set_Union1.     BinExp ::= Exp  "U"   Exp;
  Set_Union2.     BinExp ::= Exp  "∪"   Exp;
  Set_Union3.     BinExp ::= Exp  "UNION"   Exp;
  Set_Intersect1.  BinExp ::= Exp  "∩"   Exp;
  Set_Intersect2.  BinExp ::= Exp "INTERSECT" Exp ;
  Set_Subset1.     BinExp ::= Exp  "⊂"   Exp;
  Set_Subset2.     BinExp ::= Exp  "SUBSET"   Exp;

  BBool_Unless.    BinExp ::= Exp  "UNLESS"   Exp;


  coercions UnaOp 7;
  UCurr.       UnaOp7 ::= CurrencyPrefix ;
  CurrCode.     CurrencyPrefix ::= ":" UIdent ":" ;
  CurrDollar.   CurrencyPrefix ::= "$";

  UBool_Not1.  UnaOp6 ::= "!"  ;
  UBool_Not2.  UnaOp6 ::= "NOT" ;
  UBool_Not2.  UnaOp6 ::= "¬" ;
  UBool_Unlikely.  UnaOp5 ::= "UNLIKELY" ;
  UBool_Likely.    UnaOp5 ::= "LIKELY" ;

  L_All.       UnaOp5 ::= "ALL";
  L_Any.       UnaOp5 ::= "ANY";
  L_Xor.       UnaOp5 ::= "XOR";

#+end_src


*** Boolean expressions

We should have a discussion at some point about how our expression model is
- partly functional (functions evaluate to values)
- partly logical (terms unify to values)

If you have a background in logic programming this will be easier to grasp.

Have a look at [[http://curry-lang.org/][Curry]] and [[http://www.picat-lang.org/][Picat]] if you get the chance.

A boolean expression can be labeled Likely or Unlikely to serve as a hint to a reasoner.

At the moment this syntax is static. In the future it would be nice to be able to compute the likelihood of a constraint expression dynamically.

*** Boolean expressions comparing math expressions

#+begin_src bnfc :noweb-ref l4bnfc
  token TrueBool  ["Tt"] ["Rr"] ["Uu"] ["Ee"] ;
  token FalseBool ["Ff"] ["Aa"] ["Ll"] ["Ss"] ["Ee"];
  token NothingBl ["Nn"] ["Oo"] ["Tt"] ["Hh"] ["Ii"] ["Nn"] ["Gg"] ;
#+end_src

*** Match Relations

We deprecate the "~" sigil in favour of a more verbose form:

Example 1:

#+begin_src text :noweb-ref l4-rules
  RULE    noblePotato4
   DEFINE Item IS noble
     WHEN AT LEAST 2 OF Item.previousOwners
          EACH SATISFIES
          AT LEAST 1 OF [ isKing, isQueen, isPrince, isPrincess
                        , isDuke, isDuchess, isEarl, isCountess ] DISTINCT,NO-REPEATS
#+end_src

The generic structure of a match relation is:

- ObjQuantifier :: (at least N | any | all | exactly N | at most N | none) (of)?
- ObjList :: object(s)
- MatchQualifier :: "EACH" | "TOGETHER" ;
- MatchRelation :: satisfies | satisfy | matches | match | is | are | isa | areA | exists | exist
- PredQuantifier :: (at least N | any | all | exactly N | at most N | none ) (of)?
- PredList :: predicate(s)

where the predicate has type ~object -> Bool~

BNF:

#+begin_src bnfc :noweb-ref l4bnfc
  BCmp_Match2. BinExp2   ::= MatchQuantifier Exp6 AsAlias MatchQualifier MatchRelation
                             MatchQuantifier Exp6 AsAlias [MatchFlag];
  -- ConstVal here will probably need to be upgraded to at least a variable
  -- so we can say, TheRelevantQuorum.Percentage
  MQuant0.      MatchQuantifier ::= "NONE OF" ;
  MQuantMin.    MatchQuantifier ::= "AT" "LEAST" ConstVal OptOf ;
  MQuantAny.    MatchQuantifier ::= "ANY" "OF" ;
  MQuantAll.    MatchQuantifier ::= "ALL" "OF" ;
  MQuantConst.  MatchQuantifier ::= "EXACTLY" ConstVal "OF" ;
  MQuantMax.    MatchQuantifier ::= "AT" "MOST" ConstVal OptOf ;
  MQuantNull.   MatchQuantifier ::= ;
  MRelSat1.    MatchRelation   ::= "SATISFIES" ;
  MRelSat2.    MatchRelation   ::= "SATISFY" ;
  MRelMatch1.  MatchRelation   ::= "MATCHES" ;
  MRelMatch2.  MatchRelation   ::= "MATCH" ;
  MRelIs1.     MatchRelation   ::= "IS" ;
  MRelIs2.     MatchRelation   ::= "ARE" ;
  MRelExist1.  MatchRelation   ::= "EXISTS" ;
  MRelExist2.  MatchRelation   ::= "EXIST" ;

  OptOfNull.   OptOf           ::= ;
  OptOf.       OptOf           ::= "OF";

  MQualEach.      MatchQualifier ::= "EACH";
  MQualTogether.  MatchQualifier ::= "TOGETHER";
  MQualNull.      MatchQualifier ::= ;

  MFlagLDistinct. MatchFlag     ::= "L-DISTINCT" ;
  MFlagRDistinct. MatchFlag     ::= "R-DISTINCT" ;
  MFlagBDistinct. MatchFlag     ::=   "DISTINCT" ;
  MFlagNoRepeat.  MatchFlag     ::= "NO-REPEATS" ;
  separator MatchFlag ",";
#+end_src


*** Lists

Most programming languages have the concept of lists, or arrays. Usually, elements of those lists are separated by commas.

**** Junction Lists

This is experimental and may go away.

In L4, comma lists work as usual. But we also have and-lists and or-lists, which are separated by "&" and "|" respectively.

Internally we call these "junction lists" for "conjunction" and "disjunction". We are careful to define everything here, no room for ambiguity. Because https://www.lectlaw.com/def/c282.htm says: "There are many cases in law where the conjunctive 'and' is used for the disjunctive 'or' and vice versa."

The semantics depend on context:

| symbol | set context  | propositional context |
|--------+--------------+-----------------------|
| &      | intersection | and                   |
| \vert  | union        | or                    |

Read chapter 11 of MSCDv4. The remainder of this section attempts to formalize all of the possible variants from that chapter.

| example               | ~ | list        | means                           |
|-----------------------+---+-------------+---------------------------------|
| some.Unification.term | ~ | [x & y]     | forall u in U, exists u in {x, y} |
| some.Unification.term | ~ | [x \vert y] | exists u in U, exists u in {x, y} |

**** TODO Early thoughts on Lists

This section is obsolete and scheduled for deletion.

In Haskell, ~Data.List.all~ tests a single predicate against a collection of ~a~ values. You can say: the members of the Polydactyly Society are ~all polydactyl~. "Polydactyl" is the predicate. "The Polydactyly Society" is the collection. ~all polydactyl society~ returns ~True~.

#+begin_src haskell
  polydactyl :: Cat -> Bool
  polydactyl cat = length cat.frontLeft.toes  > 5 ||
                   length cat.frontRight.toes > 5

  society = filter polydactyl allcats
#+end_src

But sometimes you want to test a single value against a collection of predicates. Sometimes you want all the predicates to match.

#+begin_example
kitchen.canMakeNeapolitan = kitchen ~ [ hasChocolate
                                      & hasVanilla
                                      & hasStrawberry ]
#+end_example

Sometimes you want to test if any of the predicates match.

#+begin_example
dish.isDangerous = dish ~ [ hasPeanut     -- (hasPeanut dish) == True
                          | hasWalnut
                          | hasAlmond ]
#+end_example

The machinery for this:

#+begin_src haskell :tangle bnfc/blah/Preds.hs
module Preds where

  allPreds :: Foldable t => t (a -> Bool) -> a -> Bool
  allPreds preds value = all (flip ($) value) preds

  anyPreds :: Foldable t => t (a -> Bool) -> a -> Bool
  anyPreds preds value = any (flip ($) value) preds

  numPreds ::                [ a -> Bool ] -> a -> Int
  numPreds preds value = length (filter (flip ($) value) preds)

  xorPreds ::                [ a -> Bool ] -> a -> Bool
  xorPreds preds value = 1 == numPreds preds value

#+end_src

In L4, collections of predicates are called "junction lists". The term comes from "conjunctions" and "disjunctions", hence "junctions".

In L4, a *conjunctive list* is defined as a list of two or more predicates, in which the last two predicates are separated by a ~&~ character, for "and".

In L4, a *disjunctive list* is defined as a list of two or more predicates, in which the last two predicates are separated by a ~|~ character, for "or".

In L4, an *exclusive list* is defined as a list of two or more predicates, in which the last two predicates are separated by a ~X~ character, for "exclusive or".

In a junction list of three or more elements, the earlier predicates in the list can be separated by a comma "," or by the same as the final separator.

This makes it easy to write:

#+begin_example
  cats = [ alice
         , bob
         , carol
         , dan
         ]

  special = [ polydactyl
            | tailless
            ]

  valuable = [ polydactyl
             & tailless
             ]
#+end_example

Conjunctive lists are syntactic sugar for ~all~.

Disjunctive lists are syntactic sugar for ~any~.

Exclusive lists are syntactic sugar for ~oneOf~.

Lists can nest.

Next we talk about matching.

#+begin_example
  specialCats  = [ polydactyl | tailless ] cats
  valuableCats = [ polydactyl & tailless ] cats

  // note that we do NOT support these alternatives in L4 syntax:
  specialCats  = any [ polydactyl, tailless ] cats
  valuableCats = all [ polydactyl, tailless ] cats

  dish.isDangerous = dish [ hasPeanut
                          , hasWalnut
                          | hasAlmond ]
#+end_example

Space application is overloaded as follows:

| LHS            | RHS              | meaning                                         |
|----------------+------------------+-------------------------------------------------|
| junction list  | single value     |                                                 |
| single value   | junction list    | boolean                                         |
|----------------+------------------+-------------------------------------------------|
| junction list  | list of values   | filter for values which match the junction list |
| list of values | junction list    | filter for values which match the junction list |
|----------------+------------------+-------------------------------------------------|
| list of values | single predicate |                                                 |

The semantics of a conjunctive list:
#+begin_src haskell :tangle bnfc/blah/Matchable.hs
  module Matchable where

  -- TODO: make this work!

  class Matchable a where
    match  :: (Eq a, Foldable t) => a -> t a -> Bool

  newtype ConjList a = ConjList [a]
  newtype DisjList a = DisjList [a]

  instance Matchable (ConjList a) where
    match x = all (== x)

  instance Matchable (DisjList a) where
    match x = any (== x)
#+end_src

****** "Any" and "all"

Yay English! What's the difference between

"Any zombies will be shot on sight"

and

"All zombies will be shot on sight"

?

No difference!

This is why it's dangerous to reuse words with a rich existing history -- at some point, people will guess wrong.

First-order logic knows how to deal with this situation. That's why we have \exists and \forall.

See also https://inariksit.github.io/cclaw-zettelkasten/ambiguity_of_and.html

*** Defining Objects and Attributes

As in Javascript, objects contain a dictionary of attributes.

As in Haskell, we'd talk about a record type.

**** Object Attributes

L4 uses customary ~record.attribute~ notation for most things.

#+begin_src bnfc :noweb-ref l4bnfc

  rules      ObjAttrElem  ::= Ident | UIdent ;            -- Foo

  OA_dots.   ObjAttr      ::= [ObjAttrElem];              -- Foo.Bar.Baz
  separator nonempty ObjAttrElem ".";
  separator nonempty ObjAttr     ",";
#+end_src

**** Automatic singular / plural support for attributes

In normal languages, ~object.party~ is a different attribute than ~object.parties~.

However, our language knows English grammar, so those two attributes automatically bind to the same referent, allowing more natural expression:

- ~object.party[A]~
- ~object.party[B]~
- ~object.parties[ALL]~
- ~object.parties[A & B]~
- ~object.parties[A | B]~

This may turn out to be a bad idea.

**** Method Syntax with Args

You can chuck parens on the end of an object attribute, and you end up with an object method.

- ~object.party(foo=bar)~

Note that the parameters are named, as Python does it.

Actually, though, these parameters are constraints, so you could also say

- ~object.party(age >= 21)~

#+begin_src bnfc :noweb-ref l4bnfc
  rules      ObjMethod  ::= [UnifyElem] Args OptLangStrings;
  rules      Args       ::= | "(" [Constraint] ")";
#+end_src

**** Unification Syntax

So ObjMethod turns out to have a trick up its sleeve: it can /unify/ variable elements.

And that works even without the paren args.

#+begin_src bnfc :noweb-ref l4bnfc
  rules      UnifyExpr ::= [UnifyElem] ;
  rules      UnifyElem ::= ObjAttrElem
                        |  UnifyBracket
                        |  UnifyStar
                        |  "."; -- ideally we would have foo..bar and not foo...bar
  separator nonempty UnifyElem ".";
  rules      UnifyStar ::= "*" ;
  rules      UnifyBracket ::= "<" [CommaElem] ">" ;
  rules      CommaElem ::= ObjAttr;
  separator nonempty CommaElem ",";
#+end_src

"*" is the simplest pattern-match: it matches any value of any attribute.

More complex pattern-matches can be specified using double square brackets. In future we want this to be single square brackets, maybe when we are less scared of reduce/reduce conflicts at the moment.

See Constraint Unification for details.

*** <<<Constraint Unification>>>

"WITH" limbs look like "foo == bar". But they're actually constraint relations, and you can do multiples of them.

#+begin_src bnfc :noweb-ref l4bnfc
  rules BraceList     ::= "{" [Constraint] "}" ;
  rules  Constraint   ::= Exp;
  separator nonempty Constraint  "," ;

  -- rules ConstraintBinOp ::= "=" | "<" | ">" | "<=" | ">=" | "==" | "IS" | "ISA" | "ARE" | "HAS";
#+end_src

TODO: figure out "=" vs "==".

#+begin_src haskell :noweb-ref l4entity
 RULE mkMinor
  DEFINE Minor
     ISA Human
    WHEN CASE self.nationality ~ ["US", "SG"]             -> self.age < 21
              self.nationality ~ ["NZ", "TW", "TH", "JP"] -> self.age < 20
              otherwise                                   -> self.age < 18
#+end_src

Note that "self" and "this" are synonymous.

In the future Meng would like to allow:
- .attr :: self.attr
- ./attr :: self.attr
- ../attr :: parent.attr
- ..attr :: parent.attr

Oh right, we need case expressions.

#+begin_src bnfc :noweb-ref l4bnfc
  rules CaseExpr  ::= "CASE" "{" [CaseExp] "}" ;
  rules CaseExp   ::= Exp "->" Exp;
  separator nonempty CaseExp ";";
#+end_src

When there's a CASE, there's a decision table. Let's support DMNMD syntax for decision tables:

#+begin_src haskell
  RULE mkMajor
    ENTITY Major
       ISA Human
      WHEN TABLE
           | F | nationality (in) | age (in) | return |
           |---+------------------+----------+--------|
           | 1 | US, SG           | >= 21    | true   |
           | 2 | NZ, TW, TH, JP   | >= 20    | true   |
           | 3 | -                | >= 18    | true   |
           | 4 | -                | -        | false  |
#+end_src

This has not yet been implemented.

(If you're an Emacs user, discover M-x orgtbl-mode :)

*** THIS IS STILL UNDER CONSTRUCTION

We define a travel budget for a given month as the number of employees living in certain states multiplied by the one-way plane fare, times 2 (rough approximation to roundtrip fare), when the month is June or September.

Due to cost-cutting measures, there is no travel budget in any other month.

Due to cost-cutting measures, only those lucky employees living in two regions are allowed to travel.

In Haskell we would write something like:

#+begin_src haskell :tangle rando.hs
  newtype Month = M String deriving (Show, Eq)
  type    PlaneFare = Int
  data    Employee = E { state :: State, country :: Country } deriving (Show, Eq)
  newtype StaffDirectory = SD [Employee] deriving (Show, Eq)
  type    State = String
  type    Country = String

  travelBudget :: Month -> PlaneFare -> StaffDirectory -> [State] -> Int
  travelBudget month fare staffdir luckyStates
    | month `elem` [M "jun", M "sep"] = fare * 2 * sum (employeesIn staffdir <$> luckyStates)
    | otherwise = 0

  employeesIn :: StaffDirectory -> State -> Int
  employeesIn (SD es) s =
    length $ filter (s ==) (state <$> es)

  main = do
    let staffdir = SD [ E "CA" "US"
                      , E "BC" "CA"
                      , E "ON" "CA"
                      , E "PA" "US"]
    let pf = 100
    print $ travelBudget (M "jun") 100 staffdir ["CA", "BC"]
#+end_src

Let's try it in L4. We note that the record types for objects in L4 are less monomorphic than in Haskell, which is why we allow some staff to have "province" and other staff to have "state" attributes; we basically want our objects to feel loosey-goosey, the way a generation of JSON and MongoDB programmers have learned to expect.

#+begin_src sql
   GIVEN planeFare, staffDir, month
  DEFINE travelBudget = numberOf(Employees) * planeFare * 2
    WHEN month ~ ["jun", "sep"]
         staffDir.Employees.country ~ ["CA","US"]
         staffDir.Employees.[province,state] ~ ["BC","CA"]
#+end_src

When there's a list on the right, I pronounce "~" "is in", like with SQL.

The system infers that:
- ~staffDir~ is a record
  - with an ~.employees~ attribute which is a list of records
    - with a ~.country~ attribute of type String
    - with a ~.province~ attribute of type String
    - with a ~.state~ attribute of type String

How does it know that the ~.employees~ attribute is a list of records? Easy: If ~.employees~ were merely a regular attribute it would be have been in lowercase. On the other hand, it's possible that we represent employees as a dictionary of employeeID to employee record; in that case, Employees would be the list of employee IDs.

Note that the repeated use of Employees continues to refine the constraint on Employees.

The first use unifies Employees with all the elements of the list whose ~.country~ is ~"CA"~ or ~"US"~.

The second use further constrains Employees to those whose ~.province~ or ~.state~ attributes are ~"BC"~ or ~"CA"~.

The resulting Employees is available to the main body of the DEFINE, where numberOf, aka "length", turns it into an Int, and it participates in the math expressions.

Simple data types:
- String
- Numberlike

Complex data types include Lists, Records, and Maybes.

Currencies desugar to a Record of ~{currency: String, rawAmount: Int}~ where an importable module provides rows like ~{currency: "USD", bigName: "dollar", smallName: "cent", bigAmount: 100, smallAmount: 1}~

Numberlikes can be composed using the usual algebraic expressions.

Currencies can add and subtract only if they are the same currency. They can be composed with numberlikes with multiplication and division.

ObjAttrs are dot-separated strings used to represent objects and variables. Typically, they look like ~alice.address.1~ or ~alice.name.first~.

They can also contain uppercase words, for term unification: ~mycontract.parties.Party~ unifies Party against all elements of the ~parties~ array attribute, and can be subsequently used in a logic match:

~mycontract.parties.NorthAmericans.country ~ ["US" | "CA"]~

binds NorthAmericans to all those parties whose country matches US or matches CA. It is a list of parties.

~mycontract.parties.NorthAmericans.[state,province] ~ ["WA" | "BC"]~

further constrains NorthAmericans to those parties whose state is WA or province is BC.

*** Type Annotations

To give the parser a hand the current language definition lets you annotate ~Object.attributes~ with a ~:: Type~ annotation.

#+begin_src bnfc :noweb-ref l4bnfc
  TU.        TypeUnify      ::= "::" "Unify";
  TS.        TypeString     ::= "::" "STRING";
  TB.        TypeBool       ::= "::" "Bool";
  TM.        TypeMath       ::= "::" "Math";
  TOM.       TypeObjMethod  ::= "::" "ObjMethod";
  TT.        TypeTemporal   ::= "::" "Temporal";
#+end_src


*** Syntax Primitives

Higher-level constructs rely on syntax primitives.

#+begin_src bnfc :noweb-ref l4bnfc
  token UIdent (upper (letter | digit | '_')*) ; -- doesn't seem to work for single character idents though, like P
  rules      UIdentList ::= [UIdentElem];
  rules      UIdentElem ::= UIdent;
  separator nonempty UIdentElem ".";

#+end_src


*** User Guide

**** How To Try It For Yourself

A web REPL? IDE support?

**** Tutorials

This section will link to standalone tutorials that work through case studies for common scenarios.

**** Libraries for Genres:

Each of these genres requires a library -- a "sub-domain ontology".

- Contract Law :: notions of what constitutes a valid contract
- Real Estate ::
- City Planning ::

**** Formal Verification

How to perform static analysis on the programs.

**** Natural Language Generation

How to compile to natural languages.



*** How To Contribute

Github issues.

* Important Concepts

** The <<<Obligation Graph>>>

A contract, operationally, is expressed as a multi-DAG of states. We talk about nodes and edges.

Each node represents an event, a modal rule, or a definition rule.

Typically, a DAG will start with an "UPON executionDate && conditionsPrecedent" node.

The children of that node will then fan out to multiple "event listeners", one for each external choice which the contract must handle.

Each "thread" of execution within the contract corresponds to a separate start node.

Each modal node can have multiple indegrees.

The same definition rule may appear multiple times in the graph as multiple nodes.

Each definition node has exactly one outdegree.

Each event node has exactly one outdegree.

A modal rule may be a MUST, MAY, or SHANT node. Each modal node shows the actor and the action.

MUST and SHANT nodes have two outdegrees: a left exit and a right exit. In the case of a MUST node, if the actor performs the obligatory action before the given deadline, the right exit is taken. In the case of a SHANT node, if the actor successfully refrains from eating the forbidden fruit (or marshmallow) before the given deadline, the right exit is taken. Otherwise, the left exit is taken. Left is bad, right is good.

A sequence of right exits constitutes a "happy path" of the contract, and terminates in a "fulfilled" node.

Termination in a left exit node constitutes a "breach".

MAY nodes have one outdegree: if the actor exercises their option ("internal choice"), the successor node is typically a MUST or a SHANT upon the counterparty.

For convenience of representation, renderings may optimize to show multiple final nodes, or fewer. A ROBDD style representation may converge all outcomes to just two global nodes, Breach and Fulfilled. Or a rendering may display multiple Fulfilled and Breach nodes.

** <<<Multitemporality>>>

Unlike Javascript, an attribute may be /multitemporal/:
- valid time
- transaction time
- decision time

An attribute is also /multivalent/: by default, every attribute of an object can have zero or more values; informally speaking, every attribute of type X is really a list of X.

Let's take a simple example. As in Typescript, we define an instance type for a human:
- human.birthdate :: Date
- human.fullname :: String
- human.nationality :: Country

Take Neta-Lee Hershlag. She was born in Israel in 1981; at least, that is what Wikipedia believes, as of the 10th of September 2020 when I wrote this.

Guess what, though. She holds dual Israeli and American citizenship. Unusual, right? Most ontologies would only allow one citizenship to a person. Bit of a black swan. Let's use that as her codename.

#+begin_src haskell :noweb-ref l4entity
  RULE mkBlackSwan
    ENTITY blackSwan
       ISA Human
      WITH birthdate = { xtime = 2020-09-10, value = 1981-06-09 }
        // a person can have multiple nationalities
           nationality = [ { xtime = 2020-09-10, value = "IL", vtime = 1981-06-09 TO PRESENT }
                         , { xtime = 2020-09-10, value = "US"                                } ]
#+end_src

We assume that her Israeli citizenship began at birth, but Wikipedia doesn't know when she became a US citizen; all we know is that as of September 10 2020, Wikipedia said she is one. So that citizenship value doesn't define a vtime.

Let's not commit the usual [[https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/][falsehoods programmers believe about names]]. Can someone have multiple names? Sure, why not? Some people change their names when they get married; others when they switch genders; lots of variability. Sometimes people just have multiple names at the same time. Our Black Swan does too:

#+begin_src haskell :noweb-ref l4entity
  //       a person can have multiple names
           fullname    = [ { xtime = 2020-09-10, value = ["Neta-Lee Hershlag", "Natalie Portman"] } ]
#+end_src

As you can see, the "multitemporal" syntax allows us to easily handle scenarios like:
- On January 1, celebrities X and Y were known to be dating.
- By July 1, paparazzi sleuths found out that X and Y had gotten married some time in the past few months; the ceremony was said to have been held on a private island, but nobody's saying where or when it happened.
- On September 1, the couple spilled the details and shared that the wedding had happened on June 1.
- On December 1, the couple announced that they had gotten divorced on November 1.

#+begin_src haskell :noweb-ref l4entity
RULE mkCeleb
   GIVEN Tabloid HAVING ceaselessCoverage
  ENTITY celebXY
     ISA Couple
    WITH xtime = 2020-01-01, maritalStatus = dating
         xtime = 2020-07-01, maritalStatus = married
         xtime = 2020-09-01, maritalStatus = married,  vtime = 2020-06-01 TO PRESENT
         xtime = 2020-12-01, maritalStatus = married,  vtime = 2020-06-01 TO 2020-11-01
         xtime = 2020-12-01, maritalStatus = divorced, vtime = 2020-11-01 TO PRESENT
#+end_src

The "transaction time" shows when the system know something; the "valid time" shows when some situation was the case. This allows one to compute "on this date, what did we know? What was actually true?"

** Epistemics

An attribute may also be /epistemic/:
- on August 1, Alice learned that she was pregnant
- on September 1, Alice wrote a letter to Bob telling him that she was pregnant, and sent it via registered post.
- by the notice terms of their pre-nup, Bob was deemed to receive notice three days after the mail was sent, on September 4.
- on October 1, Bob claimed to have actually received the notice on September 10, due to difficulties with the postal service.

#+begin_src haskell :noweb-ref l4entity
  SCENARIO alicePregnancy
     TRACE 2020-08-01 Alice knew { pregnancy = true }
           2020-09-01 Alice told Bob { knownBy = Alice, pregnancy = true }
           2020-09-01 Alice knew { knownBy = Bob,  vtime = 2020-09-04, beliefs = { knownBy = Alice, pregnancy = true } }
           2020-10-01 Bob   knew { knownBy = Alice, beliefs = { knownBy = Alice, pregnancy = true, vtime = 2020-09-01 }, vtime = 2020-09-10 }
#+end_src

There should be as many xtimes as there are knowers.

** Inference: Querying Objects and Attributes



We can ask fine-grained questions like:
- On a given date, what did entity E, or The Public, or The System generally, believe to be true about some entity E, or some unit of knowledge K?

By default, L4 expressions will default to the latest known information at the time of decision.

*** Inference

The Cabbage case provides a good example of /normalization/. We present a few equivalent ways of saying the same thing, thanks to the inference rules of modal logic.

Let's start with the simple case:

- NOBODY MAY          sell Item
- PARTY * AS P1 SHANT sell Item
- PARTY * AS P1 MUST NOT(sell Item)

First, a point of syntax: we use the keyword ~SHANT~ to represent ~MUST NOT~.

While colloquially "may not" means "must not", in our syntax the term ~MAY NOT X~ does not mean ~SHANT X~ -- it does not bind as ~(MAY NOT) X~, but it binds as ~MAY (NOT X)~ instead. It means that you are allowed to not do X, but it is silent on whether you are prohibited from doing X.

In short, prohibition is best written "SHANT", but may also appear as "MUST NOT" or "NOT MAY".

Modal operator binding appears to be right-associative, as does negation.

| SHANT | <-> | MUST NOT | <-> | NOT MAY |

We induce an inference rule:

| NOBODY MAY X   | <-> | EVERYBODY SHANT X     |
| NOBODY SHANT X | <-> | EVERYBODY MAY X       |
| NOBODY MUST X  | <-> | EVERYBODY MAY (NOT X) |

Now what happens if we add a WHEN constraint?

- NOBODY MAY sell Item WHEN Item IS Nasty

Depending on our logic model, we may or may not choose to infer complementary deontics above the condition. In other words: *What about non-nasty items? Are they allowed to be sold?*

- NOBODY MAY sell Item <--IFF--> Item IS Nasty

In logic, this is the difference between

| well-founded semantics  | standard model semantics   |
| ternary logic           | binary logic               |
| Prolog                  | first-order logic          |
| intuitionistic logic    | law of the excluded middle |
| closed-world assumption | negation as failure        |

This also goes to a bigger point about "fail open" vs "fail closed" systems of law: https://en.wikipedia.org/wiki/No_U-turn_syndrome contrasts two defaults:

- everything not explicitly permitted is prohibited
- everything not explicitly prohibited is permitted

Suppose we want to live in a *permissive* world. We license inference of the form:

| P SHANT X WHEN Y | --> | P MAY X WHEN NOT Y       |
| P MAY X WHEN Y   | --> | P.X undefined WHEN NOT Y |
| P MUST X WHEN Y  | --> | P MAY NOT X WHEN NOT Y   |

Suppose we want to live in a *prohibitive* world. We license inference of the form:

| P SHANT X WHEN Y | --> | P.X undefined WHEN NOT Y |
| P MAY X WHEN Y   | --> | P SHANT X WHEN NOT Y     |
| P MUST X WHEN Y  | --> | P.X undefined WHEN NOT Y |

Note that permissive and prohibitive inference rules are themselves complementary.

If we want to live in a *passive* world, we could say that everything is simply undefined when not Y:

| P SHANT X WHEN Y | --> | P.X undefined WHEN NOT Y |
| P MAY X WHEN Y   | --> | P.X undefined WHEN NOT Y |
| P MUST X WHEN Y  | --> | P.X undefined WHEN NOT Y |

If we want to live in an *assumptive* world, we could always take the inference when not Y:

| P MUST NOT X WHEN Y | --> | P MAY X WHEN NOT Y       |
| P MAY X WHEN Y      | --> | P SHANT X WHEN NOT Y     |
| P MUST X WHEN Y     | --> | P MAY NOT X WHEN NOT Y   |

More on this later.

This is a little bit analogous to the "Men Are Scum" "#NotAllMen" arguments that need to be disambiguated using Exists vs ForAll quantifiers.

*** Using Object Attributes

Okay. Deep breath. Lower case and upper case are meaningful.

Specific individuals are lowercase, like blackSwan, or celebXY.

Interfaces, or classes, start with an uppercase letter, like Human or Couple.

Knols are belief structures, and have special attributes ~knownBy~, ~toldBy~, ~toldTo~, and ~beliefs~ attributes. This may go away at some point.

We use the "ASOF" keyword to give all the attributes a default ~xtime~ (transaction time). If it is omitted, it defaults to the execution time.

#+begin_src haskell :noweb-ref l4entity
  RULE buyCabbage
   ENTITY buyCabbage
      ISA ContractOfSale
     WITH date         = 2020-09-10
          jurisdiction = SG
          buyer        = blackSwan
          seller       = veggieBar
          buyer.consideration  = :USD: 10
          seller.consideration = [ item1, item2 ]
     ASOF 2020-09-10
    WHERE item1 ISA  Item
                WITH category = "vegetable"
                     species  = "Brassica oleracea"
                     cultivar = "capitata"
#+end_src

ContractLaw is a library class which abstracts the essential elements of a particular contract.

An alternative representation shows a trace of events:

#+begin_src haskell :noweb-ref l4entity
  SCENARIO saleHistory
    WITH parties = [ blackSwan, veggieBar ]
   TRACE 2020-09-01T1210 blackSwan offers     offerDetails
         2020-09-01T1211 veggieBar accepts    offerDetails
         2020-09-01T1212 blackSwan pays       veggieBar $10
         2020-09-01T1213 veggieBar deliversTo blackSwan [ item1, item2 ]
    ASOF 2020-09-10
   WHERE offerDetails = { blackSwan.consideration = $10
                        , veggieBar.consideration = [ item1, item2 ] }
         item1 ISA Item
               WITH category = "vegetable"
                    species  = "Brassica oleracea"
                    cultivar = "capitata"
                    quantity = 1
         item2 ISA Item
               WITH category = "beverage"
                    brand    = "Acme Water"
                    model    = "750mL"
                    quantity = 1
#+end_src

from which a pattern-matcher could deem that a legal contract was in place. Let's see what that looks like:

*** Matching Object Attributes

What you're about to read is basically a Horn clause. If you know Prolog, you will recognize that this is Prolog, dressed in the guise of an object-like paradigm. You might even say, "this has the same F-Logic as Flora-2", except with the syntax of SQL.

Let's start with a super simple case. Remember our good old spud?

Suppose potatoes are so rare and prized that they come with certificates of provenance tracing the history of previous owners.

#+begin_src haskell :noweb-ref l4-rules
  RULE mkSpud2
    ENTITY spud2
       ISA Item
      WITH species  = "Solanum tuberosum"
           isEdible = true
           previousOwners = [ alice, bob, charlie, daryl ]
#+end_src

What does that look like in Prolog?

#+begin_src prolog
  species(spud2, "Solanum tuberosum").
  isEdible(spud2).
  previousOwner(spud2, alice).
  previousOwner(spud2, bob).
  previousOwner(spud2, charlie).
  previousOwner(spud2, daryl).
#+end_src

Now we have an opportunity to explore relational syntax. Think Alloy.

Let's say that some of the previous owners were members of the nobility.

#+begin_src haskell :noweb-ref l4-rules
  RULE mkAlice   ENTITY alice   ISA Human WITH isNoble = true
  RULE mkBob     ENTITY bob     ISA Human WITH isNoble = false
  RULE mkCharlie ENTITY charlie ISA Human WITH isNoble = true
  RULE mkDaryl   ENTITY daryl   ISA Human WITH isNoble = false
#+end_src

In Prolog, that reads:

#+begin_src prolog
  isNoble(alice).
  isNoble(bob).
  isNoble(charlie).
  isNoble(daryl).
#+end_src

#+begin_src text :noweb-ref l4-rules
  RULE  2 edible
   DEFINE Item IS EdiblePotato
              AND TastyFood
     WHEN Item IS Potato
      AND Item IS Edible
#+end_src

Rule 2 relies on rule 3. This is backward chaining.

#+begin_src text :noweb-ref l4-rules
  RULE  3 isPotato
   DEFINE Item IS Potato
     WHEN Item.species ~ ["Solanum tuberosum" | "Mister Potatohead"]

  // an OR-LIST expands to
  // isPotato(Item) :- species(Item, "Solanum tuberosum"); species(Item, "Mister Potatohead").
  //                                                     ^
  // an AND-list would expand to
  // isPotato(Item) :- species(Item, "Solanum tuberosum"), species(Item, "Mister Potatohead").
  //                                                     ^
#+end_src

If this begins to feel weird, it's because under the hood, we're borrowing Prolog's unification and backtracking features.

Let's say a potato is Noble if at least two of its previous owners are Noble.

There are a couple ways to say that. This is one way:

#+begin_src haskell :noweb-ref l4-rules

  RULE     noblePotato
    DEFINE Item IS Noble
      WHEN Item ISA Potato
       AND Item.previousOwners.First  IS Noble
       AND Item.previousOwners.Second IS Noble
#+end_src

(Maybe this also creates an automatic Item.isNoble?)

That translates to:

#+begin_src prolog
  isNoble(Item) :- isPotato(Item),
                   previousOwner(Item, First), isNoble(First),
                   previousOwner(Item, Second), isNoble(Second),
                   First != Second.
#+end_src

This allows us to subsequently use the term Potato instead of Item:

#+begin_src haskell :noweb-ref l4-rules
  RULE     noblePotato2
    DEFINE Potato IS Noble
      WHEN Potato.previousOwners.isNoble >= 2
#+end_src

Alternative syntax:

#+begin_src haskell :noweb-ref l4-rules
  RULE     noblePotato3
    DEFINE Potato IS Noble
      WHEN Potato.previousOwners.<Owner1,Owner2> IS Noble
#+end_src
*** About Non-Monotonic Logics

Meng is skeptical about non-monotonic logics. In short, if you run a function with different arguments, of course you should expect to get different results.


** Ontology

Individuals are in lower case.

Variables, roles, and classes are in UpperCase.

Our ontology:
- ~x ISA Y~ :: x is an instance; Y is a class.
- ~Y ISA Z~ :: Y is a class; Z is a superclass.

** Roles and Entities

There are aggregate entities, like a board of directors.

There are principal/agent roles, like a trustee or someone holding power of attorney.

There are other roles, like Acting Schoolmaster, which resolve to individuals.

Let us reuse relevant semantics where available from other standards -- say, [[http://docs.oasis-open.org/legalruleml/legalruleml-core-spec/v1.0/cs02/legalruleml-core-spec-v1.0-cs02.html#_Toc38017888][LegalRuleML]].

** Scope

Should we just do scope in the Given parts of a stanza?
** Ternary Logic: "three-valued Booleans"

Let ~p :: a -> Ternary~, which is to say, ~p~ is a predicate; given an input of type ~a~, it will always return Yes, No, or Neither -- "neither" meaning "unknown", "undefined", "null", or "wat". This is an example of a [[https://en.wikipedia.org/wiki/Three-valued_logic][ternary logic]].

Here's a predicate: "has five toes on each fore paw". Most cats, the predicate returns ~true~. But some cats have [[https://en.wikipedia.org/wiki/Polydactyl_cat][polydactyly]]. It's an unusual condition. You can count the number of polydactyls per thousand, on the fingers of ... uh, let's just say it's a rare condition. For them, the predicate would return ~false~.

But what about an amputee, who has no forelegs? They don't have six toes on each foot. They don't have five toes on each foot. They don't have feet at all.

What is the hair colour of a bald man?

What is the airspeed velocity of an unladen Martian swallow?

On a form, you would write in "N/A" for "Not applicable".

That's why we need ternary logic: sometimes yes, sometimes no, sometimes neither.

Here's another predicate: "tailless". The Manx breed are considered tailless -- they are "rumpies" and "stumpies".

A cat is special if it is polydactyl.

A cat is special if it is tailless.

A cat is valuable if it is both polydactyl and tailless.

I wanted to say "a cat is special if it is polydactyl or tailless", but that brings up "exclusive or" considerations -- some might say "if it is both polydactyl and tailless than it isn't special, because it's obviously valuable instead." They're reading "xor" into the "or", in the context of the next sentence.

It isn't logical, but it's English!

So we spare ourselves all that grief by giving explicit definitions. Watch.
** Less Important Concepts -- Random Thoughts, Really

This section is due for review and possible deletion. If this is your first time through the document you can skip this section.

We build on a combination of the lamdba, mu, and pi calculi. What would we do without the Greeks?

*** Temporals: Time

We need to say things like: from T1 to T2, X was married to Y; from T3 to T4, X was married to Z. (OWL doesn't support this; it's timeless.)

We want [[https://en.wikipedia.org/wiki/Temporal_database][multi-temporality]]: at time T1, party P believed that the legislation then in effect was L1; however, at time T3, party P realized that the legislation in effect at T1 was actually L2, having replaced L1 at time T2. However, L2 made provision that at time T1, the effective result for parties in P's situation would be as if L1 were in effect.

So, we need the usual temporal notions of deadlines, durations, relative and absolute time referents, repeating periods.

- Temporals :: DMN refers to a standard temporal theory of before/overlap/after. We want to reconcile that with the Event and Situation calculi.

#+BEGIN_QUOTE
*Comment MS:* I think there are two issues involved in the above discussion of multi-temporality:
- the question how time evolves during the lifetime of a contract (assuming
  that the rule set remains stable) and which actions are / have to be taken
  at each moment by the parties involved. Formal models for this are Timed
  Automata, Petri Nets etc. These generate / accept a set of traces, and one
  can reason about them with temporal logics (LTL, CTL: "eventually / always",
  "in some / all runs") or their timed variants (TCTL: "some time in the next
  50 time units"). This technology is well understood at least in isolation,
  but maybe not in conjunction with all the other features we need.
- the question how the validity of a rule set changes over time. Seems closely
  related to the question of metarules mentioned below. These seem extremely
  difficult to deal with in full generality. A self-referential rule like
  "This rule will not be valid in a month any more" looks like a variant of
  the Liar's Paradox: Either the rule is still valid in a month (but
  shouldn't be according to what it states), or it is not valid in a month
  (but then there is no rule contradicting its validity, so as a rule
  appearing in a contract, why shouldn't it be valid?). To avoid these
  paradoxes, one would need a stratified set of rules, and a prover would have
  to iterate several times over the rule set to determine the applicable rules.
#+END_QUOTE

#+begin_quote
*Meng's thoughts*: Yes, that makes sense. What software already knows how to reason in this way?
#+end_quote

*** Deontics: Obligations, Permissions, and Prohibitions

Meng thinks the whole Chisholm family of paradoxes is only a problem in a framework that doesn't define obligations in terms of breach.

"You gotta do X." "Or what?" "Or nothing." "Then I don't gotta do it, do I?"

So, in Forrester's paradox, if the penalties for each level of murder -- gentle vs bloody -- are explicitly given in a partial order, then the paradox goes away.

#+BEGIN_QUOTE
*Comment MS:* I agree and hope we can do without explicitly using deontic
 logic. A rule R might say: "if condition C is met, you have to do A". If one
 reads this as an /obligation to do/ and not an /obligation to be/, one can
 give it an operational reading: if, in the current state, condition C is
 satisfied and I take action A, then I will get into a state of conformity
 with rule R. If I do not take action A, I will get into a state where I
 breach rule R. Other rules might say that there is a penalty for this breach,
 and I can explicitly reason about the costs: If I am late arriving at the
 airport, is it better to park the car in a non-parking zone and pay a fine or
 to miss the plane?

Question: which kind of obligations do we have: /to do/ or /to be/?
#+END_QUOTE

#+begin_quote
*Meng's thoughts: Right. Let's agree that we aren't going to do traditional SDL.

We borrow some of the useful ideas of deontic logic, e.g. may Y => not must not Y.

But we don't talk about "must be", we only talk about "must do".

People have choice, the way people had choice in the Israeli daycare case: [[https://rady.ucsd.edu/faculty/directory/gneezy/pub/docs/fine.pdf]["A Fine is a Price"]].

The gentle murderer gets 10 years in prison.

The bloody murderer gets 20 years in prison.

No problem.

Hvitved takes this approach; chapter 2 talks about choice.
#+end_quote

*** Party

The notion of party is complicated by the notion of "affiliates" and "subsidiaries". Also by the notion of a power of attorney, a trust, and other agent relationships.

Sometimes a master agreement will establish a relationship between one group of companies and another group of companies. So we even get to employ the concept of transitive closure.

See https://youtu.be/b6kkvvHfEOo?t=420 for a simple case of detecting such relations.

*** States, Actions, and Events:

What LegalRuleML calls "maintenance" and "achievement" obligations.

This is an opportunity to use LTL/CTL.

*** Definitions and truth values

What LegalRuleML calls "constitutive rules", as opposed to regulative or prescriptive rules. This is one place where we might talk about FOL and a choice of well-founded semantics vs the stable model semantics.

The recent discourse about binary vs nonbinary genders gives a good opportunity to talk about binary vs ternary logics.

*** Default logic

See section below on Rules and Metarules.

*** Defeasible Logic

Do we really need explicit defeasibility?

*** Subjective Perspective:

I want our epistemic theory to be able to express "X thinks Y thinks Z is true."

Or, "Interpretation /I1/ of this text assigns one set of truth values to the following formula; Interpretation /I2/ assigns a different set, and so on."

In 2020 it seems appropriate for a KRR system to admit multiple points of view, rather than to hold to set of global, universal truths. If the parties "agree to disagree", our "artificial intelligence" should not be flummoxed: “The test of a first-rate intelligence,” he said, “is the ability to hold two opposed ideas in the mind, at the same time, and still retain the ability to function.” https://quoteinvestigator.com/2020/01/05/intelligence/

Within the text, a grammar of epistemic modals should handle this.

In the interpreter, we might rely on answer-set-programming or SAT to construct multiple interpretive universes. Ambiguous interpretations of source text could simply show up as branching alternatives.

*** Space: "Jurisdiction"

Different countries have different defaults and interpretational conventions.

A clause may be enforceable in one jurisdiction but not in another.

Enforceability is a judgement to be applied late in the compilation process.

*** Specificity: Intensionality and Extensionality

- "No party who qualifies under section 12 may ..."

- "Alice Apple, of 1 Address Point, specifically may ..."

So the quantifiers of FOL are relevant here.

*** Scope: for the purposes of this section
*** Stack: the Call Stack as input to a function

While this is not recommended, some styles of drafting say:

Definition of X:
- for the purposes of P1, X is X1;
- for the purposes of P2, X is X2;
- however, if the use of this variable X causes some Y to be negative, then X shall be the nearest number needed for Y to be non-negative.

This "easier said than done" sentence gets us into constraint programming and linear equations.

What if purpose P1 stacks a hypothetical purpose P2 in its call to X?

We need a meta-rule along the lines of /lex specialis/ which tells us that in such a situation P2 is located closer in the call stack to X than P1.

*** Supposing: hypothetical, counterfactual specification with some variable set to other than what it "should be"

The Weekend Dinner price of a dish is 1.5 times what the price of the dish would have been if it were served for Weekday Lunch.

#+begin_example
DEFINE dish.price(weekend=true,  period=dinner) =
     hypothetical(dish.price(weekend=false, period=lunch)) * 1.5
#+end_example

This looks simple enough. Is it really necessary to wrap it in a "hypothetical"? Maybe yes, maybe no.

What if the computation actually depends on a whole bunch of State? In fact, it could get worse -- it could depend on the call stack:

*** Natural Language Support

This isn't strictly a logical matter, but if we are to extract (controlled) natural language isomorphisms we will need ways to annotate the L4 syntax with hints. In particular, idioms (in NL) and functions/macros (in L4) are a way of compacting longer expressions into shorter, reusable versions.

*** Macros and Functions

"Homoiconicity" refers to the idea that a program may modify itself. Contracts and laws frequently include "pragma" and "macro" type statements intended to influence interpretation.

*** <<<Rules and Metarules>>>

If multiple rules ostensibly conflict, that just means they are really only rule fragments, and need to be resolved by composition into a larger coherent rule.

Laws are sometimes written as if the drafters were drunk:

#+begin_example
1. Section 1.
   1. The speed limit is 100.
   2. No person may exceed the speed limit.
   3. Any person who may exceed the speed limit shall pay a fine of $100 for every 10 kph above the speed limit.
   4. The speed limit is 80 when it is raining.
   5. The speed limit may be increased beyond 100 during clear weather in daytime.
   6. Nothing in this section 1 shall allow a speed greater than 120.
#+end_example

Read literally, these rules all contradict each other. They need to be read together in context:

#+begin_src haskell
  type Raining = Bool
  type Daytime = Bool
  speedlimit :: Raining -> Daytime -> Int
  speedlimit False False = 100
  speedlimit False True  = 120
  speedlimit True  _     = 80
#+end_src

Sometimes people talk about "default logic". In conventional programming, defaults go at the end.

#+begin_src python
  def speedlimit (raining, daytime):
      if raining: return 80
      if daytime: return 120
      return             100
#+end_src

In legal drafting, the order is inverted: defaults go at the top; exceptions appear below; exceptions to exceptions appear farther below.

*** Explainability

"Show your work: explain to me all the reasons that the outcome was calculated as it was."

The Youtube link above to Coherent Knowledge's Ergo for Financial Regulation demo around Reg W is a good example of what explanation should look like, at least for a datalog-type query.

See also: the New Zealand rates rebates case
https://github.com/smucclaw/complaw/blob/master/doc/ex-nz-rates-20200909/aotearoa-haskell

#+begin_example
mengwong@solo-wmw ~/src/smucclaw/complaw/doc/ex-nz-rates-20200909/aotearoa-haskell $ stack exec aotearoa-exe -- combined_income=20000 dependants=0 rates_total=2000 additional_per_dependant=500 initial_contribution=160 maximum_allowable=630 income_threshold=25180 --goal=l4/from-openfisca-rr.l4 --nlgstyle=concrete
showing how we obtain the answer
630.00 -- which is
  the greater of
  simply 0.00
  and
  630.00 -- which is
    the lesser of
    1874.67 -- which is
      the difference between
      1840.00 -- which is
        the difference between
        2000.00 -- which is
          rates_total, the rates payable for that rating year in respect of the property
        and
        160.00 -- which is
          initial_contribution, the initial contribution by ratepayer
      and
      -34.67 -- which is
        the sum of
        613.33 -- which is
          the quotient given by
          1840.00 -- which is
            the difference between
            2000.00 -- which is
              rates_total, the rates payable for that rating year in respect of the property
            and
            160.00 -- which is
              initial_contribution, the initial contribution by ratepayer
          divided by
          simply 3.00
        with
        -648.00 -- which is
          $1 for each $8 in
          -5180.00 -- which is
            the difference between
            20000.00 -- which is
              combined_income, the ratepayer's income for the preceding tax year
            and
            25180.00 -- which is
              the sum of
              0.00 -- which is
                the product of
                0.00 -- which is
                  dependants, person who was a dependant of the ratepayer
                multiplied by
                500.00 -- which is
                  additional_per_dependant, the additional allowable income per dependant
              with
              25180.00 -- which is
                income_threshold, the income threshold
    and
    630.00 -- which is
      maximum_allowable, the maximum rebate allowed

#+end_example

See also: argumentation theory.

*** Explorability

asks "what if?"

*** Constraints and Inference

Our reasoner should be able to combine backward and forward chaining.

https://cliplab.org/papers/Haemmerle14ppdp.pdf

* Developers Guide

** Requirements

The following command line packages need to be runnable from your shell.

- bnfc
- alex
- happy
- haskell stack
- emacs
  - org-mode

** Install and Quickstart

If you're running the system for the first time, stack will take some time to install ghc.

#+begin_src sh
$ cd bnfc; make
#+end_src

If you're editing the README.org, you can run this to re-make every time you hit save.
#+begin_src sh
$ cd bnfc; fswatch -o ../README.org | perl -nle 'system("clear; date; make")'
#+end_src

This launches a new Emacs to tangle the source files from the README.

Then it builds the L4 interpreter from scratch.

Then it parses the sample L4 code into out/test1.out

** Other Things you can Do
#+begin_src sh
$ ghcid --command "stack ghci" ./mkProlog.hs
#+end_src

** Detailed Compiler Documentation

*** Stages

**** Lexing

handled by BNFC

**** Parsing to Abstract Syntax Tree

handled by BNFC

**** Validation Stage 1

- build a lexical symbol table of defined terms
- Are all defined terms used?
- Identify all undefined terms (which, presumably, would become interview questions in an abductive reasoner)
- distinguish between declared and defined terms

**** Metaprogramming

Any reference to "he" in this document shall be read as "she" where appropriate.

Nothing in this rule shall limit the right to xxx

**** Validation Stage 2

**** Numbering Resolution

**** Cross-Reference Resolution

**** Versioning Resolution

A current rule may refer to an obsolete rule as part of a hypothetical evaluation: /the benefit defined by this rule shall be no lesser than the benefit afforded by any previous version of this rule./

is a clumsy but compact way of saying, evaluate the current rule, evaluate the old rules, and take the max. This requires, in turn, that the old rules be resolvable using the same inputs available to the current rule. If that is not possible, the reasoner needs to raise an error, or ask what to do to handle that situation.


*** Intermediate Representation

So! Thanks to BNFC we have things in Haskell datatypes. That's our abstract representation.

And then we massage those types a bit. We did some validation, verification, inferencing, maybe some rewriting and transformation.

Next we turn those things into concrete outputs.


*** Output Targets

**** Prolog

The transformation looks like this:

- input :: Rule ... Given X ... DEFINE X.foo WHEN X.bar AND X.baz
- output :: foo(X) :- bar(X), baz(X).

-#+BEGIN_QUOTE
 *Comment MS:* Does =DEFINE= always define a rule (logically speaking: an
 implication), or is there also a mechanism for /definitions/, such as for
 example in the Catala language (which is an equivalence, logically
 speaking)? In the above example, when knowing =X.foo=, one cannot infer that
 =X.bar=.
-#+END_QUOTE

#+begin_src haskell :tangle bnfc/prolog/ToProlog.hs
  module ToProlog where

  import Data.Char (isUpper, isLower, toTitle, toLower)
  import AbsL
  import Data.List (intercalate)

  class ToProlog a where
    toProlog :: a -> String

  instance ToProlog Rules where
    toProlog (Toplevel toplevels) =
      unlines $ toProlog <$> toplevels

  instance ToProlog Toplevels where
    toProlog (ToplevelsRule rule) = toProlog rule
    toProlog (ToplevelsModule m)   = show m
    toProlog (ToplevelsImport i)   = show i
    toProlog (ToplevelsPragma p)   = show p

  instance ToProlog Rule where
    toProlog (RuleStanza ruledef rulebody) =
      unlines [ unwords [ "%% ruleDef:",   show ruledef ]
              , unwords [ "%% ruleBody:",  show rulebody ]
              , unwords [ toProlog rulebody ]
              ]

  instance ToProlog RuleBody where
    toProlog RBNoop = "%% NOOP lol"
    toProlog (RBDeem objattrands predexpr) = unlines $
      (\(ObjAttrAnd1 objAttr) -> unwords [ toProlog objAttr
                                         , ":-"
                                         , toProlog predexpr ++ "." ])
      <$> objattrands

  #+end_src

Lot of heavy lifting happens in an ObjAttr "token":

| objattr       | prolog        | remark                                         |
|---------------+---------------+------------------------------------------------|
| One.two       | two(One)      | boolean horn                                   |
| One.Two       | two(One,Two)  | Two contains a value for subsequent processing |
| one.two       | one.two       | atom                                           |
| one.Two       | one.Two       | atom                                           |
| one.two.three | one.two.three | atom; should we consider unpacking?            |

Things can get more complicated in Flora-2.

See also https://www.swi-prolog.org/pldoc/man?section=bidicts for an alternative approach we might consider.

  #+begin_src haskell :tangle bnfc/prolog/ToProlog.hs
    instance ToProlog ObjAttr where
      toProlog (OA_method oa commalist) = toProlog oa ++ "(" ++ toProlog commalist ++ ")"
      toProlog (OA_dots objAttrElems) =
        case asVar objAttrElems of
          (inside, outside, Just asvar) -> outside ++ "(" ++ intercalate "," [inside, asvar] ++ ")"
          (inside, outside, Nothing)    -> outside ++ "(" ++ inside ++ ")"

    asVar :: [ObjAttrElem] -> (String, String, Maybe String)
    asVar objAttrElems =
       let oalist = toProlog <$> objAttrElems
           outside = last oalist
           inside  = head oalist
        in
        if and [ length oalist == 2
               , isUpper . head $ outside
               , isUpper . head $ inside ]
        then (inside, lcfirst outside, Just $ titleCase outside)
        else (inside, lcfirst outside, Nothing)
        where titleCase "" = ""
              titleCase (x:xs) = toTitle x : xs
              lcfirst "" = ""
              lcfirst (x:xs) = toLower x : xs


    instance ToProlog ObjAttrElem where
      toProlog (ObjAttrElemIdent (Ident oaeii)) = oaeii

    instance ToProlog PredExpr where
      toProlog (PEOA oa)  = toProlog oa
      toProlog (PEAnd exp1 exp2) = toProlog exp1 ++ ", " ++ toProlog exp2
      toProlog (PEOr  exp1 exp2) = toProlog exp1 ++ ", " ++ toProlog exp2
      toProlog (PEME  matchexp)  = toProlog matchexp

    instance ToProlog MatchExpr where
      toProlog (ME_OA_JL oa@(OA_dots oaes) jl) =
        case asVar oaes of
          (inside, outside, Just asvar) -> intercalate ", " [ toProlog oa, "match(" ++ asvar, toProlog jl ++ ")" ]
          (inside, outside, Nothing)    -> "%% not sure what to do here"
      toProlog (ME_OA_JL oa jl) = "%% unable to render a match against a junctionlist because the object-attribute doesn't look like Upper.lower"
      toProlog (ME_True)        = "true"
      toProlog (ME_False)       = "false"

    instance ToProlog JunctionList where
      toProlog (JL_Comma l) = "plain, [" ++ toProlog l ++ "]"
      toProlog (JL_And   l) =   "and, [" ++ toProlog l ++ "]"
      toProlog (JL_Or    l) =    "or, [" ++ toProlog l ++ "]"
      toProlog (JL_Xor   (XorList l)) -- you can take out the plain bit when the xor match in prolog is working properly
        | length l == 1       = "plain, [" ++ toProlog (XorList l) ++ "]"
        | otherwise           =   "xor, [" ++ toProlog (XorList l) ++ "]"

    instance ToProlog CommaList where
      toProlog (CommaList  l) = intercalate ", " $ toProlog <$> l
    instance ToProlog   AndList where toProlog (  AndList l) = intercalate ", " $ toProlog <$> l
    instance ToProlog    OrList where toProlog (   OrList l) = intercalate ", " $ toProlog <$> l
    instance ToProlog   XorList where toProlog (  XorList l) = intercalate ", " $ toProlog <$> l

    instance ToProlog CommaElem where
      toProlog (CommaElemObjAttr oa) = toProlog oa
      toProlog (CommaElemString  oa) = show oa
    instance ToProlog   AndElem where
      toProlog (  AndElemObjAttr oa) = toProlog oa
      toProlog (  AndElemString  oa) = show oa
    instance ToProlog    OrElem where
      toProlog (   OrElemObjAttr oa) = toProlog oa
      toProlog (   OrElemString  oa) = show oa
    instance ToProlog   XorElem where
      toProlog (  XorElemObjAttr oa) = toProlog oa
      toProlog (  XorElemString  oa) = show oa

#+end_src

Some helper functions
  #+begin_src prolog :tangle bnfc/prolog/prelude.pl
    % this file is autogenerated! -*- prolog -*-
    % 1. tangle dsl/README.org using C-c C-v C-t
    % 2. run (cat prelude.pl; ./mkProlog test1.l4) > potato.pl

    :- use_module(library(yall)).

    match(Elem, or,  List)   :- member(Elem, List).
    match(Elem, and, List)   :- maplist(  [X]>>myeq(X,Elem), List).
    match(Elem, xor, List)   :- partition([X]>>myeq(X,Elem), List, In, _Out), length(In,L), L = 1.
    match(Elem, plain, List) :- match(Elem, or, List).
    myeq(A,B) :- A == B.

    % set up a couple of test potatoes
    species(potato1, "Solanum tuberosum").
    species(potato2, "Ipomoea batatas").

  #+end_src

**** Flora-2

**** Python for DocAssemble

**** Javascript because Javascript is everywhere, like bacteria on your skin



* Standard Libraries

** ContractLaw


#+begin_src haskell :noweb yes :tangle bnfc/l4/ContractLaw.l4
  RULE   1 elements
           :en: "Elements of a Contract"
     GIVEN scenario
    DEFINE scenario.hasContract
      WHEN [ parties >= 2
           ,   @ T1 party.Offeror  offers    O
           ,   @ T3 party.Acceptor accepts   O, T1 <= T3
           , ! @ T2 party.Offeror  withdraws O, T1 <= T2 <= T3
           , ! @ T2 party.Acceptor declines  O, T1 <= T2 <= T3
                    -- Note: Acceptor may unify to multiple values, since cardinality of parties can be 3 or more
           , O.Offeror.Consideration
           & O.Acceptor.Consideration
           ]
     WHERE [ O.Offeror.Consideration & O.Acceptor.Consideration ] <&> [ [ isPromiseToRefrain | hasValue ] & not isPast ]
#+end_src

Some unspoken rules are at play:
- disjoint rule :: Acceptor /= Offeror because any match is automatically narrowed to be disjoint with any previous matches of the same shape, unless there is a WHERE expression that explicitly broadens the match to allow X to be Y
- with GIVEN :: namespaces of the GIVEN parameters are available in scope for the rest of the rule
- singular / plural unification :: .parties and .party are automatically the same object

We may want to express that a counteroffer implies a decline.

** Jurisdiction


* Output

** BNFC
#+begin_src bnfc :noweb yes :tangle bnfc/l4.bnfc
-- this is auto-generated from README.org. Use C-c C-v C-t to output a fresh version of this file.
<<l4bnfc>>
<<l4expressions>>
#+end_src

** Test L4 input
#+begin_src text :noweb yes :tangle bnfc/l4/test1.l4
  // this is auto-generated from README.org. Use C-c C-v C-t to output a fresh version of this file.
  <<l4-example1>>

  <<l4-rules>>

  <<l4entity>>

#+end_src
* TODO Syntax Sketchbook

Random bits of syntax Meng has made up over the years

#+begin_example
    LEGALSOURCE  SG.Cap50.175.1
REGULATIVE RULE  "Companies Must Hold AGM" @ cmhagm
     SUBJECT TO  this§ & §175A
          PARTY  EVERY Company
          PMUST  hold (a general meeting called@ "annual general meeting") @ AGM
          WHERE  AGM.labels == 1 [ text_en= "in addition to any other meeting" ]
     REPEATEDLY
          AFTER  EACH Company.financialYearEnd
         WITHIN  Company.isListedPublicCo?
                 THEN 4 months
                 ELSE 6 months
#+end_example

#+begin_example
mengwong@solo-wmw ~/src/smucclaw/complaw/doc/ex-nz-rates-20200909/hs $ stack exec hs-exe
DEFINITION RULE "egm business"
FORALL Company.generalMeetings.isExtraordinary?.business {
  .level == Special
}

DEFINITION RULE "agm business"
FORALL Company.generalMeetings.isAnnual?.business {
  .level = Special
           UNLESS .matter ~~ [ "the declaration of a dividend",
                               "consideration" OF [ "the financial statements",
                                                    "the reports of the auditors"
                                                    &&
                                                    "the statements of the directors" ],
                               "the election of directors in the place of retiring directors"
                               ||
                               [ "the appointment"
                                 &
                                 "fixing of the remuneration" ] OF "the auditors" ]
}

UNSPOKEN DEFINITION RULE "metonym: the ontological essence of a meeting's business is its matter attribute"
FORALL Company.generalMeetings.business {
  :metonym = .matter
}

REGULATIVE RULE "must hold agm"
PARTY Company, a corporation
MUST hold an AGM
     :en: hold an AGM
REPEATEDLY every 1 year

REGULATIVE RULE "Companies Must Hold AGM"
PARTY Company, a corporation
PMUST hold an AGM
      :en: hold a general meeting called "annual general meeting"
      :en: in addition to any other meeting
      WHERE NOT (CHMAGM ~~ unique constraint excludes any other label on this meeting)
REPEATEDLY every 1 year

UNSPOKEN CONSTITUTIVE RULE "a listed public company"
FORALL Company {
  .isListedPublicCo? :- .isPublic?, .isListed?.
}
mengwong@solo-wmw ~/src/smucclaw/complaw/doc/ex-nz-rates-20200909/hs $
#+end_example

** Jason's Draft of the SAFE

#+begin_example
Safe_Contract IS A CATEGORY OF CONTRACT THAT:
    HAS PARTY Investor
    HAS PARTY Company
    HAS JURISDICTION State_of_Incorpration
    HAS DATE Executed_On
    HAS CURRENCY Purchase_Amount
    HAS CURRENCY Post-Money_Valuation_Cap
    HAS NUMBER Discount_Rate
    HAS FLUENT BOOLEAN Terminated

Equity_Financing IS A CATEGORY OF EVENT THAT:
    HAS A LIST OF DOCUMENTS Required_Documents
    HAS BOOLEAN Documents_Are_Standard

START SCOPE This_SAFE as Safe_Contract

    RULE "Certifications"
    Investor MUST pay Purchase_Amount to Company
    BEFORE Executed_On + 1W
    HENCE "Right to Shares"

    START SCOPE "Right to Shares"

        START SCOPE "Events"

            RULE "Equity Financing"

                GIVEN EVENT E
                WHEN
                    E.isEquityFinanceEvent AND
                    AS OF E.date (This_SAFE.Terminated ~ False)
                THEN
                    Company MUST give Investor Amount of Safe_Preferred_Stock
                    WHERE
                        Amount = Purchase_Amount / Conversion_Price
                HENCE "Required Documentation", "Termination By Equity Event"

            RULE "Required Documentation"

                GIVEN EVENT E
                WHEN
                    E.isEquityFinanceEvent AND
                    AS OF E.date (This_SAFE.Terminated ~ False) AND
                    E.documentation.isStandard
                THEN
                FOR EACH Document in E.Required_Documents
                    Investor MUST
                        execute Document
                        AND THEN                        // sequential, not logical
                        deliver Document to Company

            // RULE "Liquidity Event" ...

            // RULE "Dissolution Event" ...

            Rule "Termination By Equity Event"

                GIVEN Event T
                WHEN
                    T ~ Company give Investor Amount of Safe_Preferred_Stock
                THEN
                    This_SAFE.Terminated = True

        END SCOPE "Events"
    END SCOPE "Right to Shares"
END SCOPE This_SAFE

#+end_example
