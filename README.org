#+TITLE: The future home of the L4 DSL

Right now, most of the action is over in the [[https://github.com/smucclaw/complaw/][complaw]] repo.

* Draft Language Specification v0.2.0

** By Example

We want to be able to translate natural-language contracts and laws to code, without loss of meaning; so our language needs to be as expressive as natural language "pseudocode".

*** A Simple Law

See [[https://github.com/smucclaw/complaw/blob/master/doc/ex-20200806-hello-world-rules/][the Potato case]].

*** A Simple Contract

See [[https://github.com/smucclaw/complaw/blob/master/doc/ex-jurix-20200814/][the Cabbage case]], which embeds a contract-like state graph.

** Underlying Logics and Concepts

We build on a combination of the lamdba, mu, and pi calculi. What would we do without the Greeks?

*** Temporals: Time

We need to say things like: from T1 to T2, X was married to Y; from T3 to T4, X was married to Z. (OWL doesn't support this; it's timeless.)

We want [[https://en.wikipedia.org/wiki/Temporal_database][multi-temporality]]: at time T1, party P believed that the legislation then in effect was L1; however, at time T3, party P realized that the legislation in effect at T1 was actually L2, having replaced L1 at time T2. However, L2 made provision that at time T1, the effective result for parties in P's situation would be as if L1 were in effect.

So, we need the usual temporal notions of deadlines, durations, relative and absolute time referents, repeating periods.

- Temporals :: DMN refers to a standard temporal theory of before/overlap/after. We want to reconcile that with the Event and Situation calculi.

#+BEGIN_QUOTE
*Comment MS:* I think there are two issues involved in the above discussion of multi-temporality:
- the question how time evolves during the lifetime of a contract (assuming
  that the rule set remains stable) and which actions are / have to be taken
  at each moment by the parties involved. Formal models for this are Timed
  Automata, Petri Nets etc. These generate / accept a set of traces, and one
  can reason about them with temporal logics (LTL, CTL: "eventually / always",
  "in some / all runs") or their timed variants (TCTL: "some time in the next
  50 time units"). This technology is well understood at least in isolation,
  but maybe not in conjunction with all the other features we need.
- the question how the validity of a rule set changes over time. Seems closely
  related to the question of metarules mentioned below. These seem extremely
  difficult to deal with in full generality. A self-referential rule like
  "This rule will not be valid in a month any more" looks like a variant of
  the Liar's Paradox: Either the rule is still valid in a month (but
  shouldn't be according to what it states), or it is not valid in a month
  (but then there is no rule contradicting its validity, so as a rule
  appearing in a contract, why shouldn't it be valid?). To avoid these
  paradoxes, one would need a stratified set of rules, and a prover would have
  to iterate several times over the rule set to determine the applicable rules.
#+END_QUOTE

*** Deontics: Obligations, Permissions, and Prohibitions

Meng thinks the whole Chisholm paradox is only a problem in a framework that doesn't define obligations in terms of breach.

"You gotta do X." "Or what?" "Or nothing." "Then I don't gotta do it, do I?"

So, if the penalties for each level of murder -- gentle vs bloody -- are explicitly given in a partial order, then the paradox goes away.

#+BEGIN_QUOTE
*Comment MS:* I agree and hope we can do without explicitly using deontic
 logic. A rule R might say: "if condition C is met, you have to do A". If one
 reads this as an /obligation to do/ and not an /obligation to be/, one can
 give it an operational reading: if, in the current state, condition C is
 satisfied and I take action A, then I will get into a state of conformity
 with rule R. If I do not take action A, I will get into a state where I
 breach rule R. Other rules might say that there is a penalty for this breach,
 and I can explicitly reason about the costs: If I am late arriving at the
 airport, is it better to park the car in a non-parking zone and pay a fine or
 to miss the plane?

Question: which kind of obligations do we have: /to do/ or /to be/?
#+END_QUOTE

*** Party

The notion of party is complicated by the notion of "affiliates" and "subsidiaries". Also by the notion of a power of attorney, a trust, and other agent relationships.

Sometimes a master agreement will establish a relationship between one group of companies and another group of companies. So we even get to employ the concept of transitive closure.

See https://youtu.be/b6kkvvHfEOo?t=420 for a simple case of detecting such relations.

*** States, Actions, and Events: 

What LegalRuleML calls "maintenance" and "achievement" obligations.

This is an opportunity to use LTL/CTL.

*** Definitions and truth values

What LegalRuleML calls "constitutive rules", as opposed to regulative or prescriptive rules. This is one place where we might talk about FOL and a choice of well-founded semantics vs the stable model semantics.

The recent discourse about binary vs nonbinary genders gives a good opportunity to talk about binary vs ternary logics.

*** Default logic

See section below on Rules and Metarules.

*** Defeasible Logic

Do we really need explicit defeasibility?

*** Subjective Perspective:

I want our epistemic theory to be able to express "X thinks Y thinks Z is true."

Or, "Interpretation /I1/ of this text assigns one set of truth values to the following formula; Interpretation /I2/ assigns a different set, and so on."

In 2020 it seems appropriate for a KRR system to admit multiple points of view, rather than to hold to set of global, universal truths. If the parties "agree to disagree", our "artificial intelligence" should not be flummoxed: “The test of a first-rate intelligence,” he said, “is the ability to hold two opposed ideas in the mind, at the same time, and still retain the ability to function.” https://quoteinvestigator.com/2020/01/05/intelligence/

Within the text, a grammar of epistemic modals should handle this.

In the interpreter, we might rely on answer-set-programming or SAT to construct multiple interpretive universes. Ambiguous interpretations of source text could simply show up as branching alternatives.

*** Space: "Jurisdiction"

Different countries have different defaults and interpretational conventions.

A clause may be enforceable in one jurisdiction but not in another.

Enforceability is a judgement to be applied late in the compilation process.

*** Specificity: Intensionality and Extensionality

- "No party who qualifies under section 12 may ..."

- "Alice Apple, of 1 Address Point, specifically may ..."

So the quantifiers of FOL are relevant here.

*** Counterfactuals: hypothetical specification with some variable set to other than what it is

The Weekend Dinner price of a dish is 1.5 times what the price of the dish would have been if it were served for Weekday Lunch.

#+begin_example
DEEM              dish.price(weekend=true,  period=dinner) =
     hypothetical(dish.price(weekend=false, period=lunch)) * 1.5
#+end_example

This looks simple enough. Is it really necessary to wrap it in a "hypothetical"? Maybe yes, maybe no.

What if the computation actually depends on a whole bunch of State? In fact, it could get worse -- it could depend on the call stack:

*** Examination of Call Stack

While this is not recommended, some styles of drafting say:

- for the purposes of P1, X is X1;
- for the purposes of P2, X is X2;
- however, if the use of this variable X causes some Y to be negative, then X shall be the nearest number needed for Y to be non-negative.

This "easier said than done" sentence gets us into constraint programming and linear equations.

What if purpose P1 stacks a hypothetical purpose P2 in its call to X?

We need a meta-rule along the lines of /lex specialis/ which tells us that in such a situation P2 is located closer in the call stack to X than P1.

*** Natural Language Support

This isn't strictly a logical matter, but if we are to extract (controlled) natural language isomorphisms we will need ways to annotate the L4 syntax with hints. In particular, idioms (in NL) and functions/macros (in L4) are a way of compacting longer expressions into shorter, reusable versions.

*** Macros and Functions

"Homoiconicity" refers to the idea that a program may modify itself. Contracts and laws frequently include "pragma" and "macro" statements intended to influence interpretation.

*** <<<Rules and Metarules>>>

If multiple rules ostensibly conflict, that just means they are really only rule fragments, and need to be resolved by composition into a larger coherent rule.

Laws are sometimes written as if the drafters were drunk:

#+begin_example
1. Section 1.
   1. The speed limit is 100.
   2. No person may exceed the speed limit.
   3. Any person who may exceed the speed limit shall pay a fine of $100 for every 10 kph above the speed limit.
   4. The speed limit is 80 when it is raining.
   5. The speed limit may be increased beyond 100 during clear weather in daytime.
   6. Nothing in this section 1 shall allow a speed greater than 120.
#+end_example

Read literally, these rules all contradict each other. They need to be read together in context:

#+begin_src haskell
  type Raining = Bool
  type Daytime = Bool
  speedlimit :: Raining -> Daytime -> Int
  speedlimit False False = 100
  speedlimit False True  = 120
  speedlimit True  _     = 80
#+end_src

Sometimes people talk about "default logic". In conventional programming, defaults go at the end.

#+begin_src python
  def speedlimit (raining, daytime):
      if raining: return 80
      if daytime: return 120
      return             100
#+end_src

In legal drafting, the order is inverted: defaults go at the top; exceptions appear below; exceptions to exceptions appear farther below.

*** Explainability

"Show your work: explain to me all the reasons that the outcome was calculated as it was."

The Youtube link above to Coherent Knowledge's Ergo for Financial Regulation demo around Reg W is a good example of what explanation should look like, at least for a datalog-type query.

See also: the New Zealand rates rebates case
https://github.com/smucclaw/complaw/blob/master/doc/ex-nz-rates-20200909/aotearoa-haskell

#+begin_example
mengwong@solo-wmw ~/src/smucclaw/complaw/doc/ex-nz-rates-20200909/aotearoa-haskell $ stack exec aotearoa-exe -- combined_income=20000 dependants=0 rates_total=2000 additional_per_dependant=500 initial_contribution=160 maximum_allowable=630 income_threshold=25180 --goal=l4/from-openfisca-rr.l4 --nlgstyle=concrete
showing how we obtain the answer
630.00 -- which is
  the greater of
  simply 0.00
  and
  630.00 -- which is
    the lesser of
    1874.67 -- which is
      the difference between
      1840.00 -- which is
        the difference between
        2000.00 -- which is
          rates_total, the rates payable for that rating year in respect of the property
        and
        160.00 -- which is
          initial_contribution, the initial contribution by ratepayer
      and
      -34.67 -- which is
        the sum of
        613.33 -- which is
          the quotient given by
          1840.00 -- which is
            the difference between
            2000.00 -- which is
              rates_total, the rates payable for that rating year in respect of the property
            and
            160.00 -- which is
              initial_contribution, the initial contribution by ratepayer
          divided by
          simply 3.00
        with
        -648.00 -- which is
          $1 for each $8 in
          -5180.00 -- which is
            the difference between
            20000.00 -- which is
              combined_income, the ratepayer's income for the preceding tax year
            and
            25180.00 -- which is
              the sum of
              0.00 -- which is
                the product of
                0.00 -- which is
                  dependants, person who was a dependant of the ratepayer
                multiplied by
                500.00 -- which is
                  additional_per_dependant, the additional allowable income per dependant
              with
              25180.00 -- which is
                income_threshold, the income threshold
    and
    630.00 -- which is
      maximum_allowable, the maximum rebate allowed

#+end_example

See also: argumentation theory.

** Libraries for Genres:

Each of these genres requires a library -- a "sub-domain ontology".

- Contract Law :: notions of what constitutes a valid contract
- Real Estate ::
- City Planning :: 

** Formal Verification

How to perform static analysis on the programs.

** Natural Language Generation

How to compile to natural languages.



** How To Try It For Yourself

A web REPL? IDE support?

** How To Contribute

Github issues.

** Introduction

** Tutorials

This section will link to standalone tutorials that work through case studies for common scenarios.

** Compiler Documentation

*** Stages

**** Lexing

handled by BNFC

**** Parsing to Abstract Syntax Tree

handled by BNFC

**** Validation Stage 1

- build a lexical symbol table of defined terms
- Are all defined terms used?
- Identify all undefined terms (which, presumably, would become interview questions in an abductive reasoner)
- distinguish between declared and defined terms

**** Metaprogramming

Any reference to "he" in this document shall be read as "she" where appropriate.

Nothing in this rule shall limit the right to xxx

**** Validation Stage 2

**** Numbering Resolution

**** Cross-Reference Resolution

**** Versioning Resolution

A current rule may refer to an obsolete rule as part of a hypothetical evaluation: /the benefit defined by this rule shall be no lesser than the benefit afforded by any previous version of this rule./

is a clumsy but compact way of saying, evaluate the current rule, evaluate the old rules, and take the max. This requires, in turn, that the old rules be resolvable using the same inputs available to the current rule. If that is not possible, the reasoner needs to raise an error, or ask what to do to handle that situation.


*** Intermediate Representation

So! Thanks to BNFC we have things in Haskell datatypes. That's our abstract representation.

And then we massage those types a bit. We did some validation, verification, inferencing, maybe some rewriting and transformation.

Next we turn those things into concrete outputs.


*** Output Targets

**** Prolog

The transformation looks like this:

- input :: Rule ... Given X ... DEEM X.foo WHEN X.bar AND X.baz
- output :: foo(X) :- bar(X), baz(X).

#+BEGIN_QUOTE
*Comment MS:* Does =DEEM= always define a rule (logically speaking: an
 implication), or is there also a mechanism for /definitions/, such as for
 example in the Catala language (which is an equivalence, logically
 speaking)? In the above example, when knowing =X.foo=, one cannot infer that
 =X.bar=. 
#+END_QUOTE

#+begin_src haskell :tangle ToProlog.hs
  module ToProlog where

  import Data.Char (isUpper, isLower, toTitle, toLower)
  import AbsL
  import Data.List (intercalate)

  class ToProlog a where
    toProlog :: a -> String

  instance ToProlog Rules where
    toProlog (Toplevel toplevels) =
      unlines $ toProlog <$> toplevels

  instance ToProlog Toplevels where
    toProlog (ToplevelsRule rule) = toProlog rule
    toProlog (ToplevelsModule m)   = show m
    toProlog (ToplevelsImport i)   = show i
    toProlog (ToplevelsPragma p)   = show p

  instance ToProlog Rule where
    toProlog (RuleStanza ruledef rulebody) =
      unlines [ unwords [ "%% ruleDef:",   show ruledef ]
              , unwords [ "%% ruleBody:",  show rulebody ]
              , unwords [ toProlog rulebody ]
              ]

  instance ToProlog RuleBody where
    toProlog RBNoop = "%% NOOP lol"
    toProlog (RBDeem objattrands predexpr) = unlines $
      (\(ObjAttrAnd1 objAttr) -> unwords [ toProlog objAttr
                                         , ":-"
                                         , toProlog predexpr ++ "." ])
      <$> objattrands

  #+end_src

Lot of heavy lifting happens in an ObjAttr "token":

| objattr       | prolog        | remark                                         |
|---------------+---------------+------------------------------------------------|
| One.two       | two(One)      | boolean horn                                   |
| One.Two       | two(One,Two)  | Two contains a value for subsequent processing |
| one.two       | one.two       | atom                                           |
| one.Two       | one.Two       | atom                                           |
| one.two.three | one.two.three | atom; should we consider unpacking?            |

Things can get more complicated in Flora-2.

See also https://www.swi-prolog.org/pldoc/man?section=bidicts for an alternative approach we might consider.

  #+begin_src haskell :tangle ToProlog.hs
    instance ToProlog ObjAttr where 
      toProlog (OA_method oa commalist) = toProlog oa ++ "(" ++ toProlog commalist ++ ")"
      toProlog (OA_dots objAttrElems) =
        case asVar objAttrElems of
          (inside, outside, Just asvar) -> outside ++ "(" ++ intercalate "," [inside, asvar] ++ ")"
          (inside, outside, Nothing)    -> outside ++ "(" ++ inside ++ ")"

    asVar :: [ObjAttrElem] -> (String, String, Maybe String)
    asVar objAttrElems =
       let oalist = toProlog <$> objAttrElems
           outside = last oalist
           inside  = head oalist
        in
        if and [ length oalist == 2
               , isUpper . head $ outside
               , isUpper . head $ inside ]
        then (inside, lcfirst outside, Just $ titleCase outside)
        else (inside, lcfirst outside, Nothing)
        where titleCase "" = ""
              titleCase (x:xs) = toTitle x : xs
              lcfirst "" = ""
              lcfirst (x:xs) = toLower x : xs
       

    instance ToProlog ObjAttrElem where 
      toProlog (ObjAttrElemIdent (Ident oaeii)) = oaeii

    instance ToProlog PredExpr where 
      toProlog (PEOA oa)  = toProlog oa
      toProlog (PEAnd exp1 exp2) = toProlog exp1 ++ ", " ++ toProlog exp2
      toProlog (PEOr  exp1 exp2) = toProlog exp1 ++ ", " ++ toProlog exp2
      toProlog (PEME  matchexp)  = toProlog matchexp

    instance ToProlog MatchExpr where
      toProlog (ME_OA_JL oa@(OA_dots oaes) jl) =
        case asVar oaes of
          (inside, outside, Just asvar) -> intercalate ", " [ toProlog oa, "match(" ++ asvar, toProlog jl ++ ")" ]
          (inside, outside, Nothing)    -> "%% not sure what to do here"
      toProlog (ME_OA_JL oa jl) = "%% unable to render a match against a junctionlist because the object-attribute doesn't look like Upper.lower"
      toProlog (ME_True)        = "true"
      toProlog (ME_False)       = "false"

    instance ToProlog JunctionList where
      toProlog (JL_Comma l) = "plain, [" ++ toProlog l ++ "]"
      toProlog (JL_And   l) =   "and, [" ++ toProlog l ++ "]"
      toProlog (JL_Or    l) =    "or, [" ++ toProlog l ++ "]"
      toProlog (JL_Xor   (XorList l)) -- you can take out the plain bit when the xor match in prolog is working properly
        | length l == 1       = "plain, [" ++ toProlog (XorList l) ++ "]"
        | otherwise           =   "xor, [" ++ toProlog (XorList l) ++ "]"

    instance ToProlog CommaList where
      toProlog (CommaList  l) = intercalate ", " $ toProlog <$> l
    instance ToProlog   AndList where toProlog (  AndList l) = intercalate ", " $ toProlog <$> l
    instance ToProlog    OrList where toProlog (   OrList l) = intercalate ", " $ toProlog <$> l
    instance ToProlog   XorList where toProlog (  XorList l) = intercalate ", " $ toProlog <$> l

    instance ToProlog CommaElem where
      toProlog (CommaElemObjAttr oa) = toProlog oa
      toProlog (CommaElemString  oa) = show oa
    instance ToProlog   AndElem where
      toProlog (  AndElemObjAttr oa) = toProlog oa
      toProlog (  AndElemString  oa) = show oa
    instance ToProlog    OrElem where
      toProlog (   OrElemObjAttr oa) = toProlog oa
      toProlog (   OrElemString  oa) = show oa
    instance ToProlog   XorElem where
      toProlog (  XorElemObjAttr oa) = toProlog oa
      toProlog (  XorElemString  oa) = show oa

#+end_src

Some helper functions
  #+begin_src prolog :tangle prelude.pl
    % this file is autogenerated! -*- prolog -*-
    % 1. tangle dsl/README.org using C-c C-v C-t
    % 2. run (cat prelude.pl; ./mkProlog test1.l4) > potato.pl

    :- use_module(library(yall)).

    match(Elem, or,  List)   :- member(Elem, List).
    match(Elem, and, List)   :- maplist(  [X]>>myeq(X,Elem), List).
    match(Elem, xor, List)   :- partition([X]>>myeq(X,Elem), List, In, _Out), length(In,L), L = 1.
    match(Elem, plain, List) :- match(Elem, or, List).
    myeq(A,B) :- A == B.
    
    % set up a couple of test potatoes
    species(potato1, "Solanum tuberosum").
    species(potato2, "Ipomoea batatas").

  #+end_src

**** Flora-2

**** Python for DocAssemble

**** Javascript because Javascript is everywhere, like bacteria on your skin



** Reference Manual and BNFC specification

#+BEGIN_QUOTE
*Comment MS:* Having a grammar is a great step to make the language structure
precise!

/But:/ I wonder whether in addition to the /concrete syntax/ (as given by the
grammar), one can also provide an *abstract syntax*, which is a condensed form
of the concrete syntax and omits many of the details of the surface syntax
(keywords, parentheses, separators, associativity etc.) and is therefore more
readable. The abstract syntax can roughly be understood as a set of Haskell
datatype definitions. If I understand it right, BNFC is supposed to extract
the datatype definitions, but maybe, one can already enumerate the main
types of the abstract syntax "manually" to get a concise picture of the
essential constructs. To give an example, what is interesting about a rule is
something like

#+begin_src haskell
data Rule = RuleStanza RuleDef RuleBody
#+end_src
whereas the different variants of a =RuleDef= are not essential for grasping the
main aspects of the language.

This would then make it easier to define a *type system* for L4, with the main
purpose (again) of identifying the main categories of objects manipulated by
L4. As in any programming language, there will be Booleans and numeric
values. Some of the subtleties begin here: will there be types of
time, money etc, and what are their typing rules? In the Cabbage Case example,
one can write =sale.date + 3W= which seems OK, but writing =2$ + 3W= or simply
=2 + 3W= would be considered as ill typed. 

The typing question is exacerbated by the existence of object-oriented
features (such as =Item=, =sale= in the Cabbage Case example). How does one
declare such objects (i.e. their attributes)? Is there a notion of
inheritance, and if so, which one: simple (as in Java), multiple (as in
CommonLisp), or by inference from sort of ontology (which would considerably
complicate type checking because it would have to be intertwined with proving).

#+END_QUOTE

*** Projects

An L4 Project contains one or more modules.

*** Modules and Structure

An L4 Module is a file.

The /default name/ of the module is derived from its import statement, minus any ~.l4*~ extension.

The following import statements result in the following default module names:

| import                                          | default name |
|-------------------------------------------------+--------------|
| =import "Foo/Bar/Baz.l4"=                       | Foo.Bar.Baz  |
| =import "/usr/local/share/L4/./Foo/Bar/Baz.l4"= | Foo.Bar.Baz  |
| =import "test/./Foo/Bar/Baz.l4"=                | Foo.Bar.Baz  |

The default name is made by 
- deleting any prefix matching the regex ~^.*/\.+/~
- deleting any suffix matching the suffix ~\.l4\w*$~
- converting any directory separators to dots

A module can explicitly give itself a name by saying

#+begin_src haskell :noweb-ref l4-example1
module Foo.Bar.Baz where
#+end_src

#+begin_src bnfc :noweb-ref l4rules
  ModuleDecl. Module ::= "module" ObjAttr "where";
#+end_src

An L4 Module contains a list of directives and statements.

#+begin_src bnfc :noweb-ref l4rules
  Toplevel.  Rules ::= [Toplevels];
  rules      Toplevels ::= Rule | Module | Import | Pragma | Entity | Knol ;
  terminator Toplevels ";";

  layout toplevel;
  entrypoints Rules;
#+end_src

C-style and Javascript-style comments are both supported.

#+begin_src bnfc :noweb-ref l4rules
    comment "//" ;
    comment "/*" "*/" ;
#+end_src



*** Directives
**** module directive is dealt with above

Suppose we have a ContractLaw library:

#+begin_src haskell :noweb yes :tangle ContractLaw.l4
module ContractLaw where

RULE 1 elements
  :en: "Elements of a Contract"
 GIVEN scenario
  DEEM scenario.hasContract
  WHEN [ scenario.parties >= 2
       , scenario.party.[Offeror].makesOffer(O) (@@ T1)
       , scenario.party.[Acceptor @ ALL - Offeror].acceptsOffer(O) (@@ T3 > T1)
                -- Note: Acceptor may unify to multiple values, since cardinality of parties can be 3 or more
       , not scenario.party.[Offeror].withdrawsOffer(O) (@@ T2 > T1, T2 < T3)
       , scenario.party.[Offeror].promises(.Consideration)
       & scenario.party.[Acceptor].promises(.Consideration)
       ]
 WHERE [ Offeror.Consideration & Acceptor.Consideration ] <&> [ [ isPromiseToRefrain | hasValue ] & not isPast ]
#+end_src

Other modules are welcome to import this module. They would end up with ~elements~ in the namespace, explicitly referenceable as ContractLaw.Rule.1

**** pragma: version

#+begin_src bnfc :noweb-ref l4rules
  rules Pragma ::= "pragma" [KeyVal] ;
#+end_src

**** history

previous versions of this ruleset are accessible where? because this ruleset may refer to previous versions.

**** import

#+begin_src haskell :noweb-ref l4-example1
import ContractLaw
#+end_src

#+begin_src bnfc :noweb-ref l4rules
  Import. Import ::= "import" ObjAttr ;
#+end_src

**** numbering

A numbering directive instructs the output engine to reset the autonumbering to a specific value.

*** Statements

An L4 statement is one of the following:

**** Entities and Knols

#+begin_src bnfc :noweb-ref l4rules
  Entity.    Entity    ::= "ENTITY" Ident
                           "ISA"   UIdent
                           Asof
                           "WITH"  [WithKeyVal]

  layout "WITH" ;
  separator WithKeyVal ";" ;

  rules  WithKeyVal ::= ObjAttr "=" JunctionList
                      | ObjAttr "=" BraceList
                      | ObjAttr "=" String
                      | ObjAttr "=" ObjAttr ;

  rules BraceList ::= "{" [KeyVal] "}" ;

**** A Rule Statement

#+begin_src bnfc :noweb-ref l4rules

  rules      RuleDef   ::= RuleNum | RuleID | RuleName
                         | RuleNum   RuleID 
                         | RuleNum            RuleName
                         |           RuleID   RuleName ;
  RID.       RuleID    ::= Ident ;
  RName.     RuleName  ::= LangStrings ;
  RNum.      RuleNum   ::= Integer;

  RuleStanza.  Rule      ::= "RULE" RuleDef RuleBody;

  RBNoop.    RuleBody  ::= "NOOP";

  -- DEEM Item.isPotato AND Item.isVegetable WHEN ...
  RBDeem.    RuleBody  ::= "DEEM" [ObjAttrAnd] "WHEN" PredExpr;
  separator nonempty ObjAttrAnd "AND";
  ObjAttrAnd1. ObjAttrAnd ::= ObjAttr ;

  -- ... WHEN  
  PEOA.      PredExpr  ::= ObjAttr;
  PEAnd.     PredExpr  ::= PredExpr "AND" PredExpr;
  PEOr.      PredExpr  ::= PredExpr "OR"  PredExpr;
  PEME.      PredExpr1 ::= MatchExpr;
  _.         PredExpr2 ::= "(" PredExpr ")";
  coercions PredExpr 2;
  -- do we really need to say coercions?

  rules      FancyBoolOp ::= PlainBoolOp Likelihood;

  rules      PlainBoolOp ::= "AND" | "OR" ;

  rules      Likelihood  ::= "" | "LIKELY" | "UNLIKELY";

  -- need more cases -- junctionlists
  ME_OA_JL.  MatchExpr  ::= ObjAttr "~" JunctionList ;
  ME_True.   MatchExpr  ::= "True";
  ME_False.  MatchExpr  ::= "False";

  JL_And.    JunctionList ::= "["   AndList "]" ;
  JL_Or.     JunctionList ::= "["    OrList "]" ;
  JL_Xor.    JunctionList ::= "["   XorList "]" ;
  JL_Comma.  JunctionList ::= "[" CommaList "]" ;

  -- some work to be done here -- the and, or, xor lists have to have at least 2 elements
  -- if there's only one element it's a plain list

  CommaList.  CommaList ::= [CommaElem];
  rules      CommaElem ::= ObjAttr | String;
  separator nonempty CommaElem ",";

  AndList.   AndList ::= [AndElem];
  rules      AndElem ::= ObjAttr | String;
  separator nonempty AndElem "&";

  XorList.   XorList ::= [XorElem];
  rules      XorElem ::= ObjAttr | String;
  separator nonempty XorElem "|";

  OrList.    OrList ::= [OrElem];
  rules      OrElem ::= ObjAttr | String;
  separator nonempty OrElem "|";

  rules      ObjAttrElem  ::= Ident ;                     -- Foo

  OA_dots.   ObjAttr      ::= [ObjAttrElem];              -- Foo.Bar.Baz
  OA_method. ObjAttr      ::= ObjAttr "(" CommaList ")" ; -- Foo.Bar(Baz, Quux)
  separator nonempty ObjAttrElem ".";

  rules      KeyVal     ::= ObjAttr ":" ObjAttr
                          | ObjAttr "=" ObjAttr ;
  separator nonempty KeyVal ",";


#+end_src

**** Text Examples

#+begin_src text :noweb yes :tangle test1.l4
  // this is auto-generated from README.org. Use C-c C-v C-t to output a fresh version of this file.
  <<l4-example1>>
  RULE 1 RuleOne NOOP

  RULE 2 
   DEEM Item.isEdiblePotato
    AND Item.isTastyFood
    WHEN Item.isPotato
     AND Item.isEdible

  // the Prolog version of the above is:
  // isEdiblePotato(Item) :- isPotato(Item), isEdible(Item).
  // isTastyFood(Item)    :- isPotato(Item), isEdible(Item).
  //
  // the Flora-2 version of this would probably rely on the Item having properties
  //

  
  RULE 3 fertilize
    DEEM Item.isPotato
    WHEN Item.Species ~ ["Solanum tuberosum"]

  // Meng seems to be reinventing Haskell
  // let's call it HasSQL, haha

  /* like, for example ...

  append "poo" forEach [Foo, Bar, Baz]

  is equivalent to, in some other languages,

      [Foo, Bar, Baz].map(x=>x+"poo")
  or
      (++ "poo") <$> [foo, bar, baz]

  so we can sneak that in to our language too, just with lots of
  syntactic sugar so the "business developers" don't notice we're doing
  a list comprehension

  ,*/

#+end_src

***** The Jurix Paper

#+begin_src l4 :tangle test2.l4
// from the JURIX paper

RULE   "Sale Restricted"
   PARTY  P
   SHANT  sell Item
   WHEN   Item.isCabbage
   UNLESS sale.onLegalDate
       OR UNLIKELY P.hasExemption from:DirectorOfAgriculture
          HENCE Rule "Return Policy"
   WHERE
      DEEM Item.isCabbage en:"is a cabbage"
           WHEN Item.faostat ~ "FCL ITEM 0358"
             OR (Item.category      ~ "vegetable"
                 AND Item.species   ~ ["Brassica chinensis", "Brassica oleracea"]
                 AND Item.cultivar !~ "botrytis")
      DEEM sale.onLegalDate en:"on the day of a full moon"
           WHEN sale.date ~ LegalDates
           WHERE LegalDates = EXTERNAL url
                              "https://www.almanac.com/astronomy/moon/full/"
        
    RULE "Return Policy"
   GIVEN sale
   PARTY Buyer
     MAY return Item
  BEFORE sale.date + 3W
   HENCE Rule "Net 3"
   
    RULE "Net 3"
   GIVEN return
   PARTY Seller
    MUST refund Amount
  BEFORE return.date + 3D
   WHERE Amount = return.sale.cash * 90%
#+end_src

**** TODO Syntax Sketchbook

Random bits of syntax Meng has made up over the years

#+begin_example
    LEGALSOURCE  SG.Cap50.175.1
REGULATIVE RULE  "Companies Must Hold AGM" @ cmhagm
     SUBJECT TO  this§ & §175A
          PARTY  EVERY Company
          PMUST  hold (a general meeting called@ "annual general meeting") @ AGM
          WHERE  AGM.labels == 1 [ text_en= "in addition to any other meeting" ]
     REPEATEDLY
          AFTER  EACH Company.financialYearEnd
         WITHIN  Company.isListedPublicCo?
                 THEN 4 months
                 ELSE 6 months
#+end_example

#+begin_example
mengwong@solo-wmw ~/src/smucclaw/complaw/doc/ex-nz-rates-20200909/hs $ stack exec hs-exe
DEFINITION RULE "egm business"
FORALL Company.generalMeetings.isExtraordinary?.business {
  .level = Special
}

DEFINITION RULE "agm business"
FORALL Company.generalMeetings.isAnnual?.business {
  .level = Special
           UNLESS .matter ~~ [ "the declaration of a dividend",
                               "consideration" OF [ "the financial statements",
                                                    "the reports of the auditors"
                                                    &&
                                                    "the statements of the directors" ],
                               "the election of directors in the place of retiring directors"
                               ||
                               [ "the appointment"
                                 &
                                 "fixing of the remuneration" ] OF "the auditors" ]
}

UNSPOKEN DEFINITION RULE "metonym: the ontological essence of a meeting's business is its matter attribute"
FORALL Company.generalMeetings.business {
  :metonym = .matter
}

REGULATIVE RULE "must hold agm"
PARTY Company, a corporation
MUST hold an AGM
     :en: hold an AGM
REPEATEDLY every 1 year

REGULATIVE RULE "Companies Must Hold AGM"
PARTY Company, a corporation
PMUST hold an AGM
      :en: hold a general meeting called "annual general meeting"
      :en: in addition to any other meeting
      WHERE NOT (CHMAGM ~~ unique constraint excludes any other label on this meeting)
REPEATEDLY every 1 year

UNSPOKEN CONSTITUTIVE RULE "a listed public company"
FORALL Company {
  .isListedPublicCo? :- .isPublic?, .isListed?.
}
mengwong@solo-wmw ~/src/smucclaw/complaw/doc/ex-nz-rates-20200909/hs $
#+end_example

***** Jason's Draft of the SAFE

#+begin_example
Safe_Contract IS A CATEGORY OF CONTRACT THAT:
    HAS PARTY Investor
    HAS PARTY Company
    HAS JURISDICTION State_of_Incorpration
    HAS DATE Executed_On
    HAS CURRENCY Purchase_Amount
    HAS CURRENCY Post-Money_Valuation_Cap
    HAS NUMBER Discount_Rate
    HAS FLUENT BOOLEAN Terminated

Equity_Financing IS A CATEGORY OF EVENT THAT:
    HAS A LIST OF DOCUMENTS Required_Documents
    HAS BOOLEAN Documents_Are_Standard

START SCOPE This_SAFE as Safe_Contract

    RULE "Certifications"
    Investor MUST pay Purchase_Amount to Company
    BEFORE Executed_On + 1W
    HENCE "Right to Shares"

    START SCOPE "Right to Shares"

        START SCOPE "Events"

            RULE "Equity Financing"

                GIVEN EVENT E
                WHEN
                    E.isEquityFinanceEvent AND
                    AS OF E.date (This_SAFE.Terminated ~ False)
                THEN
                    Company MUST give Investor Amount of Safe_Preferred_Stock
                    WHERE
                        Amount = Purchase_Amount / Conversion_Price
                HENCE "Required Documentation", "Termination By Equity Event"

            RULE "Required Documentation"

                GIVEN EVENT E
                WHEN
                    E.isEquityFinanceEvent AND
                    AS OF E.date (This_SAFE.Terminated ~ False) AND
                    E.documentation.isStandard
                THEN
                FOR EACH Document in E.Required_Documents
                    Investor MUST
                        execute Document
                        AND THEN                        // sequential, not logical
                        deliver Document to Company  

            // RULE "Liquidity Event" ...

            // RULE "Dissolution Event" ...

            Rule "Termination By Equity Event"

                GIVEN Event T
                WHEN
                    T ~ Company give Investor Amount of Safe_Preferred_Stock
                THEN
                    This_SAFE.Terminated = True
					
        END SCOPE "Events"
    END SCOPE "Right to Shares"
END SCOPE This_SAFE

#+end_example
**** A Scope Statement

*** Expressions

#+begin_src bnfc :noweb-ref l4expressions
EString.      NormalString ::= String ;
ELangStrings. LangStrings  ::= [LangString] ;
    separator nonempty LangString " ";
ELangString.  LangString   ::= [LangID] ":" NormalString ;
ELangID.      LangID       ::= Ident ;
    separator nonempty LangID "," ;
#+end_src

**** String

A normal string looks ="like this"= and obeys the usual conventions around escaped backslashes, quotes, and newlines.

**** Language String

A language string is a normal string prefixed with a language ID prefix.

**** Language Identifiers

A language ID prefix is one or more Langauge

**** Language Stringset

A Language Stringset is one or more language strings separated by whitespace.

**** Lists

***** Plain Lists

Today's available flavours are: ~[Chocolate, Vanilla, Strawberry]~

***** Conjunctive Lists

The whole situation is a mess.

https://www.lectlaw.com/def/c282.htm says: "There are many cases in law where the conjunctive 'and' is used for the disjunctive 'or' and vice versa."

http://inthelandofinventedlanguages.com/index.php?page=excerpts&id=21 "You know what I mean!"

No I don't! https://edition.cnn.com/2018/02/09/us/dairy-drivers-oxford-comma-case-settlement-trnd/index.html

Let's work through an example. Over dinner. Actually, over dessert.

Suppose it is well known that a [[https://en.wikipedia.org/wiki/Neapolitan_ice_cream]["Neapolitan" ice cream]] must contain all of the following flavours: ~[Chocolate, Vanilla, Strawberry]~

No problem so far. Let's rephrase. Simple symbol manipulation, your basic propositional logic.

#+begin_quote
A "Neapolitan" ice cream must contain Chocolate, Vanilla, *and* Strawberry.
#+end_quote

expands, through distributivity of /must/ over /and/:
- a "Neapolitan" ice cream *must* contain Chocolate *and*
- a "Neapolitan" ice cream *must* contain Vanilla *and*
- a "Neapolitan" ice cream *must* contain Strawberry.

As a lawyer might put it: If any "limb" of the above argument fails, then what's in your ice cream bowl might be tasty, but it's not a valid Neapolitan.

All of this flashes through your mind in a split second when the waiter says: "I'm so sorry. We cannot serve Neapolitan ice cream tonight, because the kitchen doesn't have Chocolate, Vanilla, /and/ Strawberry."

By which we understand:
1. All three flavours are needed to form a Neapolitan.
2. The kitchen lacks at least one of them.
3. Thus, it is false that the kitchen has all of Chocolate, Vanilla, and Strawberry.
4. Therefore it is true that the kitchen does not have all of Chocolate, Vanilla, and Strawberry.

"But," interjects the waiter, seeing the look of disappointment on your face, "we're only out of Strawberry; we do have Chocolate and Vanilla; you can still have ice cream if you want."

This confirms that it is *not* true (as you might initially have feared) that the kitchen is completely out of ice cream. It is *not* true that
- the kitchen does not have Chocolate, *and*
- the kitchen does not have Vanilla, *and*
- the kitchen does not have Strawberry.

Wait a minute. Did we just flip the "or" for an "and"? We certainly did!

What *is* true is this:
- the kitchen does not have Chocolate, *or*
- the kitchen does not have Vanilla, *or*
- the kitchen does not have Strawberry.

This is [[https://en.wikipedia.org/wiki/De_Morgan%27s_laws][De Morgan]] at work. "The negation of a conjunction is the disjunction of the negations".

But wait, it gets worse. You say to the waiter:

"Mmm. Appreciate it, but no thanks. Let's just get a round of coffee, and then the check? We'll go to the ice cream shop next door."

"Fair enough, check coming right up!"

Some minutes later, you stroll next door to the ice cream shop.

"Welcome! You made it just before closing. So, we had a lot of customers today; we still have most of the flavours on the board, but we don't have Chocolate, Vanilla, and Strawberry."

Your brush with the Neapolitan is still fresh in your mind. The restaurant used identical phrasing, but meant a different thing! Fifteen minutes ago, next door, it meant that one of the three flavours was unavailable. Now, here, it means that all three are unavailable.

You can see what might drive people to invent a whole new language, [[https://en.wikipedia.org/wiki/Lojban][Lojban]].

In the ice cream shop, "we don't have Chocolate, Vanilla, and Strawberry" expands to:
- we don't have Chocolate *and*
- we don't have Vanilla *and*
- we don't have Strawberry.

In the restaurant, "we don't have Chocolate, Vanilla, and Strawberry" expands to:
- we don't have Chocolate *or*
- we don't have Vanilla *or*
- we don't have Strawberry.

How crazy is English? Distribution over a list is context-dependent! I guess De Morgan's laws were made to be broken.

***** Disjunctive Lists

Let's up the stakes. If English is nuts, we'll go nuts too.

The allergist says: your food must not contain any of the following ingredients: ~[Peanuts, Walnuts, Almonds]~.

Which is to say, the food must not contain Peanuts, Walnuts, or Almonds.

Or: "the food must not contain Peanuts, Walnuts, and Almonds"?

"Here you go. Don't worry, our Rocky Road doesn't contain peanuts, walnuts, and almonds."

Would you eat it?

***** Disjunctive Or versus Exclusive Or

We've talked about "and" meaning "or".

Don't get me started on [[https://en.wikipedia.org/wiki/Exclusive_or#Exclusive_%22or%22_in_English]["or" meaning "xor"]].

***** What is the total space?

Read chapter 11 of MSCDv4. The remainder of this section attempts to formalize all of the possible variants from that chapter.

***** Is there a better way?

L4 is a formal language. The meanings of expressions are explicitly defined.

****** Ternary Logic In L4: "three-valued Booleans"

Let ~p :: a -> Ternary~, which is to say, ~p~ is a predicate; given an input of type ~a~, it will always return Yes, No, or Neither -- "neither" meaning "unknown", "undefined", "null", or "wat". This is an example of a [[https://en.wikipedia.org/wiki/Three-valued_logic][ternary logic]].

Here's a predicate: "has five toes on each fore paw". Most cats, the predicate returns ~true~. But some cats have [[https://en.wikipedia.org/wiki/Polydactyl_cat][polydactyly]]. It's an unusual condition. You can count the number of polydactyls per thousand, on the fingers of ... uh, let's just say it's a rare condition. For them, the predicate would return ~false~.

But what about an amputee, who has no forelegs? They don't have six toes on each foot. They don't have five toes on each foot. They don't have feet at all.

What is the hair colour of a bald man?

What is the airspeed velocity of an unladen Martian swallow?

On a form, you would write in "N/A" for "Not applicable".

That's why we need ternary logic: sometimes yes, sometimes no, sometimes neither.

Here's another predicate: "tailless". The Manx breed are considered tailless -- they are "rumpies" and "stumpies".

A cat is special if it is polydactyl.

A cat is special if it is tailless.

A cat is valuable if it is both polydactyl and tailless.

I wanted to say "a cat is special if it is polydactyl or tailless", but that brings up "exclusive or" considerations -- some might say "if it is both polydactyl and tailless than it isn't special, because it's obviously valuable instead." They're reading "xor" into the "or", in the context of the next sentence.

It isn't logical, but it's English!

So we spare ourselves all that grief by giving explicit definitions. Watch.

****** Junction Lists

In Haskell, ~Data.List.all~ tests a single predicate against a collection of ~a~ values. You can say: the members of the Polydactyly Society are ~all polydactyl~. "Polydactyl" is the predicate. "The Polydactyly Society" is the collection. ~all polydactyl society~ returns ~True~.

#+begin_src haskell
  polydactyl :: Cat -> Bool
  polydactyl cat = length cat.frontLeft.toes  > 5 ||
                   length cat.frontRight.toes > 5

  society = filter polydactyl allcats
#+end_src

But sometimes you want to test a single value against a collection of predicates. Sometimes you want all the predicates to match.

#+begin_example
kitchen.canMakeNeapolitan = kitchen ~ [ hasChocolate
                                      & hasVanilla
                                      & hasStrawberry ]
#+end_example

Sometimes you want to test if any of the predicates match.

#+begin_example
dish.isDangerous = dish ~ [ hasPeanut     -- (hasPeanut dish) == True
                          | hasWalnut
                          | hasAlmond ]
#+end_example

The machinery for this:

#+begin_src haskell :tangle Preds.hs
module Preds where

  allPreds :: Foldable t => t (a -> Bool) -> a -> Bool
  allPreds preds value = all (flip ($) value) preds

  anyPreds :: Foldable t => t (a -> Bool) -> a -> Bool
  anyPreds preds value = any (flip ($) value) preds

  numPreds ::                [ a -> Bool ] -> a -> Int
  numPreds preds value = length (filter (flip ($) value) preds)

  xorPreds ::                [ a -> Bool ] -> a -> Bool
  xorPreds preds value = 1 == numPreds preds value

#+end_src

In L4, collections of predicates are called "junction lists". The term comes from "conjunctions" and "disjunctions", hence "junctions".

In L4, a *conjunctive list* is defined as a list of two or more predicates, in which the last two predicates are separated by a ~&~ character, for "and".

In L4, a *disjunctive list* is defined as a list of two or more predicates, in which the last two predicates are separated by a ~|~ character, for "or".

In L4, an *exclusive list* is defined as a list of two or more predicates, in which the last two predicates are separated by a ~X~ character, for "exclusive or".

In a junction list of three or more elements, the earlier predicates in the list can be separated by a comma "," or by the same as the final separator.

This makes it easy to write:

#+begin_example
  cats = [ alice
         , bob
         , carol
         , dan
         ]

  special = [ polydactyl
            | tailless 
            ]

  valuable = [ polydactyl
             & tailless 
             ]
#+end_example

Conjunctive lists are syntactic sugar for ~all~.

Disjunctive lists are syntactic sugar for ~any~.

Exclusive lists are syntactic sugar for ~oneOf~.

Lists can nest.

Next we talk about matching.

#+begin_example
  specialCats  = [ polydactyl | tailless ] cats
  valuableCats = [ polydactyl & tailless ] cats

  // note that we do NOT support these alternatives in L4 syntax:
  specialCats  = any [ polydactyl, tailless ] cats
  valuableCats = all [ polydactyl, tailless ] cats

  dish.isDangerous = dish [ hasPeanut
                          , hasWalnut
                          | hasAlmond ]
#+end_example

Space application is overloaded as follows:

| LHS            | RHS              | meaning                                         |
|----------------+------------------+-------------------------------------------------|
| junction list  | single value     |                                                 |
| single value   | junction list    | boolean                                         |
|----------------+------------------+-------------------------------------------------|
| junction list  | list of values   | filter for values which match the junction list |
| list of values | junction list    | filter for values which match the junction list |
|----------------+------------------+-------------------------------------------------|
| list of values | single predicate |                                                 |

The semantics of a conjunctive list:
#+begin_src haskell :tangle Matchable.hs
  module Matchable where

  -- TODO: make this work!

  class Matchable a where
    match  :: (Eq a, Foldable t) => a -> t a -> Bool

  newtype ConjList a = ConjList [a]
  newtype DisjList a = DisjList [a]

  instance Matchable (ConjList a) where
    match x = all (== x)

  instance Matchable (DisjList a) where
    match x = any (== x)
#+end_src

****** "Any" and "all"

Yay English! What's the difference between

"Any zombies will be shot on sight"

and

"All zombies will be shot on sight"

?

No difference!

This is why it's dangerous to reuse words with a rich existing history -- at some point, people will guess wrong.

First-order logic knows how to deal with this situation. That's why we have \exists and \forall.

**** Namespace Attributes

***** Automatic singular / plural support

In normal languages, ~object.party~ is a different attribute than ~object.parties~.

However, our language knows English grammar, so those two attributes automatically bind to the same referent, allowing more natural expression:

- ~object.party[A]~
- ~object.party[B]~
- ~object.parties[ALL]~
- ~object.parties[A & B]~
- ~object.parties[A | B]~

This may turn out to be a bit of a gotcha.

*** Defining Objects and Attributes

As in Javascript, objects contain a dictionary of attributes.

As in Haskell, we'd talk about a record type.

**** Multitemporality

Unlike Javascript, an attribute may be /multitemporal/:
- valid time
- transaction time
- decision time

An attribute is also /multivalent/: by default, every attribute of an object can have zero or more values; informally speaking, every attribute of type X is really a list of X.

Let's take a simple example. As in Typescript, we define an instance type for a human:
- human.birthdate :: Date
- human.fullname :: String
- human.nationality :: Country

Take Neta-Lee Hershlag. She was born in Israel in 1981; at least, that is what Wikipedia believes, as of the 10th of September 2020.

Guess what, though. She holds dual Israeli and American citizenship. Unusual, right? Most ontologies would only allow one citizenship to a person. Bit of a black swan. Let's use that as her codename.

#+begin_src haskell :noweb-ref l4entity
  ENTITY blackSwan
     ISA Human
    WITH birthdate   = [ { xtime: 2020-09-10, value: 1981-06-09 } ]
         nationality = [ { xtime: 2020-09-10, value: IL, vtime: 1981-06-09 -- present }
                       , { xtime: 2020-09-10, value: US                               } ]
#+end_src

We assume that her Israeli citizenship began at birth, but Wikipedia doesn't know when she became a US citizen; all we know is that as of September 10 2020, Wikipedia said she is one. So that citizenship value doesn't define a vtime.

Let's not commit the usual [[https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/][falsehoods programmers believe about names]]. Can someone have multiple names! Sure, why not? Some people change their names when they get married; others when they switch genders; lots of variability. Sometimes people just have multiple names at the same time. Our Black Swan does too:

#+begin_src haskell :noweb-ref l4entity
  -- someone can have multiple names too
         fullname    = [ { xtime: 2020-09-10, value: ["Neta-Lee Hershlag", "Natalie Portman"] } ]
#+end_src

As you can see, the "multitemporal" syntax allows us to easily handle scenarios like:
- On January 1, celebrities X and Y were known to be dating.
- By July 1, paparazzi sleuths found out that X and Y had gotten married some time in the past few months; the ceremony was said to have been held on a private island, but nobody's saying where or when it happened.
- On September 1, the couple spilled the details and shared that the wedding had happened on June 1.
- On December 1, the couple announced that they had gotten divorced on November 1.

#+begin_src haskell :noweb-ref l4entity
  ENTITY celebXY
     ISA Couple
    WITH [ { xtime: 2020-01-01, maritalStatus: dating  }
         , { xtime: 2020-07-01, maritalStatus: married }
         , { xtime: 2020-09-01, maritalStatus: married,  vtime: 2020-06-01 -- present }
         , { xtime: 2020-12-01, maritalStatus: married,  vtime: 2020-06-01 -- 2020-11-01 }
         , { xtime: 2020-12-01, maritalStatus: divorced, vtime: 2020-11-01 -- present    }
         ]
#+end_src

The "transaction time" shows when the system know something; the "valid time" shows when some situation was the case. This allows one to compute "on this date, what did we know?"

**** Epistemics

An attribute may also be /epistemic/:
- on August 1, Alice learned that she was pregnant
- on September 1, Alice wrote a letter to Bob telling him that she was pregnant, and sent it via registered post.
- by the notice terms of their pre-nup, Bob was deemed to receive notice three days after the mail was sent, on September 4.
- on October 1, Bob claimed to have actually received the notice on September 10, due to difficulties with the postal service.

#+begin_src haskell :noweb-ref l4entity
    KNOL alicePregnancy
    WITH [ { xtime: 2020-08-01, knownBy: Alice,                            beliefs:                 { pregnancy: true }                        }
         , { xtime: 2020-09-01,  toldBy: Alice,                            beliefs: { knownBy: Alice, pregnancy: true }  , toldTo: Bob         }
         , { xtime: 2020-09-01, knownBy: Alice, beliefs: { knownBy: Bob,   beliefs: { knownBy: Alice, pregnancy: true } }, vtime: 2020-09-04 } }
         , { xtime: 2020-10-01, knownBy:   Bob, beliefs: { knownBy: Alice, beliefs: { knownBy: Alice, pregnancy: true }  , vtime: 2020-09-01 }, vtime: 2020-09-10 }
         ]
#+end_src

*** Querying Objects and Attributes

We can ask fine-grained questions like:
- On a given date, what did entity E, or The Public, or The System generally, believe to be true about some entity E, or some unit of knowledge K?

By default, L4 expressions will default to the latest known information at the time of decision.

**** Using Object Attributes

Okay. Deep breath. Lower case and upper case are meaningful.

Specific individuals are lowercase, like blackSwan, or celebXY.

Interfaces, or classes, start with an uppercase letter, like Human or Couple.

Knols are belief structures, and have special attributes ~knownBy~, ~toldBy~, ~toldTo~, and ~beliefs~ attributes.

We use the "ASOF" keyword to give all the attributes a default ~xtime~ (transaction time). If it is omitted, it defaults to the execution time.

#+begin_src haskell :noweb-ref l4entity
  ENTITY veggieBar
     ISA Business
    WITH address = [ "1 Veggie Way" ]
         id      = { idtype = "UEN", idval = "202000000A" }
         name    = "The Veggie Bar Pte. Ltd."

  ENTITY buyCabbage
     ISA ContractOfSale
    ASOF 2020-09-10
    WITH date         = 2020-09-10
         jurisdiction = SG
         buyer        = blackSwan
         seller       = veggieBar
         buyer.consideration = $10
         seller.consideration = [ item1, item2 ]
   WHERE item1 ISA  Item
               WITH category = "vegetable"
                    species  = "Brassia oleracea"
                    cultivar = "capitata"
#+end_src

**** Matching Object Attributes

If this begins to feel weird, it's because under the hood, we're borrowing Prolog's unification and backtracking features.

Suppose a WHEN clause says ~object.MyAttr.isTrue~.

In a logic programming language that expression is synonymous with

~isTrue(object.MyAttr)~

~MyAttr~ takes on every attribute of ~object~ which is true

Within an ~object.[ ]~ attribute dereference, the following aliases exist:
- ALL :: unifies with every attribute
- ALL - PreviouslyUnified :: 

*** Ontology

AKA a type system

*** Metaprogramming

**** patterns

basically, macro expansions and function definitions

#+begin_src l4
  PATTERN myfirstpattern
  WHEREVER RuleMatchExpr // a lens-style pattern match against one or more rules
  TRANSFORM  AliasExpr
  TO         ReplacementExpr
  ...
#+end_src

TODO For example we expand a rule about potatoes to also apply to cabbages, expanding ~item.isPotato~ to ~(item.isPotato OR item.isCabbage)~ in the body of any Horn clause.



*** Comments

The usual:

=/* text within C-style comment blocks is ignored */=

=// text after Javascript-style comment slashes is ignored to end of line=

* Developers Guide

#+begin_src sh
$ stack install pretty-simple

$ fswatch -o Makefile l4.bnfc test1.l4 TestL.hs mkProlog.hs | perl -nle 'system("clear; make")'

$ ghcid --command "stack ghci" ./mkProlog.hs
#+end_src

* Output

#+begin_src bnfc :noweb yes :tangle l4.bnfc
<<l4rules>>
<<l4expressions>>
#+end_src
