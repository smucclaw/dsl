#+TITLE: LPAPCR34

In this case study, we formalize [[https://sso.agc.gov.sg/SL/LPA1966-S706-2015#pr34-][Section 34 of the Legal Profession (Professional Conduct) Rules 2015]].

See also [[https://github.com/smucclaw/fv/blob/taboo/Experiments/ProfessionalConductRule34/][the FV repo experiment]]. At some point these will be merged.

* Content

We represent all of Section 34 in L4. L4 (as currently defined) may not suffice to accurately and idiomatically represent Section 34. This use case therefore motivates improvement of the L4 language.

* Targets and Demonstrations

** Prolog
We create Prolog, in the spirit of "British Nationality Act as a Logic Program".

** Python
We automate the creation of a DocAssemble expert system.

We auto-generate Python to go into the DocAssemble YAML interview file.

** Formal Verification

We output to the model checking syntaxes shown in the [[https://github.com/smucclaw/fv/blob/taboo/Experiments/ProfessionalConductRule34/][FV repo]]. At some point these will be merged.

* L4 representation

** Section 1

1) A legal practitioner must not accept any executive appointment associated with any of the following businesses:
   a) any business which detracts from, is incompatible with, or derogates from the dignity of, the legal profession;
   b) any business which materially interferes with —
      1) the legal practitioner’s primary occupation of practising as a lawyer;
      2) the legal practitioner’s availability to those who may seek the legal practitioner’s services as a lawyer; or
      3) the representation of the legal practitioner’s clients;
   c) any business which is likely to unfairly attract business in the practice of law;
   d) any business which involves the sharing of the legal practitioner’s fees with, or the payment of a commission to, any unauthorised person for legal work performed by the legal practitioner;
   e) any business set out in the First Schedule;
   f) any business which is prohibited by —
      1) the Act;
      2) these Rules or any other subsidiary legislation made under the Act;
      3) any practice directions, guidance notes and rulings issued under section 71(6) of the Act; or
      4) any practice directions, guidance notes and rulings (relating to professional practice, etiquette, conduct and discipline) issued by the Council or the Society.


*** Let's talk commas!

=any business which detracts from, is incompatible with, or derogates from the dignity of, the legal profession=

Some style guides would argue that this comma is not strictly grammatical. Others would rebut that the last comma is necessary to disambiguate from

=any business which detracts from, is incompatible with, or derogates from, the dignity of the legal profession=

Before you read on: which makes more sense:
A. "detract from the legal profession"
B. "detract from the dignity of the legal profession"

If you answered B, you agree with the wording of the Second Schedule:

#+begin_quote
1. The business of the business entity —
(a) must not jeopardise the professional integrity, independence or competence of the legal practitioner; and
(b) must not detract from the standing and dignity of the legal profession.
#+end_quote

Analysis follows.

#+begin_example
// 1. the original phrasing invites this interpretation:
any business which - detracts from,
                   - is incompatible with,
                   or
                   - derogates from the dignity of,
                   the legal profession

// 2. Without a comma, it could mean the same as above...
any business which - detracts from,
                   - is incompatible with,
                     or
                   - derogates from the dignity of
                   the legal profession

// 3. ... or it could bind "the dignity of" differently, as in:
any business which - detracts from,
                   - is incompatible with,
                   or
                   - derogates from
                   the dignity of the legal profession

// 4. though if this were the intended interpretation we might place the comma differently:
any business which - detracts from,
                   - is incompatible with,
                   or
                   - derogates from,
                   the dignity of the legal profession

// can we think of a situation where
a business is compatible with the legal profession
but is incompatible with the dignity of the legal profession
?

scenario: a lawyer wants to make an indie movie on the side because of his lifelong interest in film. In the film, lawyers are portrayed negatively, as undignified. The movie is inspired in part by "Better Call Saul"
#+end_example


*** In L4, First Try

#+begin_src sql :noweb-ref section34-try1
  SECTION 34.1

   DEFINE 1base ISA DeonticRule
    GIVEN Predicate
    PARTY LegalPractitioner
    SHANT accept(role = ExecutiveAppointment)
    WHERE ExecutiveAppointment associated with Business
      AND Predicate (Business, LegalPractitioner)

   -- (expands to...)
 
   DEFINE 34.1.a ISA DeonticRule
    PARTY LegalPractitioner
    SHANT accept(role = ExecutiveAppointment)
    WHERE ExecutiveAppointment associated with Business
      AND Business detracts from legal_profession

   DEFINE 34.1.b ISA DeonticRule
    PARTY LegalPractitioner
    SHANT accept(role = ExecutiveAppointment)
    WHERE ExecutiveAppointment associated with Business
      AND Business materially_interferes ( with | primary_occupation
                                                | service_availability
                                                | client_representation
                                                of LegalPractitioner ) )

  -- note the preposition combinators are right associative

  RULE    34.1.a         -- syntax alternative 1: "or-list" with commas; the preps are partially applied
   RETURN 1base(Business [ detracts from
                         | is_incompatible with         -- LHS to a preposition
                         | derogates from dignity of ]  -- is a VPSlash
                         legal_profession )             -- "complement" to a preposition

   RETURN 1base(Business detracts from legal_profession )
   RETURN 1base(Business [ detracts from , is_incompatible with ]
                         [ legal_profession, financial_profession ] )


                       -- Applicatives: [ a, b, c ] <*> pure legal_profession

  RULE    34.1.b                                -- syntax 2: experimental
   RETURN 1base(Business materially_interferes ( with | primary_occupation
                                                      | service_availability
                                                      | client_representation
                                                      of LegalPractitioner ) )

  RULE    34.1.c                 -- consider right associativity
   RETURN 1base(Business likely ( to unfairly_attract_business in practice of law ) )

  RULE    34.1.d                    -- syntax 3: "any" of a normal [,,,] list
   RETURN 1base(Business involves ( any [ sharing_fees with
                                        , (payment of commission to)
                                        ] unauthorized_person
                                    for (legal_work performed by LegalPractitioner ) ) )


  RULE    34.1.e
   RETURN 1base(FirstSchedule(Business))


   -- syntax 4: with more explicit equals signs, resembling function params; can we get rid of them?
  RULE    34.1.f
   RETURN 1base(Business prohibitedByUsualSuspects)

  DEFINE  prohibitedByUsualSuspects
   SCOPE  SECTION 34
   HIDDEN true
   RETURN prohibited (by = [ the_Act
                           , [ these_rules | subsidiary_legislation ]
                           , any [ practice_directions , guidance_notes U rulings ]
                             issued (under = section 71.6 of Act)
                           | any [ practice_directions , guidance_notes U rulings ]
                             relating (to = [ professional_practice, etiquette, conduct U discipline ])
                             issued   (by = [ the_Council | the_Society ] )
                           ] )

#+end_src

*** Second Try, all in one giant block

**** As pseudo-L4
#+begin_src text :tangle test/section34-1.l4
  SECTION 34.1 :en:"Thirty Four, Part One"

     RULE 34.1.a ISA DeonticRule
    PARTY LegalPractitioner
    SHANT accept(executive_appointment, Business)
     WHEN any [ Business [ detracts_from
                         , is_incompatible_with
                         | derogates_from ] the_dignity_of the_legal_profession
              , Business materially_interferes_with [ LegalPractitioner's primary_occupation_of_practising_as_a_lawyer
                                                    , availability_to those_who may_seek LegalPractitioner's services_as_a_lawyer
                                                    | the_representation_of LegalPractitioner's clients ]
              , Business is_likely_to unfairly attract_business_in the_practice_of_law
              , Business involves [ the_sharing_of LegalPractitioner's fees with
                                  | the_payment_of a_commission to ]
                                  (any unauthorised_person)
                                  for (legal_work performed_by LegalPractitioner)
              , Business is in FirstSchedule
              , Business is prohibited_by [ the_Act
                                          , [ these_Rules
                                            | any_other_subsidiary_legislation
                                              made_under the_Act ]
                                          , any [ practice_directions
                                                , guidance_notes
                                                U rulings ]
                                            issued_under section_71(6)_of the_Act
                                          | any [ practice_directions
                                                , guidance_notes
                                                U rulings ]
                                            relating_to [ professional_practice
                                                        , etiquette
                                                        , conduct
                                                        & discipline ]
                                            issued_by [ the_Council | the_Society ]
                                          ]
              ]
#+end_src

**** Our front-end uses a few simple types

#+begin_src haskell :noweb-ref 34-types
  data Stm = Section TermExpr -- first TermExpr should always be an NL expression (:@)
           | DRule { rulename :: TermExpr -- deontic rule
                   , party  :: TermExpr
                   , dmodal :: Deontic
                   , action :: TermExpr
                   , when   :: Maybe TermExpr
                   }
           | CRule { item :: TermExpr
                   , body :: [TermExpr]
                   , when :: Maybe TermExpr
                   }
    deriving (Show, Eq)

  data TermExpr = String :@ [NLTag]            -- infix constructor for NL:    "potato" :@ [("en","Solanum Tuberosum")]
                | TKey Key                     -- "potato"
                | All [TermExpr]               -- and -- each element must evaluate true
                | Any [TermExpr]               -- or  -- only one element is needed to be true
                | And [TermExpr]               -- set union! inclusive "and" is not a logical "and"! more of an "or"
                | BinOp TermExpr BinOp TermExpr -- ace "of" bass, useful when either lhs or rhs term is itself an All/Any list
                | UnOp UnOp TermExpr
                | Prim PrimType
                | TE0                          -- nil
    deriving (Show, Eq)

  data UnOp = HasAttr
    deriving (Show, Eq)

  data BinOp = Cons
             | Compound
             | HasType
             | HasValue
             | TE2 TermExpr
             deriving (Show, Eq)

  type Key = String               -- ideally spaceless but can contain spaces. Maybe a Mk to s/ /_/g
  type NLTag = (Key,String)

  data Deontic = DMust | DMay | DShant deriving (Show, Eq)

#+end_src

**** As Raw Haskell

Given only those types, and the source text above, we write an AST by hand. Subsequently we will write a parser that turns the L4 syntax above into this AST.

For now we take the eDSL approach with a bit of syntactic sugar, and write the AST from scratch. There are emoji galore below, so I hope your editor can view them.

#+begin_src haskell :noweb-ref 34-haskell

  section34 :: [Stm]
  section34 = [ (§) ("34" :@ [("en","Thirty Four, part One")
                             ,("se","lasdkjklasdjf")]) -- subsequently we speechbubble with English as default
              , section34_1 ]

  section34_1 :: Stm
  section34_1 =
    (§§) ("34.1" 💬 "Prohibitions")
    ("LP" 💬 "Legal Practitioner")
    mustNot
    (en_ "accept" ⏩ ["execA" 💬 "executive appointment", "Business" 💬 "business"])
    (Any [ "Business" 👉 Any [ (en_ "detracts" `_from`)                        -- [ (1 +),
                                , ("incompat" 💬 "is incompatible" `_with`)    --   (2 *),
                                , (en_ "derogates" `_from`)                    --   (10 -) ] <*> [400] = [401, 800, -390]
                                ] $ (en_ "dignity") `of_` ("profession" 💬 "legal profession")
           , "Business" 👉 (en_ "materially interferes with") $
             Any [ lp's ("occ" 💬 "primary occupation") `of_` (en_ "practising") `as_` (en_ "lawyer")
                 , lp's $ en_ "availability to those who may seek" <> lp's (en_ "services as a lawyer")
                 , en_ "representation" `of_` lp's ( en_ "clients" ) ]
           , "Business" 👉 (en_ "is likely to") $ (en_ "unfairly attract business") `in_` (en_ "practice of law")
           , "Business" 👉 (en_ "involves") $ ( Any [ ((en_ "sharing") `of_` (lp's (en_ "fees")) `_with`)
                                                    , (en_ "payment" `of_` en_ "commission" `_to`) ] <>
                                                Any [ en_ "unauthorised person" ] `for_`
                                                en_ "legal work performed" `by_`
                                                (TKey "LP") )
           , "Business" 👉 ("isIn" 💬 "is in") $ ("Schedule1" 💬 "First Schedule")
           , "Business" 👉 ("isProhibitedBy" 💬 "is prohibited by") $
             Any [ en_ "Act"
                 , Any [ en_ "these Rules"
                       , en_ "any other subsidiary legislation made under the Act" ] -- not enough structure?
                 , And [ en_ "practice directions", en_ "guidance notes", en_ "rulings" ]
                   <> en_ "issued under section 71(6) of the Act" -- should "under" be a preposition like the others?
                 , And [ en_ "practice directions", en_ "guidance notes", en_ "rulings" ]
                   <> en_ "relating" `to_` And [ en_ "professional practice", en_ "etiquette", en_ "conduct", en_ "discipline" ]
                   <> en_ "issued" `by_` Any [ en_ "Council", en_ "Society" ]
               ]
           ]
    )

#+end_src

Emacs users may need to put this in their =.emacs=:
#+begin_src elisp
(set-fontset-font t 'symbol "Apple Color Emoji")
#+end_src

The emojis above are part of the syntactic sugar used to create the actual AST.

#+begin_src haskell :noweb-ref 34-haskell
  -- by default, we construct an English term, but this could evolve toward wordnet
  (💬) :: String -> String -> TermExpr
  infixr 7 💬
  ex 💬 tag = ex :@ [("en",tag)]

  -- wordnet!
  (🔤) :: String -> Integer -> TermExpr
  infixr 7 🔤
  ex 🔤 tag = ex :@ [("wordnet",show tag)]

  (📭) :: TermExpr -> TermExpr -> TermExpr
  infix 6 📭
  var 📭 typ = BinOp var HasType typ

  (📩) :: String -> PrimType -> TermExpr
  infix 7 📩
  var 📩 val = BinOp (var 💬 var) HasValue (Prim val)

  data PrimType
    = L4True | L4False
    | L4S String
    deriving (Show, Eq)

  isa = (📭)
  infix 6 `isa`

  (📪) = typ
  typ = "Type" 💬 "Base Type"
  bool = "Bool" 💬 "Primitive Type Boolean"
  str = "String" 💬 "Primitive Type String"

  (§=) = (📬)
  (📬) :: TermExpr -> String -> TermExpr
  infix 6 📬
  obj 📬 t = BinOp obj HasType (t 💬 "User Defined Type")

  en_ :: String -> TermExpr
  en_ ex = ex :@ [("en",ex)]

  nl_ :: String -> TermExpr
  nl_ ex = ex :@ []

  -- syntactic sugar for a prolog-style Compound term: lhs(r,h,s)
  (⏩) :: TermExpr -> [TermExpr] -> TermExpr
  infixr 5 ⏩
  lhs ⏩ rhs = BinOp lhs Compound (telist2conslist rhs)

  telist2conslist :: [TermExpr] -> TermExpr
  telist2conslist (te:[]) = te
  telist2conslist (t:tes) = BinOp t Cons (telist2conslist tes)

  -- StringValue -> BinOp "hasAttr" Compound StringValue
  hasAttr :: TermExpr -> TermExpr
  hasAttr te = UnOp HasAttr te

  -- executive appointment IS associatedWith Something
  -- becomes, in prolog, associatedWith(ExecutiveAppointment, Something)
  -- which is basically a bit of a flip and rearrangement of the above
  (👉) :: Key -> TermExpr -> TermExpr -> TermExpr
  infixr 5 👉
  lhs 👉 compound = \rhs -> BinOp compound Compound (telist2conslist [TKey lhs, rhs])

  -- section marker. this always has to be wrapped in () because it's a section?
  (§) :: TermExpr -> Stm
  (§) = Section

  -- deontic rule -- party x must y
  type MkDRule = TermExpr -> TermExpr -> Deontic -> TermExpr -> TermExpr -> Stm
  (§§) :: MkDRule
  (§§) a b c d e = DRule a b c d (Just e)

  -- constitutive rule
  {- DEFINE x ISA Type
       WITH attribute ISA String
            attribute2 ISA Boolean
  -} 
  type MkCRule = TermExpr -> [TermExpr] -> Stm
  (§=§) :: MkCRule
  (§=§) item body = CRule item body Nothing

  -- attribute constructors
  type MkDef = TermExpr -> TermExpr -> TermExpr
  (§.=§) :: MkDef
  (§.=§) a b = BinOp a HasType b

  (§.=) :: MkDef
  (§.=) a b = BinOp a HasValue b

  instance Semigroup TermExpr where (<>) x y = BinOp x Cons y

  _'s :: Key -> TermExpr -> TermExpr
  infixr 6 `_'s`
  x `_'s` y = TKey x `possessive` y

  -- we hardcode "LP" to mean Legal Practitioner
  lp's = _'s "LP"

  mustNot = DShant
  mayNot  = DShant
  must    = DMust
  may     = DMay
  dshow DShant = "SHANT"
  dshow DMust  = "MUST"
  dshow DMay   = "MAY"

  binop op x y = BinOp x (TE2 (op :@ [])) y

  -- this is a sign we need to learn Template Haskell
  infixr 6 `of_`;     of_ = binop "of";      infixr 5 `_of`;    _of  x = x <> (nl_ "of")  
  infixr 6 `to_`;     to_ = binop "to";      infixr 5 `_to`;    _to  x = x <> (nl_ "to")  
  infixr 6 `as_`;     as_ = binop "as";      infixr 5 `_as`;    _as  x = x <> (nl_ "as")  
  infixr 6 `in_`;     in_ = binop "in";      infixr 5 `_in`;    _in  x = x <> (nl_ "in")  
  infixr 6 `is_`;     is_ = binop "is";      infixr 5 `_is`;    _is  x = x <> (nl_ "is")  
  infixr 6 `by_`;     by_ = binop "by";      infixr 5 `_by`;    _by  x = x <> (nl_ "by")  
  infixr 6 `for_`;   for_ = binop "for";     infixr 5 `_for`;   _for x = x <> (nl_ "for") 
  infixr 6 `with_`; with_ = binop "with";    infixr 5 `_with`; _with x = x <> (nl_ "with")
  infixr 6 `from_`; from_ = binop "from";    infixr 5 `_from`; _from x = x <> (nl_ "from")

  infixr 6 `possessive`
  possessive = binop "'s"

  isPrep "of" = True 
  isPrep "to" = True 
  isPrep "as" = True 
  isPrep "in" = True 
  isPrep "is" = True 
  isPrep "by" = True 
  isPrep "for" = True
  isPrep "with" = True
  isPrep "from" = True
  isPrep _ = False   

#+end_src

**** Pretty-Printed AST

Here's what the output looks like, with perhaps a little more pretty-printing than really necessary

#+begin_example
[ Section
    ( "34" :@
        [
            ( "en"
            , "Thirty Four, part One"
            )
        ]
    )
, DRule
    { rulename = "34.1" :@
        [
            ( "en"
            , "Prohibitions"
            )
        ]
    , party = "LP" :@
        [
            ( "en"
            , "Legal Practitioner"
            )
        ]
    , dmodal = DShant
    , action = BinOp
        ( "accept" :@
            [
                ( "en"
                , "accept"
                )
            ]
        ) Compound
        ( BinOp
            ( "execA" :@
                [
                    ( "en"
                    , "executive appointment"
                    )
                ]
            ) Cons
            ( "Business" :@
                [
                    ( "en"
                    , "business"
                    )
                ]
            )
        )
    , when = Just
        ( Any
            [ BinOp
                ( Any
                    [ BinOp
                        ( "detracts" :@
                            [
                                ( "en"
                                , "detracts"
                                )
                            ]
                        ) Cons ( "from" :@ [] )
                    , BinOp
                        ( "incompat" :@
                            [
                                ( "en"
                                , "is incompatible"
                                )
                            ]
                        ) Cons ( "with" :@ [] )
                    , BinOp
                        ( "derogates" :@
                            [
                                ( "en"
                                , "derogates"
                                )
                            ]
                        ) Cons ( "from" :@ [] )
                    ]
                ) Compound
                ( BinOp ( TKey "Business" ) Cons
                    ( BinOp
                        ( "dignity" :@
                            [
                                ( "en"
                                , "dignity"
                                )
                            ]
                        )
                        ( TE2 ( "of" :@ [] ) )
                        ( "profession" :@
                            [
                                ( "en"
                                , "legal profession"
                                )
                            ]
                        )
                    )
                )
            , BinOp
                ( "materially interferes with" :@
                    [
                        ( "en"
                        , "materially interferes with"
                        )
                    ]
                ) Compound
                ( BinOp ( TKey "Business" ) Cons
                    ( Any
                        [ BinOp
                            ( BinOp ( TKey "LP" )
                                ( TE2 ( "'s" :@ [] ) )
                                ( "occ" :@
                                    [
                                        ( "en"
                                        , "primary occupation"
                                        )
                                    ]
                                )
                            )
                            ( TE2 ( "of" :@ [] ) )
                            ( BinOp
                                ( "practising" :@
                                    [
                                        ( "en"
                                        , "practising"
                                        )
                                    ]
                                )
                                ( TE2 ( "as" :@ [] ) )
                                ( "lawyer" :@
                                    [
                                        ( "en"
                                        , "lawyer"
                                        )
                                    ]
                                )
                            )
                        , BinOp ( TKey "LP" )
                            ( TE2 ( "'s" :@ [] ) )
                            ( BinOp
                                ( "availability to those who may seek" :@
                                    [
                                        ( "en"
                                        , "availability to those who may seek"
                                        )
                                    ]
                                ) Cons
                                ( BinOp ( TKey "LP" )
                                    ( TE2 ( "'s" :@ [] ) )
                                    ( "services as a lawyer" :@
                                        [
                                            ( "en"
                                            , "services as a lawyer"
                                            )
                                        ]
                                    )
                                )
                            )
                        , BinOp
                            ( "representation" :@
                                [
                                    ( "en"
                                    , "representation"
                                    )
                                ]
                            )
                            ( TE2 ( "of" :@ [] ) )
                            ( BinOp ( TKey "LP" )
                                ( TE2 ( "'s" :@ [] ) )
                                ( "clients" :@
                                    [
                                        ( "en"
                                        , "clients"
                                        )
                                    ]
                                )
                            )
                        ]
                    )
                )
            , BinOp
                ( "is likely to" :@
                    [
                        ( "en"
                        , "is likely to"
                        )
                    ]
                ) Compound
                ( BinOp ( TKey "Business" ) Cons
                    ( BinOp
                        ( "unfairly attract business" :@
                            [
                                ( "en"
                                , "unfairly attract business"
                                )
                            ]
                        )
                        ( TE2 ( "in" :@ [] ) )
                        ( "practice of law" :@
                            [
                                ( "en"
                                , "practice of law"
                                )
                            ]
                        )
                    )
                )
            , BinOp
                ( "involves" :@
                    [
                        ( "en"
                        , "involves"
                        )
                    ]
                ) Compound
                ( BinOp ( TKey "Business" ) Cons
                    ( BinOp
                        ( Any
                            [ BinOp
                                ( BinOp
                                    ( "sharing" :@
                                        [
                                            ( "en"
                                            , "sharing"
                                            )
                                        ]
                                    )
                                    ( TE2 ( "of" :@ [] ) )
                                    ( BinOp ( TKey "LP" )
                                        ( TE2 ( "'s" :@ [] ) )
                                        ( "fees" :@
                                            [
                                                ( "en"
                                                , "fees"
                                                )
                                            ]
                                        )
                                    )
                                ) Cons ( "with" :@ [] )
                            , BinOp
                                ( BinOp
                                    ( "payment" :@
                                        [
                                            ( "en"
                                            , "payment"
                                            )
                                        ]
                                    )
                                    ( TE2 ( "of" :@ [] ) )
                                    ( "commission" :@
                                        [
                                            ( "en"
                                            , "commission"
                                            )
                                        ]
                                    )
                                ) Cons ( "to" :@ [] )
                            ]
                        ) Cons
                        ( BinOp
                            ( Any
                                [ "unauthorised person" :@
                                    [
                                        ( "en"
                                        , "unauthorised person"
                                        )
                                    ]
                                ]
                            )
                            ( TE2 ( "for" :@ [] ) )
                            ( BinOp
                                ( "legal work performed" :@
                                    [
                                        ( "en"
                                        , "legal work performed"
                                        )
                                    ]
                                )
                                ( TE2 ( "by" :@ [] ) ) ( TKey "LP" )
                            )
                        )
                    )
                )
            , BinOp
                ( "isIn" :@
                    [
                        ( "en"
                        , "is in"
                        )
                    ]
                ) Compound
                ( BinOp ( TKey "Business" ) Cons
                    ( "Schedule1" :@
                        [
                            ( "en"
                            , "First Schedule"
                            )
                        ]
                    )
                )
            , BinOp
                ( "isProhibitedBy" :@
                    [
                        ( "en"
                        , "is prohibited by"
                        )
                    ]
                ) Compound
                ( BinOp ( TKey "Business" ) Cons
                    ( Any
                        [ "Act" :@
                            [
                                ( "en"
                                , "Act"
                                )
                            ]
                        , Any
                            [ "these Rules" :@
                                [
                                    ( "en"
                                    , "these Rules"
                                    )
                                ]
                            , "any other subsidiary legislation made under the Act" :@
                                [
                                    ( "en"
                                    , "any other subsidiary legislation made under the Act"
                                    )
                                ]
                            ]
                        , BinOp
                            ( And
                                [ "practice directions" :@
                                    [
                                        ( "en"
                                        , "practice directions"
                                        )
                                    ]
                                , "guidance notes" :@
                                    [
                                        ( "en"
                                        , "guidance notes"
                                        )
                                    ]
                                , "rulings" :@
                                    [
                                        ( "en"
                                        , "rulings"
                                        )
                                    ]
                                ]
                            ) Cons
                            ( "issued under section 71(6) of the Act" :@
                                [
                                    ( "en"
                                    , "issued under section 71(6) of the Act"
                                    )
                                ]
                            )
                        , BinOp
                            ( And
                                [ "practice directions" :@
                                    [
                                        ( "en"
                                        , "practice directions"
                                        )
                                    ]
                                , "guidance notes" :@
                                    [
                                        ( "en"
                                        , "guidance notes"
                                        )
                                    ]
                                , "rulings" :@
                                    [
                                        ( "en"
                                        , "rulings"
                                        )
                                    ]
                                ]
                            ) Cons
                            ( BinOp
                                ( "relating" :@
                                    [
                                        ( "en"
                                        , "relating"
                                        )
                                    ]
                                )
                                ( TE2 ( "to" :@ [] ) )
                                ( BinOp
                                    ( And
                                        [ "professional practice" :@
                                            [
                                                ( "en"
                                                , "professional practice"
                                                )
                                            ]
                                        , "etiquette" :@
                                            [
                                                ( "en"
                                                , "etiquette"
                                                )
                                            ]
                                        , "conduct" :@
                                            [
                                                ( "en"
                                                , "conduct"
                                                )
                                            ]
                                        , "discipline" :@
                                            [
                                                ( "en"
                                                , "discipline"
                                                )
                                            ]
                                        ]
                                    ) Cons
                                    ( BinOp
                                        ( "issued" :@
                                            [
                                                ( "en"
                                                , "issued"
                                                )
                                            ]
                                        )
                                        ( TE2 ( "by" :@ [] ) )
                                        ( Any
                                            [ "Council" :@
                                                [
                                                    ( "en"
                                                    , "Council"
                                                    )
                                                ]
                                            , "Society" :@
                                                [
                                                    ( "en"
                                                    , "Society"
                                                    )
                                                ]
                                            ]
                                        )
                                    )
                                )
                            )
                        ]
                    )
                )
            ]
        )
    }
]
#+end_example

**** The Parser

This is a work in progress.
#+begin_src haskell :noweb-ref 34-parser
  -- an L4 document is a list of stanzas
  parseL4 :: Parser [Stm]
  parseL4 = do
    stm <- parseStm
    rhs <- parseL4
    eof
    return (stm : rhs)

  -- a stanza
  parseStm :: Parser Stm
  parseStm = do
    many newline
    stm <- choice [ try (Section           <$> (lexeme "SECTION" *> parseNLStr))
                  , try parseDeonticRule
                  , try parseConstitutiveRule
                  ]
    return stm

  -- RULE PARTY X MUST Y
  parseDeonticRule :: Parser Stm
  parseDeonticRule = do
    ruleName <- space *> lexeme "RULE"    *> parseNLStr <* lexeme "ISA" <* lexeme "DeonticRule" <* some newline
    party    <- space *> lexeme "PARTY"   *> parseNLStr <*                                         some newline
    dmodal   <- space *> lexeme (DMust  <$ "MUST" <|>
                                 DMay   <$ "MAY"  <|>
                                 DShant <$ "SHANT")
    action   <-          lexeme parseTermExpr <* some newline
    when     <- optional (space *> lexeme "WHEN" *> parseTermExpr)
    return (DRule ruleName party dmodal action when)

  -- DEFINE X IS BLAH
  parseConstitutiveRule :: Parser Stm
  parseConstitutiveRule = do
    item     <- space *> lexeme "DEFINE"  *> parseNLStr <*                                         some newline
    body     <-     many (lexeme parseTermExpr <* some newline)
    when     <- optional (space *> lexeme "WHEN" *> parseTermExpr)
    return (CRule item body when)

  -- SomeString :en:"Some String"
  parseNLStr :: Parser TermExpr
  parseNLStr = do
    exPart    <- lexeme $ some (alphaNumChar <|> char '.')
    tagsPart  <- many (lexeme parseTag)
    return $ exPart :@ tagsPart

  -- :en:"Some String"
  parseTag :: Parser NLTag
  parseTag = do
    lhs <- between (char ':') (char ':') (some alphaNumChar)
    rhs <- stringLiteral
    return (lhs, rhs)

  -- sooner or later we will need to think about https://github.com/glebec/left-recursion
  parseTermExpr :: Parser TermExpr
  parseTermExpr = return $ "burf" :@ []
    
#+end_src

**** We can print the manually generated AST or the parsed STDIN
#+begin_src haskell :noweb-ref 34-app
  someFunc :: String -> IO ()
  someFunc myinput = do
    let stdinAST = case parse parseL4 "parsing L4 toplevel" (pack myinput) of
                     Left  someError  -> error $ errorBundlePretty someError
                     Right rhs -> rhs
    (opts,runCmd) <-
      simpleOptions "v0.01" "lpapcr34" "an early L4 prototype for section 34" (pure ()) $
      do addSubCommands "pretty" "pretty-print" (
           do addCommand "ast"   "the manual AST" (const (pPrint section34)) (pure ())
              addCommand "baby"  "the baby AST"   (const (pPrint superSimple1)) (pure ())
              addCommand "babyts"  "the baby AST as typescript"   (const (printStms To_TS superSimple1)) (pure ())
              addCommand "stdin" "parsed STDIN"   (const (pPrint stdinAST))  (pure ())
           )
         -- i think there is a bug in optparse-simple, honestly
         addCommand "prolog" "output to prolog" (const (mapM_ (putStrLn . show . stmToProlog) section34)) (pure ())
         addCommand "plain"  "output to plain"  (const (mapM_ (putStrLn .        stmToPlain)  section34)) (pure ())
    runCmd
#+end_src

**** Let's try outputting to Prolog

First, a little theory.

Prolog is cool with compound terms: anywhere you can have a =plain(term)=, you can =have(a(compound(term)))=.

Now, the L4 AST contains a lot of structure. A =TermExpr= has a couple of tree constructors: =BinOp= and =UnaOp= are the "middle management" nodes in a tree whose leaves tend to be =:@= terms, perhaps parked under a =TKey= or =TE2=. This may not be enough to capture some exceptions, like ditransitive verbs, mentioned [[https://allthingslinguistic.com/post/100781064586/how-to-draw-syntax-trees-part-4-type-2-a][here]], but it gives us nearly as much rope as a GF-style natural language grammar.

Prolog doesn't need quite that much structure: typically we would just deal with that notion as a single concept =half_of_a_potato=.

To get that we linearize the tree DFS left-to-right.

What if the semantics require a different kind of break down? What if we want =half_of(a_potato)=? We'll cross this bridge when we come to it.

So, that's the basic theory behind linearization of the AST to Prolog.

What special cases might we need to consider?

In the AST Meng defined =compl= as "complement", when it's not obvious what the connector? preposition? should be: "half a potato". The "of" is dropped, so we just use "compl" as the binary operator; and when we linearize, we just drop that too.

What if a term involves a variable? Like, suppose we have "half of a green Fruit". We don't want to say =half_of_a_green_Fruit= because that jams the =Fruit= variable into the term; it should be separate.

What would work? Let's work toward more structure:

1. =half_of_a_green_Fruit= -- not enough structure
2. =half_of_a_green(Fruit)= -- Fruit stands alone, good
3. =half_of_a(green,Fruit)= -- looking ahead to the future, we will probably want to have =(Color,Fruit)=
4. =half_of(a(green,Fruit))= -- maybe the "a" determiner applies to "green fruit".
5. =half_of(a(green),Fruit)= -- maybe the "a" determiner applies to "green".
6. =of(half,a(green,Fruit))= -- this is a fully structured version, at least where Prolog is concerned
7. =half(green(Fruit))= -- maybe Prolog would prefer this form? It all depends on the application.

Note that this structure doesn't really match the "binary tree" we described above: a linearization of =a(green,Fruit)= would give "green a Fruit". So we should keep in mind that the binary tree in the AST doesn't look exactly the same as a binary tree in Prolog.

Back to the original question: how do we linearize? We know that linearization is affected by whether a node is a =Variable= (uppercase) or a non-variable =term=.

Let's look at some desired inputs and outputs; from that, we'll know what code to write.

The location probably affects the linearization, too, so let's keep a input column for that.

| Input                                                                 | location | Output        |
|-----------------------------------------------------------------------+----------+---------------|
| BinOp ( "detracts" :@ [ ( "en" , "detracts" ) ] ) Cons ( "from" :@ [] |          | detracts_from |
|                                                                       |          |               |

#+begin_src haskell :noweb-ref 34-prolog
    stmToPlain :: Stm -> String
    stmToPlain (Section te) = plain te

    stmToProlog :: Stm -> Doc ann
    stmToProlog (Section te) = "%% " <> pretty (stmToL4 (Section te))
    stmToProlog (DRule rn p d a w) =
      let headP = "drule" <> parencomma [ dquotes (pretty $ plain rn)
                                        , "SubRuleName"
                                        , teToProlog p
                                        , pretty ((toLower <$> dshow d) :: String)
                                        , teToProlog a ]
          varargs = teToProlog p : unwrapP a
      in vsep ( [ if null w
                     then headP <> pretty '.'
                     else hang 4 (headP <+> ":-" <+> ("subRule" <> parencomma ("SubRuleName" : varargs) <> pretty '.') )
                   ] ++ (intersperse line' (asPrologSubrules w varargs)) )

    asPrologSubrules :: Maybe TermExpr -> [Doc ann] -> [Doc ann]
    asPrologSubrules Nothing _ = [emptyDoc]
    asPrologSubrules (Just (Any termexprs)) varargs = asPrologSubrule varargs <$> (zip ['A'..] termexprs)

    asPrologSubrule :: [Doc ann] -> (Char, TermExpr) -> Doc ann
    asPrologSubrule varargs (ruleNum, te) =
      hang 5
      ("subRule" <> parencomma ([ pretty ("subRule_"++[ruleNum]) ] ++ varargs) <+> (":-") <> line <> (teToProlog te) <> pretty '.')


    unwrapP :: TermExpr -> [Doc ann]
    unwrapP (mainex :@ nltags) = [pretty $ tr_ mainex]
    unwrapP (TKey tkey)        = [pretty $ tr_ tkey]
    unwrapP (All termexprs)    = teToProlog <$> termexprs
    unwrapP orig@(Any termexprs)     = teToProlog <$> termexprs
    unwrapP (And termexprs)          = teToProlog <$> termexprs
    unwrapP orig@(BinOp te1 Compound te3) = [teToProlog te3]
    unwrapP orig@(BinOp te1 bo2 te3) = [teToProlog te1, teToProlog te3]

    parencomma docs = parens (hsep $ punctuate (pretty ',') docs)

    data NLConj = NLAny | NLAnd | NLAll | NLJust deriving (Show, Eq)
    -- we convert the TermExpr AST into a tree of pretty-printable strings -- Natural Language Intermediate Representation
    type NLTree NLConj String
    type NLIR = Tree NLTree
    -- this is especially useful in the expansion of "any" and "all" subexpressions to disjunctive normal form:
    -- input:      [ foo, any [bar, baz], quux ]
    -- output: any [ foo bar quux, foo baz quux ]
    -- input:      [ foo, any [bar, baz], all [fee, fie], quux]
    -- output: any [ foo bar (fee and fie) quux, foo baz (fee and fie) quux ] ]
    -- then we compose the NLR into prolog formulas
    sample :: NLIR
    sample = Node (NLJust "the") [Node (NLAnd [ Node (NLJust "cat") []
                                              , Node (NLJust "dog") []]

    teToProlog :: TermExpr -> Doc ann
    teToProlog orig@(mainex :@ nltags) = pretty $ plain orig
    teToProlog orig@(TKey tkey)        = pretty $ plain orig
    teToProlog (All termexprs)    = "TODO All"
    teToProlog orig@(Any termexprs)     = vcat $ punctuate (semi <> PP.space) (teToProlog <$> termexprs)
    teToProlog (And termexprs)          = "TODO And"
    teToProlog orig@(BinOp x Cons te2@(y :@ _))
      | isPrep y  = teToProlog x <>          "_" <> teToProlog te2
      | otherwise = teToProlog x <> comma <> " " <> teToProlog te2
    teToProlog orig@(BinOp x Cons y)          = teToProlog x <> comma <> " " <> teToProlog y
    teToProlog orig@(BinOp (Any lhss) co rhs) = teToProlog (Any ((\lhs -> (BinOp lhs co rhs)) <$> lhss)) -- compound or cons
    teToProlog orig@(BinOp lhs co (Any rhss)) = teToProlog (Any ((\rhs -> (BinOp lhs co rhs)) <$> rhss))
    teToProlog orig@(BinOp (All lhss) co rhs) = teToProlog (All ((\lhs -> (BinOp lhs co rhs)) <$> lhss)) -- compound or cons
    teToProlog orig@(BinOp lhs co (All rhss)) = teToProlog (All ((\rhs -> (BinOp lhs co rhs)) <$> rhss))
    teToProlog orig@(BinOp (BinOp tk1 (TE2 ("'s" :@ [])) tk2) (TE2 ("of" :@ [])) te3) = teToProlog tk2 <> "_of" <> parencomma [teToProlog tk1, teToProlog te3]
    teToProlog orig@(BinOp te1 Compound te2)     = teToProlog te1 <> parencomma [teToProlog te2]
    teToProlog orig@(BinOp te1 (TE2 ("'s" :@ [])) te3@(te3a :@ _)) = teToProlog te3 <> parencomma [teToProlog te1] -- step 1
    teToProlog orig@(BinOp te1 (TE2 ("'s" :@ [])) te3@(BinOp te3a Cons te3c)) = teToProlog te3a <> parencomma [teToProlog te1, teToProlog te3c] -- step 3
    teToProlog orig@(BinOp te1 (TE2 ("'s" :@ [])) te3) = "unhandled deep BinOp for " <> teToProlog te1
    teToProlog orig@(BinOp te1 (TE2 ("of" :@ [])) te3) = teToProlog te1 <> "_of_" <> teToProlog te3
    teToProlog orig@(BinOp te1 (TE2 ("as" :@ [])) te3) = teToProlog te1 <> "_as_" <> teToProlog te3
    teToProlog orig@(BinOp te1 (TE2 (prep :@ [])) te3) = pretty prep <> parencomma [teToProlog te1, teToProlog te3]

    {- INPUT
       , BinOp
           ( TKey "LP" )
           ( TE2 ( "'s" :@ [] ) )
           ( BinOp
               ( "availability to those who may seek" :@ [ ( "en" , "availability to those who may seek" ) ] )
               Cons
               ( BinOp
                   ( TKey "LP" )
                   ( TE2 ( "'s" :@ [] ) )
                   ( "services as a lawyer" :@ [ ( "en" , "services as a lawyer" ) ] )
               )
           )
      OUTPUT
      availability_to_those_who_may_seek(LP, services_as_a_lawyer(LP))

      step 1: BinOp (TKey LP , TE2 's, services as a lawyer
              services_as_a_alwyer(LP)

      step 2: BinOp (availability, Cons, step1)
              \x -> availability(x, step1)
      in practice we bypass this step

      step 3: BinOp (TKey LP, TE2 's, step2)
              availabiilty(LP, step1)

    -}

    plain :: TermExpr -> String
    plain (mainex :@ nltags) = tr_ mainex
    plain (TKey tkey)        = tr_ tkey

    tr_ = tr " " "_"

    -- tr "abc" "123" "a cow" -> "1 3ow"
    tr x y cs = [ maybe c (y !!) eI | c <- cs, let eI = elemIndex c x ]

    stmToL4 :: Stm -> String
    stmToL4 (Section te)       = unlines [ unwords [ "SECTION",             teToL4 toplevel te ] ]
    stmToL4 (DRule rn p d a w) = unlines [ unwords [ "   RULE",             teToL4 toplevel rn ]
                                         , unwords [ "  PARTY",             teToL4 toplevel p ]
                                         , unwords [ "  "  ++ dshow d,      teToL4 toplevel a ]
                                         , unwords [ "   " ++ maybe "-- EVER"
                                                                  (("WHEN " ++) . teToL4 toplevel) w ]

                                         ]
    -- rule_34_1(party(LegalPractitioner), shant, accept(ExecA)) :- assocWith(ExecA, Business),
    --    detracts_from
    toplevel = Ctx []

    data Context = Ctx { stack    :: [TermExpr] } deriving (Show, Eq)

    ppTE ctx orig@(Any termexprs)     = "Any " ++ (show $ brackets (hcat $ punctuate (comma) (pretty . (teToL4' ctx orig) <$> termexprs )))

    -- this Context thing really should be a State monad
    teToL4 :: Context -> TermExpr -> String
    teToL4 ctx (mainex :@ nltags) = mainex
    teToL4 ctx (TKey tkey)        = tkey
    teToL4 ctx (All termexprs)    = "TODO All"
    teToL4 ctx orig@(Any termexprs)     = "TODO Any"
    teToL4 ctx (And termexprs)          = "TODO And"
    teToL4 ctx orig@(BinOp te1 bo2 te3)      = show (bo2) ++ "(" ++ teToL4' ctx orig te1 ++ " , " ++ teToL4' ctx orig te3 ++ ")"

    teToL4' ctx orig = teToL4 (ctx { stack = orig : stack ctx })

#+end_src

**** Haskell Infrastructure

#+begin_src haskell parse-341 :noweb yes :tangle src/Lib.hs
  {-# LANGUAGE PostfixOperators #-} -- https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#postfix-operators
  {-# LANGUAGE OverloadedStrings #-}
  {-# LANGUAGE ScopedTypeVariables #-}
  {-# LANGUAGE DuplicateRecordFields #-}

  module Lib where

  import Text.Megaparsec
  import Text.Megaparsec.Char
  import qualified Text.Megaparsec.Char.Lexer as L
  import Data.Text (Text, pack, unpack)
  import qualified Data.Text.IO as TIO
  import Prettyprinter hiding (space)
  import qualified Prettyprinter as PP
  import Data.Void
  import Data.List (nub, permutations, sort, sortOn, intercalate, elemIndex, intersperse)
  import Data.Char (toLower)
  import Data.Tree
  import Control.Monad (forM_)
  import qualified Data.Map.Lazy as Map
  import Text.Pretty.Simple (pPrint, pShow)
  import Options.Applicative.Simple (simpleOptions, addCommand, addSubCommands)
  import Language.Prolog
  type Parser = Parsec Void Text

  sc :: Parser ()
  sc = L.space space1 (L.skipLineComment "//") (L.skipBlockComment "/*" "*/")

  lexeme :: Parser a -> Parser a
  lexeme = L.lexeme sc

  stringLiteral = char '"' >> manyTill L.charLiteral (char '"')

  <<34-types>>
  <<34-parser>>
  <<34-prolog>>
  <<34-haskell>>
  <<34-app>>

#+end_src

** Section 2

2) Subject to paragraph (1), a legal practitioner in a Singapore law practice (called in this paragraph the main practice) may accept an executive appointment in another Singapore law practice (called in this paragraph the related practice), if the related practice is connected to the main practice in either of the following ways:
   a) every legal or beneficial owner of the related practice is the sole proprietor, or a partner or director, of the main practice;
   b) the legal practitioner accepts the executive appointment as a representative of the main practice in the related practice, and the involvement of the main practice in the related practice is not prohibited by any of the following:
      1) the Act;
      2) these Rules or any other subsidiary legislation made under the Act;
      3) any practice directions, guidance notes and rulings issued under section 71(6) of the Act;
      4) any practice directions, guidance notes and rulings (relating to professional practice, etiquette, conduct and discipline) issued by the Council or the Society.

We use a different syntactic style here, where the entire paragraph is made a single RULE; the parts are labeled.

#+begin_src sql :noweb-ref section34
  SECTION 34.2
   RULE       34.2
    SUBJECTTO 34.1
        GIVEN SingaporeLawPractice1 :en:"the main practice"    AS MainP
              SingaporeLawPractice2 :en:"the related practice" AS RelatedP
        PARTY LegalPractitioner
          MAY accept (role = ExecutiveAppointment) in SingaporeLawPractice2 AS Acceptance
         WHEN [ :label:34.2.a
                FORALL Owner2 in [ legal | beneficial ] Owner of SingaporeLawPractice2 {
                  Owner2 is [ soleProprietor | partner | director ] of SingaporeLawPractice1
                }
              | :label:34.2.b
                Acceptance as representative
                              (of SingaporeLawPractice1
                              ,in SingaporeLawPractice2)
                  -- this is not a 34.2.c because it's a OR (b1 AND b2)
                  AND NOT (Involvement (of MainP, in RelatedP)
                           prohibitedByUsualSuspects)
              ]
#+end_src         

every legal or beneficial owner of the related practice is

- the sole proprietor, or a partner or director, of the main practice;
- the sole proprietor, a partner, or a director of the main practice;

BUT NOT

- the sole proprietor, partner, or director of the main practice;
  (implies there is only one partner / director)

- the sole proprietor, a partner, or director of the main practice;
  (ungrammatical, "director" violates parallel structure)

- "is a sole proprietor, partner, or director of the main practice"

** Section 3

3) Subject to paragraph (1), a legal practitioner may accept an executive appointment in a business entity which provides law-related services.

** Section 4

** Section 5

*** Let's talk types!

There is synecdoche going on here -- 34.1.b is a predicate constraining businesses, but 34.5 casts it to a deontic deny, implicitly including the context of the introductory text of 34.1 above in the "parent".

** Section 6

* Let's also do the super simple case that we whiteboarded in January:

** The original whiteboard text:

#+begin_src text :tangle test/supersimple.l4
  Type Business (12345):
    is_operating (23456): boolean
    bus_name: string

  megaCorp : Business

  megaCorp.is_operating = true
  megaCorp.bus_name = "Mega"

  QUERY
    megaCorp.is_operating
#+end_src

** A Megaparsec parser

has been done by Jacob, see =sandbox/jacobtan/baby-l4=

A future version of that parser could construct the following AST:

** eDSL AST

For now we hand-write the semantics of the case in an AST / IR:

#+begin_src haskell :noweb-ref 34-haskell
  superSimple1 :: [Stm]
  superSimple1 =
    [ (§=§) ("Business" 🔤 12345 📭 typ)
      [ "is_operating" 🔤 23456 📭 bool
      , "bus_name" 💬 "Business Name" 📭 str
      ]
    , (§=§) ("megaCorp" 💬 "Mega Corporation" 📬 "Business")
      [ "is_operating" 📩 L4True
      , "bus_name" 📩 L4S "Mega"
      ]
    ]
#+end_src

** It pretty-prints to this:

#+begin_src haskell
[ CRule
    { item = BinOp
        ( "Business" :@
            [
                ( "wordnet"
                , "12345"
                )
            ]
        ) HasType
        ( "Type" :@
            [
                ( "en"
                , "Base Type"
                )
            ]
        )
    , body =
        [ BinOp
            ( "is_operating" :@
                [
                    ( "wordnet"
                    , "23456"
                    )
                ]
            ) HasType
            ( "Bool" :@
                [
                    ( "en"
                    , "Primitive Type Boolean"
                    )
                ]
            )
        , BinOp
            ( "bus_name" :@
                [
                    ( "en"
                    , "Business Name"
                    )
                ]
            ) HasType
            ( "String" :@
                [
                    ( "en"
                    , "Primitive Type String"
                    )
                ]
            )
        ]
    , when = Nothing
    }
, CRule
    { item = BinOp
        ( "megaCorp" :@
            [
                ( "en"
                , "Mega Corporation"
                )
            ]
        ) HasType
        ( "Business" :@
            [
                ( "en"
                , "User Defined Type"
                )
            ]
        )
    , body =
        [ BinOp
            ( "is_operating" :@
                [
                    ( "en"
                    , "is_operating"
                    )
                ]
            ) HasValue ( Prim L4True )
        , BinOp
            ( "bus_name" :@
                [
                    ( "en"
                    , "bus_name"
                    )
                ]
            ) HasValue
            ( Prim ( L4S "Mega" ) )
        ]
    , when = Nothing
    }
]

#+end_src

** Extraction to Typescript

desired output:

#+begin_src typescript :tangle test/mega.ts
  interface Business {
    is_operating : boolean;
    bus_name : string;
  }

  let megaCorp : Business = {
    is_operating: true,
    bus_name: "Mega"
  }
#+end_src

A little transpiler to Typescript:

#+begin_src haskell :noweb-ref 34-haskell
  data Target = To_TS deriving (Show, Eq)

  -- we'll use https://hackage.haskell.org/package/prettyprinter-1.7.0/docs/Prettyprinter.html
  -- interface definition
  stm2ts :: Stm -> Doc ann
  stm2ts (CRule (BinOp (te1 :@ _) HasType ("Type" :@ _)) crb crmw) =
    vsep [ nest 2 (vsep (hsep ["interface", pretty te1, lbrace]
                                  :
                                  (attrdef To_TS <$> crb)))
            , rbrace ]
  -- instance definition
  stm2ts (CRule (BinOp (te1 :@ _) HasType (te2 :@ _)) crb crmw) =
    vsep [ nest 2 (vsep (hsep ["let", pretty te1, colon, pretty te2, equals, lbrace]
                                  : -- alternatively, use encloseSep, but that does a hanging indent.
                                  (punctuate comma (attrdef To_TS <$> crb))))
            , rbrace ]

  -- attribute type definition inside interface
  attrdef :: Target -> TermExpr -> Doc ann
  attrdef To_TS (BinOp (te1 :@ _) HasType (te2 :@_)) =
    pretty te1 <+> colon <+> pretty (typecast To_TS te2) <> semi

  -- attribute value definition inside instance
  attrdef To_TS (BinOp (te1 :@ _) HasValue te2) =
    pretty te1 <+> colon <+> pretty (showTSval te2)

  -- attribute catch-all
  attrdef target y = hsep (pretty <$> [ "// attrdef unimplemented: ", show target, show y])

  showTSval (Prim L4True) = "true"
  showTSval (Prim L4False) = "false"
  showTSval (Prim (L4S str)) = "\"" ++ str ++ "\"" -- TODO: need to properly stringify by escaping internal " etc
  showTSval x = show x

  printStms To_TS stms = mapM_ (putStrLn . show . stm2ts) stms

  typecast To_TS "Bool" = "boolean"
  typecast To_TS "String" = "string"
  typecast target y = y
#+end_src

** Extraction to English

#+begin_src haskell :noweb-ref 34-haskell

#+end_src

** Extraction to Python

#+begin_src haskell :noweb-ref 34-haskell

#+end_src

** Extraction to Hyperledger Concerto

#+begin_src haskell :noweb-ref 34-haskell

#+end_src

* Language Notes

** Prepositional Style and Infix Operators

Gosh, prepositions are complicated. Here we'll try to do a sort of Rosetta Stone between representations of the same ideas in multiple languages.

https://en.wikipedia.org/wiki/List_of_English_prepositions

Let's say we follow Prolog tradition for a moment: variables are =Upper= and functions are =lower=.

Color = { red, green, blue }
val red   = "red"
val green = "green"
val blue  = "blue"

val potatoColor : Color = green

Suppose we have a simple clause that says, *if potatoColor is red, blue, or green*. Semantically, the clause is a Boolean predicate.
- Python     :: potatoColor in     [ red, blue, green ]
- Javascript :: [ red, blue, green ].indexOf(potatoColor) >= 0
- Haskell    :: potatoColor `elem` [ red, blue, green ]
- Prolog     :: member(   PotatoColor, [ red, blue, green ]).
- Prolog     :: memberchk(PotatoColor, [ red, blue, green ]).      (semidet)
- L4         :: potatoColor is     [ red, blue | green ] -- NLG produces "potatoColor is red, blue, or green"
- L4         :: potatoColor is any [ red, blue U green ] -- NLG produces "potatoColor is any of red, blue, and green"

potato.color is [red, blue | green]

potato is [yellow, cooked & salted]

What do we do about more complex phrases? Let's consider a sentence which expresses a list -- a list of things, filtered through a couple of predicates:
- English :: *any guidance notes relating to conduct issued by the Council*
- GF      ::
#+begin_src gf
(AnyDet (NounVP (mkNoun "guidance note" Pl)
                             (mkAdvP "relating" "to" (mkN "conduct"))
                             (mkAdvP "issued"   "by" (theDet (mkN "Council")))))
#+end_src
- Python  :: [ x in guidanceNotes
               if  "conduct" in x.relatingTo
               and "Council" in x.issuedBy ]
- Javascript :: guidanceNotes.filter(lambda x => ...)
- Prolog :: gnRule(GN) :- relatesTo(GN, conduct), issuedBy(GN, theCouncil).
- L4 :: (any guidanceNotes (relating TO conduct (issued BY theCouncil)))

Let's throw a couple more bits into the mix:

- English :: *any practice directions, guidance notes and rulings (relating to professional practice, etiquette, conduct and discipline) issued by the Council or the Society.*

Here we have ambiguity -- does the "relating to" constraint attach to "rulings" only, or to all of "practice directions, guidance notes and rulings"? The nice thing about a formal syntax is that it saves us from even having to ask that question.

- L4 :: wrong:
#+begin_src sql
      any [ practice_directions, guidance_notes U rulings ]
          relating to ( [ professional_practice, etiquette, conduct U discipline ]
                        issued   by [ the_Council | the_Society ] )
#+end_src

- L4 :: right:
#+begin_src sql
      any [ practice_directions, guidance_notes U rulings ]
          relating to [ professional_practice, etiquette, conduct U discipline ]
          issued   by [ the_Council | the_Society ]
#+end_src

#+begin_src haskell
  [ thing <- [ x, y, z ]
  | thing `relatingTo` [...]
  , thing `issuedBy`   [...]
  ]
#+end_src

** Right Associativity and Transitive Prepositions

Let's take an entity defined by its constraint:

- English :: Business likely to unfairly attract business in practice of law
- L4 :: business likely to unfairly_attract_business in practice of law

Here's how the right-associativity binds:

                                                   N2?
                                                   VPSlash  PrepOf Comp
                     VPSlash               PrepIn (Comp               )
          VPSlash PrepTo  (Comp                                        )
business (likely to (unfairly_attract_business in (practice of     law)))

Gosh, it looks like the prepositions here are binary infix operators:

| left                      | binary preposition | right  | bound to term |
|---------------------------+--------------------+--------+---------------|
| practice                  | of                 | law    | pol           |
| unfairly_attract_business | in                 | pol    | uabpol        |
| likely                    | to                 | uabpol | l2uabpol      |

So our algorithm looks for keyword prepositions; the stuff to the right is the complement; the word, clause, or array to the left of the preposition is the LHS.

** Prepositional Groups: when do we use commas and parentheses?

#+begin_quote
Finally, a preposition that consists of two or more words is called a complex preposition.[10] It is a matter of debate as to whether these groups of words each function as a single preposition (the complex preposition analysis) or the initial preposition simply takes a complement that contains another preposition. Traditional grammars and some dictionaries take this complex preposition approach, but grammars informed by work in linguistics vary in how they address these groups of words.
#+end_quote

Suppose we have: =Business [ detracts from , is_incompatible with | derogates from ] dignity of legal_profession=



                         
** Notes: Simplification

The compiler automatically expands, then refactors, 34.1 to simplify the expression to be readable, from

#+begin_example
step 1:
  - base = a b c(...)
  - base(1 2)
  - base(3 4)
  - base(5 6)
  - base(7 8)

step 2:
  - a b c 1 2
  - a b c 3 4
  - a b c 5 6
  - a b c 7 8

step 3:
- a b c (any [1 2, 3 4, 5 6, 7 8])
#+end_example

  
  
* Source Text

** Section 34

https://sso.agc.gov.sg/SL/LPA1966-S706-2015#pr34-

Paragraph numbering scheme is 1.a.i. Roman numerals were converted to arabic to be kinder to org-mode.

1) A legal practitioner must not accept any executive appointment associated with any of the following businesses:
   a) any business which detracts from, is incompatible with, or derogates from the dignity of, the legal profession;
   b) any business which materially interferes with —
      1) the legal practitioner’s primary occupation of practising as a lawyer;
      2) the legal practitioner’s availability to those who may seek the legal practitioner’s services as a lawyer; or
      3) the representation of the legal practitioner’s clients;
   c) any business which is likely to unfairly attract business in the practice of law;
   d) any business which involves the sharing of the legal practitioner’s fees with, or the payment of a commission to, any unauthorised person for legal work performed by the legal practitioner;
   e) any business set out in the First Schedule;
   f) any business which is prohibited by —
      1) the Act;
      2) these Rules or any other subsidiary legislation made under the Act;
      3) any practice directions, guidance notes and rulings issued under section 71(6) of the Act; or
      4) any practice directions, guidance notes and rulings (relating to professional practice, etiquette, conduct and discipline) issued by the Council or the Society.

2) Subject to paragraph (1), a legal practitioner in a Singapore law practice (called in this paragraph the main practice) may accept an executive appointment in another Singapore law practice (called in this paragraph the related practice), if the related practice is connected to the main practice in either of the following ways:
   a) every legal or beneficial owner of the related practice is the sole proprietor, or a partner or director, of the main practice;
   b) the legal practitioner accepts the executive appointment as a representative of the main practice in the related practice, and the involvement of the main practice in the related practice is not prohibited by any of the following:
      1) the Act;
      2) these Rules or any other subsidiary legislation made under the Act;
      3) any practice directions, guidance notes and rulings issued under section 71(6) of the Act;
      4) any practice directions, guidance notes and rulings (relating to professional practice, etiquette, conduct and discipline) issued by the Council or the Society.

3) Subject to paragraph (1), a legal practitioner may accept an executive appointment in a business entity which provides law-related services.

4) Subject to paragraph (1), a legal practitioner (not being a locum solicitor) may accept an executive appointment in a business entity which does not provide any legal services or law-related services, if all of the conditions set out in the Second Schedule are satisfied.

5) Despite paragraph (1)(b), but subject to paragraph (1)(a) and (c) to (f), a locum solicitor may accept an executive appointment in a business entity which does not provide any legal services or law-related services, if all of the conditions set out in the Second Schedule are satisfied.

6) Except as provided in paragraphs (2) to (5) —
   a) a legal practitioner in a Singapore law practice must not accept any executive appointment in another Singapore law practice; and
   b) a legal practitioner must not accept any executive appointment in a business entity.

7) To avoid doubt, nothing in this rule prohibits a legal practitioner from accepting any appointment in any institution set out in the Third Schedule.

8) To avoid doubt, this rule does not authorise the formation of, or regulate —
   a) any related practice referred to in paragraph (2); or
   b) any business entity referred to in paragraph (3), (4) or (5).

9) In this rule and the First to Fourth Schedules —
   - "business" :: includes any business, trade or calling in Singapore or elsewhere, whether or not for the purpose of profit, but excludes the practice of law;
   - "business entity" ::
     a) includes any company, corporation, partnership, limited liability partnership, sole proprietorship, business trust or other entity that carries on any business; but
     b) excludes any Singapore law practice, any Joint Law Venture, any Formal Law Alliance, any foreign law practice and any institution set out in the Third Schedule;
   - "executive appointment" :: means a position associated with a business, or in a business entity or Singapore law practice, which entitles the holder of the position to perform executive functions in relation to the business, business entity or Singapore law practice (as the case may be), but excludes any non‑executive director or independent director associated with the business or in the business entity;
   - "law-related service" :: means any service set out in the Fourth Schedule, being a service that may reasonably be performed in conjunction with, and that is in substance related to, the provision of any legal service.


** First Schedule

Rule 34(1)(e) and (9)

PROHIBITED BUSINESSES

1.	Housing or estate agency business

2.	Debt collection business

** Second Schedule

Rule 34(4), (5) and (9)

CONDITIONS FOR ACCEPTING EXECUTIVE APPOINTMENT IN BUSINESS ENTITY

1. The business of the business entity —
   a) must not jeopardise the professional integrity, independence or competence of the legal practitioner; and
   b) must not detract from the standing and dignity of the legal profession.

2. The business entity must not be held out or described in such a way as to suggest —
   a) that the business entity is a law practice; or
   b) that any legal practitioner in the business entity provides services, carries on business, or is employed, as a regulated legal practitioner.

3. The involvement of the legal practitioner in the business entity must not impair, and must not be in conflict with, the legal practitioner’s duties —
   a) in the law practice in which the legal practitioner practises; or
   b) to any client of that law practice.

4. The files, records and accounts of the business entity must be kept separate from and independent of the files, records and accounts of the law practice in which the legal practitioner practises.

5. Where, in the course of dealing with the law practice in which the legal practitioner practises, a client of that law practice deals with, or is referred by that law practice to, the business entity, the legal practitioner must make full and frank disclosure of all of the following matters to the client:
   a) the relationship (if any) between the business entity and each of the following:
      1) that law practice;
      2) every legal practitioner in that law practice who has any interest in the business entity;
   b) the financial or other interests of each of the following in the business entity:
      i) that law practice;
      ii) every legal practitioner in that law practice who has any interest in the business entity;
   c) that the statutory protection conferred on a client of a law practice under the Act (including but not limited to compulsory professional indemnity insurance coverage and the Compensation Fund maintained under section 75 of the Act), or under any subsidiary legislation made under the Act, may not be available to a customer of the business entity.

6. The client account of the law practice in which the legal practitioner practises, and any other account of that law practice used to hold money for a client of that law practice, must not be used to hold money for the business entity in its capacity as such, or for any customer of the business entity in the customer’s capacity as such.

7. Each account of the business entity must not be used to hold money for the law practice in which the legal practitioner practises in that law practice’s capacity as such, or for any client of that law practice in the client’s capacity as such.

8.
   1. The business entity must conduct its business at an address that is separate and distinct from the address of the law practice in which the legal practitioner practises.
   2. However —
      a) both addresses may be in the same building; and
      b) the business entity is not to be treated as conducting its business at an address by reason only that the address is the address of the registered office of the business entity.


** Third Schedule

Rule 34(7) and (9)

INSTITUTIONS IN WHICH LEGAL PRACTITIONER MAY ACCEPT ANY APPOINTMENT

1. The Society
2. The Academy
3. The Institute
4. The National University of Singapore
5. The Singapore Management University
5A. The Singapore University of Social Sciences [S 82/2018 wef 12/02/2018]
6. Any charity registered under section 5 of the Charities Act (Cap. 37)

** Fourth Schedule

Rule 34(9)

LAW-RELATED SERVICES

1. Any intellectual property service, including the registration (where applicable), and the provision of consultancy and advice on the management and enforcement, of copyright, trade marks, patents, designs, plant varieties and any other category of intellectual property referred to in the Agreement on Trade-Related Aspects of Intellectual Property Rights
2. Any tax service, including tax consultancy and advice
3. Any trust business or trust business service as defined in section 2 of the Trust Companies Act (Cap. 336)
4. Any company secretarial service, including the establishment and incorporation of a company
5. Any service as a continuing sponsor company for an entity any shares of which are listed for quotation on the Singapore Exchange Catalist
6. Any administrative, management, property or other service provided exclusively to a law practice or to a business entity referred to in rule 34(3), (4) or (5)
7. Any forensic investigation, document management or discovery service, or any other service relating to litigation support
8. Any voluntary liquidation service



