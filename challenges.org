#+TITLE: Challenge Problems, May 2024

* Background

  As part of the next-gen L4 language definition effort, we present a handful of challenge problems that exercise the proposed semantics at various levels of difficulty and composition.

* Checklist of Semantics

** boolean

** arithmetics

** state transition systems, with a bit of modal "deontics"

** multi-temporal

** looking at the history of the contract and past state

** constraint and property assertions

external to the contract

* Example Challenge 1: Booleans, Arithmetics, and simple State-Transition Deontics

1. A person may frobulate
2. if and only if
3. the person's colour attribute is red
4. and
5. the person's size attribute is greater than
   1. if the person is a rectangle, then 10 * 10
   2. if the person is a circle, then pi * 5 * 5
   3. if the person is some other shape, then 42
6. or
7. the person's electrical charge, if they have one, is positive
  
** Initial State: the person has not yet frobulated.

** After the transition: the person frobulates.

** The precondition for the transition is given in lines 3--7.

** There is an element of choice: the person MAY frobulate, and the contract can be fulfilled in two ways: they do, or don't.

The only way the contract can be BREACHED is if they fail to meet the preconditions, but frobulate anyway.

** Semantics -- Commentary

- if the person has no electrical charge, then line 7 evaluates to false
  - "the identity for OR is false"
  - person.electricalCharge 
- lines 4 and 6 are at the same level. What is the grouping precedence infixl/infixr for an unindented and/or? Jo Hsi has previously pointed out natural4 does opposite to Python. Let's fix that in this next iteration?
- the IFF on line 2 implies that we can test the contract for other "may frobulate" and detect a conflict if something else also allows frobulation, either directly or in some synthetic way.

** Example Challenge 1.B: Synthetic Frobulation

1. If a person crantulates, then that person frobulates.
2. A person may crantulate at any time.

This is a conflict with the previous (1).

The reasoning engine should infer the existence of this conflict, and warn about it.

** Example Challenge 1.C: a semantics for electrical charge

Line 7 says, "a person's X, if they have one, is Y"

What are the semantics of "if they have one"?

In Typescript we have optional types; and we might, naively, adopt the notion of "if they have one"

#+begin_src typescript
enum PosNeg { Positive, Negative }

interface Person {
  electricalCharge ?: PosNeg
}
#+end_src

That corresponds to the Haskell

#+begin_src haskell
  data ElectricalCharge2 = Positive | Negative
  data Person = Person {
    electricalCharge :: Maybe ElectricalCharge2
  }
#+end_src

Another way to model electrical charge:

#+begin_src haskell
  data ElectricalCharge3 = Positive | Neutral | Negative
#+end_src

In the second case, "if they have one" is given by ~person.electricalCharge /= Nothing~

In the first case, "if they have one" is given by ~person.electricalCharge /= Neutral~

** Temporal Bounds

The example so far is not temporally bounded. Do we infer that the permission is coextensive with the conditions? I.e. the conditions need to be tested at every time t, and then the resulting permission holds at that time t.

Or do we add a notion of deadlines:

*** (Non-Temporal) Qualification

This is a purely constitutive decision rule, without any deontics / state transitions.

1. A person qualifies
2. if and only if
3. the person's colour attribute is red
4. and
5. the person's size attribute is greater than
   1. if the person is a rectangle, then 10 * 10
   2. if the person is a circle, then pi * 5 * 5
   3. if the person is neither, then 42
6. or
7. the person's electrical charge, if they have one, is positive

*** (Temporal) Permission deontic state transitions

1. Upon qualification, a person may frobulate for 24 hours, but not thereafter.

* trivially, a pure regulative rule

EVERY person
MUST obey the law
-- IF (always!)

* Example Challenge 2: Composition of Sub-contracts Considered As State Transition Systems
Showing some of the essentials from DeonDigital's CSL:

1. The trivial "identity" contract is FULFILLED.
2. The trivial dual to the identity contract is BREACHED.
3. Nontrivial contract: C1 @( PARTY P (MUST|MAY|SHANT) DO X {..} BEFORE DEADLINE ) THEN C2 ELSE C3.
4. Contracts can be composed using AND, OR, THEN, ELSE relations.
5. Contract 1 THEN contract 2 THEN contract 3 ELSE contract 4.
6. Contract 1 AND contract 2 OR contract 3.

And that's the basic underlying semantics for regulative rules!

* Example Challenge 3: Multi-Temporal Logic

** Temporal properties of a contract stated using deontic language, aka "bounded deontics"

Suppose we have a simple contract:

- EVERY P:person MAY borrow a book from the library
- THEN:
  - P MAY
    - return the book BEFORE 1 week
    - THEN fulfilled (true)
    - ELSE breached (false)
     
- OR (if the above is true, we short circuit to fulfilled; if it is false, then we continue evaluation)
  - P MAY
    - return the book BEFORE 2 week
    - AND
    - pay $100 fine
    - THEN fulfilled
    - ELSE breached
- OR
  - P MAY
    - return the book BEFORE 4 week
    - AND
    - pay $200 fine
    - THEN fulfilled
    - ELSE breached
- OR
  - P MAY
    - keep book
    - AND
    - Library MAY charge $500 replacement cost to the credit card on file
    - THEN fulfilled
    - ELSE breached (the charge didn't go through, and so we send the lawyers to your door to recover the book)

Laypeople will analyze this contract as follows:

*** Analysis 1: "P must return the book within 1 week"
Bound: ... if the goal is that P doesn't pay a fine and doesn't end up in BREACHED.

*** Analysis 2: "If P doesn't return the book within 1 week, P must pay some kind of fine"
Bound: ... if the goal is that P doesn't end up in BREACHED state.

this is a property assertion -- the MUST is an alethic modal, not a specifically deontic modal.

*** Discussion
The "must" in the analyses is an alethic modal bounded by specific goals, not a deontic or constitutive modal!

* Example of Constitutive MUST BE vs Deontic MUST DO vs Alethic external property of the contract

Constitutive rules follow the template:
- for X to be considered Y in context Z, X MUST BE ...

Regulative rules follow the template:
- UPON some event, or ALWAYS
- Party P
- if they meet criteria ("WHO")
- if the world meets certain criteria
- deontic MAY/SHANT/MUST DO some action
- BEFORE/AFTER some deadline
- THEN C1 ELSE C2

** Rules that are both!

Framing: is ~(2+4) * (5+3)~ a "fundamentally" multiplicative or a "fundamentally" additive formula? Hmmmm.

Deontic:
1. Party P
2. MAY do X
3. IF and only IF
4. P qualifies

Constitutive:
1. P qualifies
2. IF and only IF
3. P previously did Y

From this we infer:
1. P MAY Y
2. THEN
3. P MAY X

Or:
1. To (be able to) do X, P MUST (have done) Y

And then the "to be able to" gets dropped out of the explicit stateement, because it moves into the implicit goal bound!
1. P MUST Y
Bound: goal = P MAY X

which looks like two purely regulative rules chained together; the constitutive has been compiled out.

But it could be analyzed slightly differently:

1. do Y, P MUST BE qualified
2. to be qualified, P MUST HAVE done X

All of these readings are semantically equivalent!

* Example Challenge 4: Rule Against Perpetuities

We have dealt with this in the past, let's dig up the old write-up.

But basically it can be in a state of indeterminacy until some event happens which resolves the conditions one way or another and then the rule operates.

See also: conveyanc.es

If anyone is 21 or older at any time in the previous tax year, etc

moving point of reference around

* Example Challenge 5: Charlotte's Trust Fund

Netflix: "The Gentlemen" S01E01

- “To my daughter, Charlotte,
- I leave the Endurance [some kind of boat],
- with the condition that she sail around the world on her
- in the next six months.”
- ("Well done, Chuckles.")
- “As well, a trust fund of £1,000 a week
- until she marries
- a man.”

* The Insurance Challenge 6: Calculating Claim Coverage

Even the non-regulative decision logic deals with Boolean and Numeric-valued expressions

DECIDE the Payout  :: Number
IS     SUM    NumA :: Number
              NumB :: Number
              NumC :: Number
IF     PayoutRuleApplies
              
WHERE  DECIDE  NumA :: Number
           IS  IF    ConditionA
               THEN  ...
               ELSE  0

       DECIDE  ConditionA :: Boolean
           IS  True   WHEN  X < Y
               False  WHEN  X > Y
               False  OTHERWISE

       DECIDE  ConditionB :: Boolean
           IS  ANY/OR  [ Bob is over 21 years old
                       , Bob is under 7 years old
                       ]

       DECIDE  PayoutRuleApplies  IF  TheRegulatorSaysPayoutRuleApplies
       
  What if the PayoutRuleApplies == False? There is some kind of Default/Maybe monad so that numbers default to identity 0.
  
** Sarah Lawsky's Default Rules

#+begin_example
Section 1337(a): You can cite as a schmdudction (this is a term of art) whatever interest you paid within the tax year on your debts.
[nothing else in Section 1337(a).]
[...other sections…]
Section 1337(f): 
i)  If you are not a corporation, you cannot invoke as a schmdudction any personal interest paid or accrued during the tax year.
(ii) For purposes of this subsection, the term “personal interest” means any interest allowable as a schmdeduction under this chapter other than [...] any raxified moodrigible interest [nonsensical term of art to make cheating harder]
#+end_example

#+begin_src haskell
  data Interest = Personal | NonPersonal
  data Person   = Natural | Corporation
  data TaxYear

  canCite :: Person -> Interest -> TaxYear -> Boolean
  canCite p i _
    | p /= Corporation && i /= Personal  = False
    | otherwise                          = True
  canCite _ _ _ = True

#+end_src

Language rule: subsequent things override earlier things

(a)   DECIDE  canCite  IS  True IF | always | == 0

...

(f)   DESPITE (a)  DECIDE  canCite IS False IF | Corporation ... Personal ...  | == 2

The Dev-facing IDE could search for un-ordered pairs of rules that define the same terms ("canCite") and ask the developer for explicit ordering.

We can apply Lex Specialis and Posterior Derogat to assume ordering, and then we have to figure out how the two doctrines fight.

We can do this in an "adversarial" elicitation dialogue, where we use a backend to come up with concrete examples that have ambiguous evaluations, and we ask the user to choose which is "correct" / "desirable" / "prioritized".


** Support for TYPICALLY

Boolean terms can be annotated with a TYPICALLY default value.

A program can be evaluated with those values set to defaults, or explicitly overridden by the user.

That's enough to support default and defeasible logic.

X is a Penguin (TYPICALLY false).
X is a bird (TYPICALLY true.)

Birds can fly unless they are penguins.

Can X fly?

given: { X is a bird } ==> X flies. Because we are using the assumption X is not a penguin.

given: { X is a bird, X is a penguin } ==> X does not fly.





* Challenge 7: insurance renewals

** the regulative style:

 PARTY  Customer
   MAY  make claim
WITHIN  1 YEAR OF last renewal

  THEN  PARTY   Customer
          MAY   renew insurance
        WITHIN  1 YEAR of last renewal
         THEN   residuum

   ELSE  PARTY  Customer
           MAY  renew insurance
        WITHIN  1 YEAR of last renewal
          THEN  bonus := bonus + 5% -- THIS IS THE DIFFERENT BIT
           AND  residuum

** the constitutive style:
      
DECIDE bonus = 5% * numberOfRenewalsWithoutClaim

** Trace-based evaluation:

The "event sourcing" paradigm:

- EVENT yyyy-mm-dd RENEWAL occurred
- EVENT yyyy-mm-dd CLAIM   occurred
- EVENT yyyy-mm-dd RENEWAL occurred
- EVENT yyyy-mm-dd RENEWAL occurred

* Challenge 8: type inference!

what if we don't have explicit type annotations, the system has to figure it out.

From challenge (1) above, we can infer the following data and world model:
- *frobulate* is an action that a person can take -- in an OOP rendering, the Person class has a ~frobulate()~ method
- Person has a *colour* attribute
- Person's *colour* attribute can take *red* as a value, and presumably others
- Person has a *size* attribute
- Person's *size* attribute is numeric
- Person can be the subject of a shape predicate
- the shape predicate takes an input of ~rectangle | circle | _~ -- in Prolog it would be something like
  - ~isRectangle(Person)~
  - ~isCircle(Person)~
  - ~isOtherShape(Person)~
- alternatively, we could restyle to
  - ~isShape(Person, rectangle) :- ...~
  - ~isShape(Person, circle) :- ...~
  - ~isShape(Person, _).~
- Person has an *electrical charge* attribute which could be *positive*; alternatively, they could /not/ have *electrical charge* attribute, see discussion above.

Oh, and:

* Challenge 9: type checking

give actual type errors lolol

* A model of causation

we need to figure out what PURSUANT TO means, or DUE TO, or BY WAY OF

wonder what GPT thinks about those idioms

* Challenge 10: planning problems

When is the earliest possible time that ... event X could occur?

* Challenge 11: abduction problems

What sets of conditions/circumstances would be necessary for X to arise in future?

* Challenge 12: idioms for message-passing

in the actor model, message-passing is the key operation.

we borrow Epistemic Modals:

"Party X may obtain from Party Y certain information I"

unpacks to

PARTY  X
  MAY  notify  PARTY  Y
         with  demand for  information I
 THEN  PARTY  Y
        MUST  notify  PARTY  X
                with  information I
 ELSE  fulfilled

* ACTION ITEMS

** TODO Turn these examples into actual tab in spreadsheet that compiles



