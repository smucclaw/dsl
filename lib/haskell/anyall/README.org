#+TITLE: Yet Another AnyAll Library

The And/Or Tree is a classic data structure in CS.

Our implementation equips it with
- a visualization engine (SVG)
- a natural language target producing traditional conjunctive and disjunctive lists
- a relevance calculus that paints elements of the tree for use in a user interface

#+begin_quote
If, when, why, what?
How much have you got?
Have you got it, do you get it, if so, how often?
And which do you choose, a hard or soft option?
-- C. Lowe & N. Tennant, 1985
#+end_quote

* Usage (CLI)

Compile the typescript to javascript (you may need to ~npm i -g typescript~):
#+begin_src bash
  tsc ts/*.ts
#+end_src

Run the javascript to produce JSON:
#+begin_src bash
  node ts/example.js
#+end_src

Let's output to the ~out/~ directory:
#+begin_src bash
  mkdir -p out
#+end_src

Feed the JSON into the Haskell executable:

#+begin_src bash
  node ts/example.js | stack run -- --only svg | tee out/example.svg
#+end_src

Now you can view the SVG:

#+begin_src bash
  open -a 'Google Chrome' out/example.svg
#+end_src

* Usage (Library)

Suppose you want to be able to ~import AnyAll as AA~

In ~package.yaml~ say ~dependencies: - anyall~

** Local
If you're using this within the ~dsl~ repo, say within ~dsl/lib/haskell/natural4~,

In ~stack.yaml~ under ~extra-deps:~ say

#+begin_src yaml
  - ../anyall
#+end_src

** Remote
If you're using this outside the ~dsl~ repo,

In ~stack.yaml~ under ~extra-deps:~ say

#+begin_src yaml
  - github: smucclaw/dsl
    commit: 10ed7be2775740badcb87a389d6acd578155d53d
    subdirs:
    - lib/haskell/anyall
#+end_src

(The commit hash will need to update to whatever commit you're up to in main.)

** Usage

For an example of this API at work, see https://github.com/smucclaw/dsl/blob/main/lib/haskell/natural4/src/LS/XPile/SVG.hs#L23-L32

The main API to drawing SVGs with AnyAll looks like this:

1. set up your BoolStruct Text (by calling, perhaps, the Interpreter's ~qaHornsT~)
2. set up your Marking Text (by calling, perhaps, the Interpreter's ~getMarkings~)
3. choose a hard or soft option -- that is to say, do we take the ~Left~ defaults into consideration when evaluating the markings?
4. call ~AnyAll.PP.hardnormal~ or ~AnyAll.PP.softnormal~ to set up a QTree
5. call ~makeSvg~ against the QTree, with some ~cscale~ set to ~Tiny~ or to ~Full~

You now have an SVGElement which is Showable. Dump it to disk and do with it what you will.

* CLI Documentation

** Input example:

#+begin_src typescript :tangle ts/example.ts
  import StdinSchema from "./types"

  let mustSing : StdinSchema = {
    marking: {
      "walk": { byDefault: true },
    },
    andOrTree: {
      nodetype: "all",
      pre: "all of",
      children: [
        { leaf: "walk" },
        { leaf: "run" },
        { nodetype: "any"
        , pre: "either"
        , children: [ { leaf: "eat" }, { leaf: "drink" } ]
        }
      ]
    }
  }

  console.log(JSON.stringify(mustSing));
#+end_src

** Input schema:

#+begin_src typescript :tangle ts/types.ts

     interface withDefault<T> {
       byDefault?: T,
       fromUser?: T
     }
     export default interface StdinSchema {
       marking: {
         [nodeLabel: `${string}`]: withDefault<boolean>;
       },
       andOrTree: LeafNode | AnyNode | AllNode
     }
     export class LeafNode {
       leaf: string
     }
     abstract class SubTree {
       children: (LeafNode | AnyNode | AllNode)[];
       pre: string;
       prepost?: string
     }
     export class AnyNode extends SubTree { nodetype: "any" }
     export class AllNode extends SubTree { nodetype: "all" }
#+end_src

** Output example:

The CLI produces two chunks of JSON output:

*** The "For UI" output JSON

... contains a simplified instruction to the UI for which elements to ~ask~ for, which elements to ~view~, and what values to represent. Left means our own default; Right means user input.

#+begin_src javascript
  {
    "ask": {
      "drink": {
        "getDefault": {
          "Left": null
        }
      },
      "eat": {
        "getDefault": {
          "Left": null
        }
      },
      "run": {
        "getDefault": {
          "Left": null
        }
      },
      "walk": {
        "getDefault": {
          "Left": true
        }
      }
    },
    "view": {}
  }
#+end_src

A UI might proceed as follows:
1. flatten this to a list of pane components
2. order "view" elements as a group above "ask" elements as a group
3. further order within the groups according to their placement in the and/or tree
4. place the active cursor on the head of "ask"
5. center the screen (perhaps with a tasteful animation) on the active cursor

Alternatively, the UI might closely follow the ordering from the And/Or structure, and show/hide/ask each element, without reordering.

*** The more detailed JSON output is enough to construct an entire interview:

This syntax follows the ~Data.Tree~ format, so the node details are in an object followed by an array of children.

#+begin_src javascript
  [
    {
      "shouldView": "View",
      "andOr": {
        "tag": "And"
      },
      "prePost": {
        "tag": "Pre",
        "contents": "all of"
      },
      "mark": {
        "getDefault": {
          "Left": null
        }
      }
    },
    [
      [
        {
          "shouldView": "Ask",
          "andOr": {
            "tag": "Simply",
            "contents": "walk"
          },
          "prePost": null,
          "mark": {
            "getDefault": {
              "Left": true
            }
          }
        },
        []
      ],
      [
        {
          "shouldView": "Ask",
          "andOr": {
            "tag": "Simply",
            "contents": "run"
          },
          "prePost": null,
          "mark": {
            "getDefault": {
              "Left": null
            }
          }
        },
        []
      ],
      [
        {
          "shouldView": "View",
          "andOr": {
            "tag": "Or"
          },
          "prePost": {
            "tag": "Pre",
            "contents": "either"
          },
          "mark": {
            "getDefault": {
              "Left": null
            }
          }
        },
        [
          [
            {
              "shouldView": "Ask",
              "andOr": {
                "tag": "Simply",
                "contents": "eat"
              },
              "prePost": null,
              "mark": {
                "getDefault": {
                  "Left": null
                }
              }
            },
            []
          ],
          [
            {
              "shouldView": "Ask",
              "andOr": {
                "tag": "Simply",
                "contents": "drink"
              },
              "prePost": null,
              "mark": {
                "getDefault": {
                  "Left": null
                }
              }
            },
            []
          ]
        ]
      ]
    ]
  ]
#+end_src

* Relevance Calculus

Given a tree, we ~evaluate~ its tentative value.

This happens under some evaluation strategy, either Hard (relying on human input only) or Soft (using defaults as well).

Certain children are dispositive if they determine the value of the parent. In other words, if we short-circuit evaluation, /why/ did we short-circuit it? We can label each child as dispositive or not.

| evaluation strategy | Item | Item Predicate   | E B | B | value      | dispositive children   |
|---------------------+------+------------------+-----+---+------------+------------------------|
| Soft                | Leaf | Left Just True   | T . | T | Just True  | -                      |
| Soft                | Leaf | Left Just False  | F . | F | Just False | -                      |
| Soft                | Leaf | Left Nothing     | 0 . | 0 | Nothing    | -                      |
| Soft                | Leaf | Right Just True  | . T | T | Just True  | -                      |
| Soft                | Leaf | Right Just False | . F | F | Just False | -                      |
| Soft                | Leaf | Right Nothing    | . 0 | 0 | Nothing    | -                      |
| Hard                | Leaf | Left Just True   | T . | 0 | Nothing    | -                      |
| Hard                | Leaf | Left Just False  | F . | 0 | Nothing    | -                      |
| Hard                | Leaf | Left Nothing     | 0 . | 0 | Nothing    | -                      |
| Hard                | Leaf | Right Just True  | . T | T | Just True  | -                      |
| Hard                | Leaf | Right Just False | . F | F | Just False | -                      |
| Hard                | Leaf | Right Nothing    | . 0 | 0 | Nothing    | -                      |
| -                   | Any  | any Just True    | .T. | T | Just True  | filter =True children  |
| -                   | Any  | all Just False   | FFF | F | Just False | filter =False children |
| -                   | Any  | -                | FT. | 0 | Nothing    | -                      |
| -                   | All  | any Just False   | .F. | F | Just False | filter =False children |
| -                   | All  | all Just True    | TTT | T | Just True  | filter =True children  |
| -                   | All  | -                | FT. | 0 | Nothing    | -                      |

So, how does this affect what we display?

Each Leaf item has a "first approximation" preference for ~ShouldView~ (~View|Hide|Ask~).

That preference gets overridden by the parent because the parent knows more about the context. For example, if a parent node is hidden, then every subtree could be hidden too.

Each child may be a Leaf or itself a subtree of Any/All. We evaluate the child value and mark its 'a' with the appropriate ShouldView.

Along the way we convert it from our native notation ~Item a~ to a more conventional ~Data.Tree~ format.

The display style may be one of the following:
- terse :: we hide as much as we can. This minimizes cognitive complexity.
- normal :: we always show every piece of explicit user input, even if it was obsoleted by some other input. This means we may need to show parts of the trees along the way as needed to show those elements.
- verbose :: we always show everything.

| Item | Hard Value | ChildValue | set ShouldView to | Comment                                                        | Comment 2                  |
|------+------------+------------+-------------------+----------------------------------------------------------------+----------------------------|
| Leaf | Left       | -          | Ask               | first approximation: if I'm still a Left default, why not ask? |                            |
| Leaf | Right      | -          | View              | if I've been configured by a human, show what they set.        |                            |
| Any  | T          | T          | View              | dispositive, so show                                           |                            |
| Any  | T          | -          | Hide              | no longer relevant                                             |                            |
| Any  | F          | F          | View              | user input, so show                                            |                            |
| Any  | F          | -          | Hide              |                                                                | this case should not occur |
| Any  | 0          | . _        | View              | they selected something, so show it                            |                            |
| Any  | 0          | -          | Ask               | not yet decided, so let them choose                            |                            |
| All  | T          | T          | View              | dispositive, so show                                           |                            |
| All  | T          | F          | View              |                                                                | this case should not occur |
| All  | F          | F          | View              | dispositive, so show                                           |                            |
| All  | F          | -          | Hide              |                                                                | this case should not occur |
| All  | 0          | . _        | View              | they selected something, so show it                            |                            |
| All  | 0          | -          | Ask               | not yet decided, so let them choose                            |                            |

in terms of display UI, View and Ask are both shown, and are editable, but "ask" keeps it in the active area, while "view" scrolls it off the top of the screen.

* Consumers of this library

See:
- https://github.com/smucclaw/sandbox/blob/default/jacobtan/Rule34-logic-gates/rule34-haskell/src/SandboxBuilder.hs#L8

* TODO Things we are gradually getting smart enough to do

** use Trees That Grow

https://www.microsoft.com/en-us/research/uploads/prod/2016/11/trees-that-grow.pdf


** switch to a DAG syntax

a given node may supply more than one decision, so after the upgrade to Data.Tree we should probably continue to upgrade toward ~fgl~.

We kind of have the beginnings of this because we keep Leaf-node values separate from the ~AnyAll Item~ input in a ~Marking~ map; so we don't need to go to ~fgl~ just yet.


* Toolchain Context

This code is most frequently run as part of the Legal Spreadsheets sidebar.

See https://docs.google.com/spreadsheets/d/1leBCZhgDsn-Abg2H_OINGGv-8Gpf9mzuX1RR56v0Sss/edit?pli=1#gid=1779650637

This is happening under smucclaw/dsl/lib/haskell/natural4/

The toolchain, in brief, looks like this:
- spreadsheet sidebar
- gsheet/Code.gs onEdit()
- gsheet/pyrest/hello.py
- natural4-exe
- workdir/..../aasvg/
- pyrest/hello.py
- gsheet/Code.gs

* SVGLadder Visualization Notes

In the year 2022, in a world where Edward Tufte has published five hefty books, what good options do we have for visualization of one of the most basic data structures in computer science?

Surprisingly few that I know of.

Initially we visualized the and/or tree like this:

[[./out/Screenshot 2022-05-03 at 1.42.26 PM.png]]

After re-reading [[https://drive.google.com/file/d/1FXHyxDhjQJ5plDC_a7yCPUrxIu8EBhYp/view?usp=sharing][Layman Allen]] and considering circuit diagrams, particularly the [[https://en.wikipedia.org/wiki/Ladder_logic][ladder logic used in PLC controllers]], we tried a new design.

** See Also Documentation Diagrams elsewhere

See the PDFs under https://drive.google.com/drive/folders/1y7TssfA925VuyuAt8VBaNxlRTo8KyqlS

** Principles

*** Orientation

Elements on the canvas can be laid out left-to-right (LR), top-to-bottom (TB), or a combination of both, whatever is most appropriate given the immediate context.

*** Unfilled Elements

An AnyAll Item is represented as a 2d box, typically connected to the rest of the diagram with a pair of lines.

If the user has not given a truth value to the proposition, it is in an "unknown" state -- ~Left Nothing :: Either (Maybe Bool) (Maybe Bool)~.

Typographically, we represent unknown values as white text on gray background. The ASCII art below doesn't show it, but the PNG examples elsewhere do.

**** Leaf nodes are simple.

LR:
#+begin_example
  ---- proposition 1 ----
#+end_example

TB:
#+begin_example
        |
  proposition 2
        |
#+end_example

**** Disjunction

In an "or" tree, a proposition is true if ~any~ of its sub-propositions is true.

LR:
#+begin_example
     any of the following 
  ----- proposition 3 -------
    |                   |
    +-- proposition 4 --+
    |                   |
    +-- proposition 5 --+
#+end_example

TB:
#+begin_example
   |
   |   if there has been any unauthorized
   +--------+------------------+------------------+
            |                  |                  |
       disclosure,        announcement,  or  publication
            |                  |                  |
   |--------+------------------+------------------+
   |   of the confidential information
   |
#+end_example

**** Conjunction

In an "and" tree, a proposition is true if ~all~ of its sub-propositions are true.

LR:
#+begin_example
      all of the following
  ----- proposition 6
             |
        proposition 7
             |
        proposition 8 -----
      
#+end_example

TB:
#+begin_example
   |
   |   there must be
   |
   +---  offer, ----- acceptance, ----- capacity, ----- and consideration -----+
                                                                               |
      for the contract to be valid                                             |
                                                                               |
   +---------------------------------------------------------------------------+
   |
   |
#+end_example

**** One can apply a "NOT" to the node

Suppose the legal logic says: "If ... you are not a public agency ... then ..."

The question is encoded as ~Not (Leaf "you are a public agency")~ to allow a more natural interview with the end-user.

We draw a solid line at the end of the box to indicate the NOT.

LR:
#+begin_example
                               |
  ---- you are a public agency |----
                               |
#+end_example

TB:
#+begin_example
        |
  proposition 10
  --------------
        |
#+end_example

If the user answers "yes" to the question the overall value becomes "no", and vice-versa: see below diagrams.

*** Known states where user has given input

User input allows us to mark a box with a known value -- ~Just True~ or ~Just False~.

To be precise, ~Right (Just True/False) :: Either (Maybe Bool) (Maybe Bool)~

The marking represents "closing the circuit":

**** Suppose we know that something is true.

We mark it by drawing a line to connect the start and ends of the box, and we change the colour to black text on white bg.

LR:
#+begin_example
   +----------------+
   |                |
---+ proposition 11 +---

#+end_example


TB:
#+begin_example
            |
   +--------+
   |   proposition 1
   +--------+
            |
#+end_example

The intuition: if you can trace the line without lifting the pen from the paper, your conditions hold true.

**** Suppose we know that something is false.

We indicate that something is false by drawing a line at the start of the box:

LR:
#+begin_example
      |               
  ----| proposition 1 ----
      |               
#+end_example

Intuitively, this represents that the circuit "stops here".

**** A double negative is true!

If there's already a line at the end, drawing a line at the start makes it possible to connect:

LR:
#+begin_example
      +---------------+
      |               |
  ----| proposition 1 |----
      |               |
#+end_example

TB:
#+begin_example
            |
   +--------+---------
   |   proposition 1
   +--------+---------
            |
#+end_example


*** Unknown states where there is a "typical" default

When user input has not been received, but we know that most answers will be "yes", we leave the colour as white on grey but we connect the lines as though the user had given input.

We model this as ~Left (Just True/False) :: Either (Maybe Bool) (Maybe Bool)~

*** Bounding Box

Every Item has a bounding box. This includes nested items! We deal with nesting using the ~g~ element to group, and ~with move~ to relocate relative to the parent.

*** Alignment Guidance

How does one center-align a column of text boxes?

In SVG we can use the ~alignment-baseline~ attribute which makes things easier.


