#+TITLE: Yet Another AnyAll Library

The And/Or Tree is a classic data structure in CS.

Our implementation equips it with
- a visualization engine (SVG)
- a natural language target producing traditional conjunctive and disjunctive lists
- a relevance calculus that paints elements of the tree for use in a user interface

#+begin_quote
If, when, why, what?
How much have you got?
Have you got it, do you get it, if so, how often?
And which do you choose, a hard or soft option?
-- C. Lowe & N. Tennant, 1985
#+end_quote

* Usage (CLI)

Compile the typescript to javascript (you may need to ~npm i -g typescript~):
#+begin_src bash
  tsc ts/*.ts
#+end_src

Run the javascript to produce JSON:
#+begin_src bash
  node ts/example.js
#+end_src

Let's output to the ~out/~ directory:
#+begin_src bash
  mkdir -p out
#+end_src

Feed the JSON into the Haskell executable:

#+begin_src bash
  node ts/example.js | stack run -- --only svg | tee out/example.svg
#+end_src

Now you can view the SVG:

#+begin_src bash
  open -a 'Google Chrome' out/example.svg
#+end_src

* Usage (Library)

In ~package.yaml~ say ~dependencies: - anyall~

In ~stack.yaml~ under ~extra-deps:~ say

#+begin_src yaml
  - github: smucclaw/dsl
    commit: d561043fed8abfd8333318af5882713b6da13c6b
    subdirs:
    - lib/haskell/anyall
  - svg-builder-0.1.1
#+end_src

Then in your code you can ~import AnyAll as AA~

* CLI Documentation

** Input example:

#+begin_src typescript :tangle ts/example.ts
  import StdinSchema from "./types"

  let mustSing : StdinSchema = {
    marking: {
      "walk": { byDefault: true },
    },
    andOrTree: {
      nodetype: "all",
      pre: "all of",
      children: [
        { leaf: "walk" },
        { leaf: "run" },
        { nodetype: "any"
        , pre: "either"
        , children: [ { leaf: "eat" }, { leaf: "drink" } ]
        }
      ]
    }
  }

  console.log(JSON.stringify(mustSing));
#+end_src

** Input schema:

#+begin_src typescript :tangle ts/types.ts

     interface withDefault<T> {
       byDefault?: T,
       fromUser?: T
     }
     export default interface StdinSchema {
       marking: {
         [nodeLabel: `${string}`]: withDefault<boolean>;
       },
       andOrTree: LeafNode | AnyNode | AllNode
     }
     export class LeafNode {
       leaf: string
     }
     abstract class SubTree {
       children: (LeafNode | AnyNode | AllNode)[];
       pre: string;
       prepost?: string
     }
     export class AnyNode extends SubTree { nodetype: "any" }
     export class AllNode extends SubTree { nodetype: "all" }
#+end_src

** Output example:

The CLI produces two chunks of JSON output:

*** The "For UI" output JSON

... contains a simplified instruction to the UI for which elements to ~ask~ for, which elements to ~view~, and what values to represent. Left means our own default; Right means user input.

#+begin_src javascript
  {
    "ask": {
      "drink": {
        "getDefault": {
          "Left": null
        }
      },
      "eat": {
        "getDefault": {
          "Left": null
        }
      },
      "run": {
        "getDefault": {
          "Left": null
        }
      },
      "walk": {
        "getDefault": {
          "Left": true
        }
      }
    },
    "view": {}
  }
#+end_src

A UI might proceed as follows:
1. flatten this to a list of pane components
2. order "view" elements as a group above "ask" elements as a group
3. further order within the groups according to their placement in the and/or tree
4. place the active cursor on the head of "ask"
5. center the screen (perhaps with a tasteful animation) on the active cursor

Alternatively, the UI might closely follow the ordering from the And/Or structure, and show/hide/ask each element, without reordering.

*** The more detailed JSON output is enough to construct an entire interview:

This syntax follows the ~Data.Tree~ format, so the node details are in an object followed by an array of children.

#+begin_src javascript
  [
    {
      "shouldView": "View",
      "andOr": {
        "tag": "And"
      },
      "prePost": {
        "tag": "Pre",
        "contents": "all of"
      },
      "mark": {
        "getDefault": {
          "Left": null
        }
      }
    },
    [
      [
        {
          "shouldView": "Ask",
          "andOr": {
            "tag": "Simply",
            "contents": "walk"
          },
          "prePost": null,
          "mark": {
            "getDefault": {
              "Left": true
            }
          }
        },
        []
      ],
      [
        {
          "shouldView": "Ask",
          "andOr": {
            "tag": "Simply",
            "contents": "run"
          },
          "prePost": null,
          "mark": {
            "getDefault": {
              "Left": null
            }
          }
        },
        []
      ],
      [
        {
          "shouldView": "View",
          "andOr": {
            "tag": "Or"
          },
          "prePost": {
            "tag": "Pre",
            "contents": "either"
          },
          "mark": {
            "getDefault": {
              "Left": null
            }
          }
        },
        [
          [
            {
              "shouldView": "Ask",
              "andOr": {
                "tag": "Simply",
                "contents": "eat"
              },
              "prePost": null,
              "mark": {
                "getDefault": {
                  "Left": null
                }
              }
            },
            []
          ],
          [
            {
              "shouldView": "Ask",
              "andOr": {
                "tag": "Simply",
                "contents": "drink"
              },
              "prePost": null,
              "mark": {
                "getDefault": {
                  "Left": null
                }
              }
            },
            []
          ]
        ]
      ]
    ]
  ]
#+end_src

* Relevance Calculus

Given a tree, we ~evaluate~ its tentative value.

This happens under some evaluation strategy, either Hard (relying on human input only) or Soft (using defaults as well).

Certain children are dispositive if they determine the value of the parent. In other words, if we short-circuit evaluation, /why/ did we short-circuit it? We can label each child as dispositive or not.

| evaluation strategy | Item | Item Predicate   | E B | B | value      | dispositive children   |
|---------------------+------+------------------+-----+---+------------+------------------------|
| Soft                | Leaf | Left Just True   | T . | T | Just True  | -                      |
| Soft                | Leaf | Left Just False  | F . | F | Just False | -                      |
| Soft                | Leaf | Left Nothing     | 0 . | 0 | Nothing    | -                      |
| Soft                | Leaf | Right Just True  | . T | T | Just True  | -                      |
| Soft                | Leaf | Right Just False | . F | F | Just False | -                      |
| Soft                | Leaf | Right Nothing    | . 0 | 0 | Nothing    | -                      |
| Hard                | Leaf | Left Just True   | T . | 0 | Nothing    | -                      |
| Hard                | Leaf | Left Just False  | F . | 0 | Nothing    | -                      |
| Hard                | Leaf | Left Nothing     | 0 . | 0 | Nothing    | -                      |
| Hard                | Leaf | Right Just True  | . T | T | Just True  | -                      |
| Hard                | Leaf | Right Just False | . F | F | Just False | -                      |
| Hard                | Leaf | Right Nothing    | . 0 | 0 | Nothing    | -                      |
| -                   | Any  | any Just True    | .T. | T | Just True  | filter =True children  |
| -                   | Any  | all Just False   | FFF | F | Just False | filter =False children |
| -                   | Any  | -                | FT. | 0 | Nothing    | -                      |
| -                   | All  | any Just False   | .F. | F | Just False | filter =False children |
| -                   | All  | all Just True    | TTT | T | Just True  | filter =True children  |
| -                   | All  | -                | FT. | 0 | Nothing    | -                      |

So, how does this affect what we display?

Each Leaf item has a "first approximation" preference for ~ShouldView~ (~View|Hide|Ask~).

That preference gets overridden by the parent because the parent knows more about the context. For example, if a parent node is hidden, then every subtree could be hidden too.

Each child may be a Leaf or itself a subtree of Any/All. We evaluate the child value and mark its 'a' with the appropriate ShouldView.

Along the way we convert it from our native notation ~Item a~ to a more conventional ~Data.Tree~ format.

The display style may be one of the following:
- terse :: we hide as much as we can. This minimizes cognitive complexity.
- normal :: we always show every piece of explicit user input, even if it was obsoleted by some other input. This means we may need to show parts of the trees along the way as needed to show those elements.
- verbose :: we always show everything.

| Item | Hard Value | ChildValue | set ShouldView to | Comment                                                        | Comment 2                  |
|------+------------+------------+-------------------+----------------------------------------------------------------+----------------------------|
| Leaf | Left       | -          | Ask               | first approximation: if I'm still a Left default, why not ask? |                            |
| Leaf | Right      | -          | View              | if I've been configured by a human, show what they set.        |                            |
| Any  | T          | T          | View              | dispositive, so show                                           |                            |
| Any  | T          | -          | Hide              | no longer relevant                                             |                            |
| Any  | F          | F          | View              | user input, so show                                            |                            |
| Any  | F          | -          | Hide              |                                                                | this case should not occur |
| Any  | 0          | . _        | View              | they selected something, so show it                            |                            |
| Any  | 0          | -          | Ask               | not yet decided, so let them choose                            |                            |
| All  | T          | T          | View              | dispositive, so show                                           |                            |
| All  | T          | F          | View              |                                                                | this case should not occur |
| All  | F          | F          | View              | dispositive, so show                                           |                            |
| All  | F          | -          | Hide              |                                                                | this case should not occur |
| All  | 0          | . _        | View              | they selected something, so show it                            |                            |
| All  | 0          | -          | Ask               | not yet decided, so let them choose                            |                            |

in terms of display UI, View and Ask are both shown, and are editable, but "ask" keeps it in the active area, while "view" scrolls it off the top of the screen.

* Consumers of this library

See:
- https://github.com/smucclaw/sandbox/blob/default/jacobtan/Rule34-logic-gates/rule34-haskell/src/SandboxBuilder.hs#L8

* TODO Things we are gradually getting smart enough to do

** use Trees That Grow

https://www.microsoft.com/en-us/research/uploads/prod/2016/11/trees-that-grow.pdf


** switch to a DAG syntax

a given node may supply more than one decision, so after the upgrade to Data.Tree we should probably continue to upgrade toward ~fgl~.

We kind of have the beginnings of this because we keep Leaf-node values separate from the ~AnyAll Item~ input in a ~Marking~ map; so we don't need to go to ~fgl~ just yet.


** get input from a spreadsheet

See https://docs.google.com/spreadsheets/d/1qMGwFhgPYLm-bmoN2es2orGkTaTN382pG2z3RjZ_s-4/edit#gid=1043543357

This is happening under smucclaw/sandbox/mengwong/mp/ and will be upgraded to a library in this repo when it is done.
