-- File generated by the BNF Converter (bnfc 2.9.5).

-- | Program to test parser.
module Main where

import Control.Monad (forM_, when)
import Data.Function ((&))
import Data.HashMap.Strict qualified as HM
import Data.List (uncons)
import Data.Text.Lazy qualified as Text
import Explainable
import Explainable.MathLang
import Explainable.MathLang qualified as Expl
import LS.Rule (Interpreted (origrules), defaultL4I)
import LS.XPile.MathLang.GenericMathLang.ToGenericMathLang
import LS.XPile.MathLang.MathLang qualified as GML
import System.Environment (getArgs)
import System.Exit (exitFailure)
import Text.Pretty.Simple (pShowNoColor)
import TextuaL4.AbsTextuaL qualified as TL4
import TextuaL4.LexTextuaL (Token, mkPosToken)
import TextuaL4.ParTextuaL (myLexer, pRule)
import TextuaL4.Transform

type Err = Either String
type ParseFun a = [Token] -> Err a
type Verbosity = Int

putStrV :: Verbosity -> String -> IO ()
putStrV v s = when (v > 1) $ putStrLn s

run :: Verbosity -> ParseFun TL4.Rule -> String -> IO ()
run v p s =
  case p ts of
    Left err -> do
      putStrLn "\nParse              Failed...\n"
      putStrV v "Tokens:"
      mapM_ (putStrV v . showPosToken . mkPosToken) ts
      putStrLn err
      exitFailure
    Right tree -> do
      putStrLn "\nParse Successful!"
      showTree v tree
      putStrLn "\n\n[Transformed into L4 tree]\n"
      let l4tree = transRule tree
      putStrLn $ Text.unpack $ pShowNoColor l4tree


      when (v >= 3) $ do
        let
          stuff = toMathLangGen $ defaultL4I{origrules = [l4tree]}
          (stuff2, st0) = GML.toMathLang $ defaultL4I{origrules = [l4tree]}
          st =
            st0
              { symtabF =
                  symtabF st0
                    & HM.insert "green" (Expl.Val Nothing 1.0)
                    & HM.insert "red" (Expl.Val Nothing 2.0)
                    & HM.insert "d" (Expl.Val Nothing 15.0)
              }
        putStrLn $ fst stuff
        forM_ stuff2 $ \explExpr -> do
          xplainE (mempty @()) st $ eval explExpr
        pure ()
 where
  ts = myLexer s
  showPosToken ((l, c), t) = concat [show l, ":", show c, "\t", show t]

showTree :: (Show a) => Int -> a -> IO ()
showTree v tree = do
  putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree

main :: IO ()
main = do
  xs <- getArgs
  let v = case uncons xs of
        Nothing -> 2
        Just (x, _) -> read x
  getContents >>= run v pRule
