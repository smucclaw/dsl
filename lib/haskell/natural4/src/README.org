#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="excel-2007.css" />

* Notes on the code

** Extracting a BoolStruct

Suppose we are given an input range containing, /inter alia/, a column of AND and OR values:

| EVERY | person |
| WHO   | walks  |
| AND   | runs   |
| AND   | eats   |
| OR    | drinks |
| MUST  | sing   |

The BoolStruct is the bit in the middle. It spans the ~(walks && runs && (eats || drinks))~. Some call it a "condition" or "case".

The prior text, "EVERY person WHO", we will label the "Preamble". Because it comes before "walks".

The "MUST sing" we label the "Denouement". Other structures are possible; more on that later. But most variations contain a BoolStruct somewhere or other.

It's up to us to turn the columns of a BoolStruct into an and/or tree, respecting operator precedence.

Desired output:

#+begin_src haskell
  All (pre "who")
      [ Leaf "walks"
      , Leaf "runs"
      , Any (Pre "or")
            [ Leaf "eats"
            , Leaf "drinks"
            ]
      ]
#+end_src

We do this using a simple Parser pattern in which an AndGroup consists of one or more OrGroups; and the overall expression consists of one or more AndGroups. That gets you conjunctive normal form for free!

** What about the checkboxes?

Some variants of the spreadsheet will arrive bearing Bools:

| EVERY |       | person |
| WHO   | TRUE  | walks  |
| AND   | FALSE | runs   |
| AND   | FALSE | eats   |
| OR    | TRUE  | drinks |
| MUST  |       | sing   |

This is because Google Sheets uses checkboxes, in CSV, they show as TRUE and FALSE.

The parser ignores them:

#+begin_src haskell
  pEmpty = pToken Empty <|> pToken Checkbox
#+end_src

** What about nested sub-expressions?

~(walks && (eats || drinks))~ can fit into a straight column down the screen, but what if we have

~(walks || (eats && drinks))~ ?

We would need to indent a level, as [[https://docs.google.com/spreadsheets/d/1qMGwFhgPYLm-bmoN2es2orGkTaTN382pG2z3RjZ_s-4/edit#gid=1334573632][Example 13]] shows.

| EVERY | person |        |
| WHO   | walks  |        |
| OR    |        | eats   |
|       | AND    | drinks |
| MUST  | sing   |        |

** Nested Constitutive Rules

"Inline" constitutive rules take the form of a nested subexpression. Here we show the TRUE/FALSE checkboxes:

| TRUE | Prerequisites are met |                       |   |
| IF   | TRUE                  | preconditions are met |   |
|      | IF                    | TRUE                  | A |
|      | AND                   | TRUE                  | B |
| OR   | FALSE                 | C                     |   |
|      |                       |                       |   |

Eliminating the TRUE/FALSE checkboxes shows

|    | Prerequisites are met |                       |   |
|----+-----------------------+-----------------------+---|
| IF |                       | preconditions are met |   |
|    | IF                    |                       | A |
|    | AND                   |                       | B |
| OR |                       | C                     |   |
|    |                       |                       |   |

The general pattern for constitutive rules is

|       | Exp0 |        |
| IF    |      | Exp1a  |
| OR    |      | Exp1b  |
| OR    |      | Exp1c  |
|-------+------+--------|
| leftX |      | rightX |

Where each ExpN can itself expand recursively following the same pattern:

|    | Exp0 |       |       |   |
| IF |      | Exp1a |       |   |
|    | IF   |       | Exp2a |   |
|    | AND  |       | Exp2b |   |
| OR |      | Exp1b |       |   |
| OR |      | Exp1c |       |   |

Constitutive rules are similar to a ~let~ expression, where each named expression gets a variable binding.

#+begin_src haskell
  let Exp1a = Exp2a && Exp2b
      Exp0  = Exp1a || Exp1b || Exp1c
#+end_src

Equivalently, as an And/Or tree,
#+begin_src haskell
  Any (Label "Exp0")
    [ All (Label "Exp1a") [ Leaf Exp2a
                          , Leaf Exp2b ]
    , Leaf Exp1b
    , Leaf Exp1c ]
#+end_src

** Nested Boolean Expressions without Constitutive Labels

A version without variable bindings is more compact:

| something | something |        |
| WHEN      |           | Exp2a  |
|           | AND       | Exp2b  |
| OR        | Exp1b     |        |
| OR        | Exp1c     |        |
| something | something |        |

** So, how do we parse all this?

Currently the parser goes linearly left to right. It would be nice if we could preserve that linearity in the indentation-sensitive parser.

We know that a BoolStruct comes after an IF token. Reading left to right, a non-nested input would be a stream of ~[ Other AND/OR Other AND/OR Other ]~.

The parser is given the location of the preamble ~IF~. Non-nested input is expected to have all ~AND/OR~ at the same ~x~ (column) position.

What happens if there's a nested structure?

The parser might encounter a new AND or OR with an ~x~ position that is greater than the preamble's ~x~ position.

*** Parsing a Nested Boolean

So when a BoolStruct parser encounters an AND/OR farther to the right, it calls a new BoolStruct Parser, giving it a deeper x position. The result of the inner BoolStruct just becomes a term in the current BoolStruct.

*** Parsing a Nested Constitutive

A BoolStruct parser might encounter a constitutive rule: instead of a simple

#+begin_example
  Exp2a AND Exp2b
#+end_example

it encounters

#+begin_example
  Exp1a IS Exp2a AND Exp2b
#+end_example

In this situation, it returns, as part of the ongoing BoolStruct, a ~Leaf Exp1a~.

And it returns, as an attachment, a constitutive rule defining ~Leaf Exp1a~ in terms of ~All [ Exp2a, Exp2b ]~.

*** Parsing a Nested Regulative

A BoolStruct parser might encounter a regulative rule, connected to the parent by a ~HENCE~ or a ~LEST~ keyword.

In this situation it returns, as an attachment, the nested regulative rules.

*** The BoolStruct Parser, revisited

The need to return "attachments" means that a BoolStruct parser actually has to return:

#+begin_src haskell
  data BoolStruct = BS { getBS :: AnyAll Text
                       , getR  :: [ Rule ] -- constitutive and regulative rules
                       }
#+end_src

Nested booleans go into the ~getBS~.

Nested constitutive and regulative rules go into the ~getR~.

** Type Definitions                                                                      :ontology:

We assume most L4 developers will have some exposure to OOP.

We borrow some essential notions from OOP.

*** product types

- classes have attributes
- alternatively, records have fields

attributes have types.

| DEFINE | Cartesian   | coordinate | AKA | Point  |
| HAS    | X           | IS         | AN  | Int    |
|        | Y           | IS         | AN  | Int    |
|        | Label       | IS         | A   | String |

**** Legalese

***** Dialect 1

A Cartesian coordinate (hereinafter, a "*Point*") has the following attributes:
- an integer value "*X*";
- an integer value "*Y*"; and
- a string "*Label*".

***** Dialect 2

*Point* means a Cartesian coordinate with an integer value "X", an integer value "Y", and a string "label".

**** Haskell
#+begin_src haskell :tangle Classy.hs :noweb yes
  <<lens magic>>
  data Point = Point
   { _x     :: Int
   , _y     :: Int
   , _label :: String
   }
  makeClassy ''Point
#+end_src

**** Typescript
#+begin_src typescript
  class Point {
    x     : number;
    y     : number;
    label : string;
  }
#+end_src

**** Python
#+begin_src python
  class Point:
    x     = 1
    y     = 2
    label = "point label"
#+end_src

**** Prolog [[https://www.swi-prolog.org/pldoc/man?section=bidicts][dicts]]

#+begin_src prolog
  A = point{x:1, y:2, label:"point label"}.
#+end_src

**** Alloy
#+begin_src alloy
open util/integers

abstract sig Point {
  x : Int,
  y : Int
  /* labels are strings, which are too hairy for Alloy */
}

one pointA extends Point {
  x = 0
  y = 0
}
#+end_src

**** Uppaal

#+begin_src uppaal?
???
#+end_src

**** Java

#+begin_src java
class public super awesome Point {
  x: attribute variable member of Point is integer;
  y: same as above but in an ever more verbose syntax;
}
#+end_src


*** basic types
:PROPERTIES:
:HTML_CONTAINER_CLASS: plain-table
:END:

|      | L4       | Haskell                   | Typescript | Desc                                                                                    |
|------+----------+---------------------------+------------+-----------------------------------------------------------------------------------------|
|      | int      | Int                       | number     |                                                                                         |
|      | real     | Real                      | number     |                                                                                         |
|      | date     |                           |            | a mess of possible spec formats including "the third business day after Christmas 2033" |
|      | datetime |                           |            |                                                                                         |
|      |          |                           |            |                                                                                         |
|      | currency | (currencycode, baseunits) |            |                                                                                         |
| SG$1 |          | (SGD, 100)                |            |                                                                                         |
|      |          |                           |            |                                                                                         |

*** inheritance and validation

The syntax for inheritance and validation is:

| DEFINE         | SubClass | IS | A | SuperClass |
| HAS            | ...      |    |   |            |
| WHICH / WHOSE  | ...      |    |   |            |

There must be at least one of { HAS, WHICH | WHOSE } present after the DEFINE

**** WHICH syntax

the subject of the WHICH is the SubClass itself:

| DEFINE | Natural | IS | AN | Int |
| WHICH  | IS      | >= | 0  |     |

**** WHOSE syntax

an attribute name follows the WHOSE keyword:

| DEFINE | Quadrant1 | IS | A  | Point |   |
| WHOSE  | X         | IS | >= |     0 |   |
| AND    | Y         | IS | >= |     0 |   |

**** HAS syntax

| DEFINE | MyObject |    |   |                |
| HAS    | attr1    | IS | A | <Type Name>    |
| HAS    | attr2    | IS |   | a static value |

Here ~<Type Name>~ could be something like ~Int~ or ~String~ or ~Person~ or ~Address~.

A static value is literally that: something like ~42~. It's a class constant.

**** Examples
***** Haskell

as shown above with Classy Lenses

***** Typescript
#+begin_src typescript :tangle Classy.ts
  class SuperParent { }

  export class SubChild extends SuperParent {
    newSubAttribute9: number = 42;
    constructor(
      public newSubAttribute7: number,
      public newSubAttribute8: string
    ) { super() }
  }
#+end_src

This gets us:

#+begin_example
Welcome to Node.js v17.0.1.
Type ".help" for more information.
> classy = require('./src/Classy.js')
{ __esModule: true, SubChild: [Function: SubChild] }
> oops =new classy.SubChild (12,"boo")
SubChild {
  newSubAttribute7: 12,
  newSubAttribute8: 'boo',
  newSubAttribute9: 42
}
#+end_example


*** validation

OOP has the idea of *constructors* which instantiate a particular value into a class. Maybe something like ~init()~ or ~new()~

In Haskell every term has a type.

In advanced typed languages we have the notion of refinement and dependent types.

In L4 every class possesses a set of *validation rules*. Some might think of this in terms of refinement or dependent types.

**** Example 1
| DEFINE | Natural | IS | AN | Int |
| WHICH  | IS      | >= |  0 |     |

#+begin_src haskell :tangle Classy.hs
  data MyNatural = MyNatural {
    _myint :: Int
  } deriving (Show, Eq, Ord)
  makeClassy ''MyNatural

  class Validation a where
    isValid :: a -> Bool

  instance Validation MyNatural where
    isValid myn = myn^.myint >= 0
#+end_src

**** Example 2: majority

| ENTITY | Person        |   |   |    |       |         |             |                                     |   |    |   |        |                   |
| HAS    | official name |   |   | IS | A     | String  |             |                                     |   |    |   |        |                   |
| HAS    | address       |   |   | IS | AN    | Address | OPTIONAL    |                                     |   |    |   |        |                   |
| HAS    | identifier    |   |   | IS | ONEOF | UEN     | AKA         | Unique Entity Number                |   | IS | A | String | SG_UEN            |
|        |               |   |   |    | OR    | NRIC    | AKA         | National Registration Identity Card |   | IS | A | String | SG_NRIC           |
|        |               |   |   |    | OR    | FIN     | AKA         | Foreigner Identification Number     |   | IS | A | String | SG_FIN            |
|        |               |   |   |    | OR    | TIN     | AKA         | U.S. Taxpayer Identification Number |   | IS | A | String |                   |
|        |               |   |   |    | OR    |         | Nationality |                                     |   | IS | A | String | ISO3166-1 alpha-2 |
|        |               |   |   |    |       | AND     | Passport    |                                     |   | IS | A | String |                   |

#+begin_src haskell :tangle Classy.hs :noweb yes
  <<subsidiary types>>
  data Person = Person
    { _officialName :: String
    , _address :: Address
    , _identifier :: Identifier
    } deriving (Show, Eq)
  makeClassy ''Person
#+end_src

#+NAME: subsidiary types
#+begin_src haskell 
  type Address = [String]

  data Identifier = SG_UEN  String
                  | SG_NRIC String
                  | SG_FIN  String
                  | US_TIN  String
                  | Passport
                    { nationality :: String
                    , passportNo  :: String
                    }
    deriving (Show, Eq)
#+end_src

#+begin_src typescript
  class Person {
    _officialName  : string;
    _address      ?: Address;
    _identifier    :
        { idtype : "SGUEN",     idval : SGUEN }
      | { idtype : "SGNRIC",    idval : SGNRIC }
      | { idtype : "SGFIN",     idval : SGFIN }
      | { idtype : "USTIN",     idval : USTIN }
      | { idtype : "passport",  idval :
          {
            nationality: string; // "se" "sg" "us" "uk"
            passportNo:  string;
          }
        }
  }
  makeClassy ''Person
#+end_src

| ENTITY | Corporation    |   |   | IS | A | Person |   |   |
| ENTITY | Natural Person |   |   | IS | A | Person |   |   |

#+begin_src haskell :tangle Classy.hs
  data Corporation   = Corporation   { _cperson :: Person }
  data NaturalPerson = NaturalPerson { _nperson :: Person }
  makeClassy ''NaturalPerson
  instance HasPerson NaturalPerson where
    person = nperson
#+end_src

#+begin_src typescript
  class Corporation   extends Person { }
  class NaturalPerson extends Person { }
#+end_src

| ENTITY | Capable          |                  |   | IS | A       | Natural |          |        |       |
| HAS    | adulthood        |                  |   | IS | ONEOF   | Major   | Minor    | LIKELY | Major |
| HAS    | ParentOrGuardian |                  |   | IS | A       | Capable | OPTIONAL |        |       |
| WHOSE  | adulthood        |                  |   | IS |         | Major   |          |        |       |
| OR     |                  | ParentOrGuardian |   | IS | defined |         |          |        |       |
|        | AND              | ParentOrGuardian |   | IS | VALID   |         |          |        |       |

(Majority means: are they not a minor?)

Conventionally one would expect such a form to gather the exact birthdate, from which we could compute the age, from which we could compute majority, but here we are being more privacy-conscious and just asking if the individual is a major or a minor, hence ~majority~ is a Bool.

#+begin_src haskell :tangle Classy.hs
  data Majority = Major | Minor
    deriving (Eq)

  data CapablePerson = CapablePerson
    { _np               :: NaturalPerson
    , _adulthood        :: Majority
    , _parentOrGuardian :: Maybe CapablePerson
    }
  makeClassy ''CapablePerson
  instance HasNaturalPerson CapablePerson where
    naturalPerson = np

  instance Validation CapablePerson where
    isValid p =
      p^.adulthood == Major
      || maybe False isValid (p^.parentOrGuardian)

#+end_src

#+begin_src typescript
  class CapablePerson extends Natural {
    adulthood         : boolean;
    parentOrGuardian ?: CapablePerson;
  }
#+end_src
									
| ENTITY | Singapore Company |   |   | IS | A   | Corporation |   |   |
| HAS    | identifier        |   |   | IS | UEN |             |   |   |

#+begin_src typescript

#+end_src
									

*** instances



*** default values

*** attribute types

*** 

* Indentation Parsing

We use ( and ) to represent going deeper and going undeeper.

See the [[https://github.com/smucclaw/dsl/blob/main/lib/haskell/natural4/src/LS/Lib.hs#L340][insertparen]] function in the parser to see how preprocessing happens.

There are some tricky situations that result from conceptually separate /lines/ being parsed under the same indentation /tree/.

** Labels in boolstructs

Our And/Or trees (using the AnyAll library) have the notion of a PrePost label used to capture prefix/suffix text around a sutbree.

*** Indentation 1: a tree might look like:
:PROPERTIES:
:TABLE_EXPORT_FILE: ../test/boolstruct-indentation-1.csv
:TABLE_EXPORT_FORMAT: orgtbl-to-csv
:END:

| Qualifies |    |           |        |
| MEANS     | 1. | walks     |        |
| AND       | 2. | either of |        |
|           |    | 2a.       | eats   |
|           | OR | 2b.       | drinks |

Here we see that the subtrees carry structured labels -- the "1. 2. 2a. 2b." bits of text need to be preserved as set apart from the body of the tree.

And we see that subtree 2 has a pre-label, "either of". It is an OR tree. Its children are 2a. eats, 2b. drinks.

Conceptually easy, right?

But the parser needs to handle this input stream:

#+begin_src
  AND ( "2." ( "either of" "2a." ( "eats" ) ...
#+end_src

Note the lack of parenthesis between "either of" and "2a.". This is liable to confuse the parser.

What do we want?

We want the "2a. eats OR 2b. drinks" part to be organized under a Pre label "2. either of".

But achieving that is difficult.

The "OR" construct under "2." would ordinarily begin at the column of the "OR". But for that to work, the OR would need to somehow synthesize a virtual ) ( between "either of" and "2a.". We don't currently have a way to push into the stream.

Also, consider that there are alternative ways of indenting the same rule:

*** Indentation 2: A similar tree might look like this
:PROPERTIES:
:TABLE_EXPORT_FILE: ../test/boolstruct-indentation-2.csv
:TABLE_EXPORT_FORMAT: orgtbl-to-csv
:END:

| Qualifies |    |       |           |
| MEANS     | 1. | walks |           |
| AND       | 2. |       | either of |
|           |    | 2a.   | eats      |
|           | OR | 2b.   | drinks    |

Here the stream is

#+begin_src 
  AND ( "2." ( ( "either of" EOL ( "2a." ( "eats" ) ) OR ( "2b." ( "drinks" ) ) ) ) )
#+end_src

*** Indentation 3: An equally valid tree might look like this
:PROPERTIES:
:TABLE_EXPORT_FILE: ../test/boolstruct-indentation-3.csv
:TABLE_EXPORT_FORMAT: orgtbl-to-csv
:END:

| Qualifies |    |       |           |
| MEANS     | 1. | walks |           |
| AND       |    | 2.    | either of |
|           |    | 2a.   | eats      |
|           | OR | 2b.   | drinks    |

Here the stream is

#+begin_src
  AND ( ( "2." ( "either of" ) "2a." ( eats ) ) OR ( "2b." ( "drinks" ) ...
#+end_src

*** Solving indentation

All these alternatives need to be parsed and organized into the same output structure.

This job falls to the ~term~ function in ~Parser.hs~.

That function needs to handle the following cases:

- label's last word is directly above  the first word below
- label's last word is to the left of  the first word below
- label's last word is to the right of the first word below

Yes, it's possible for labels to have multiple words; or just a single word. We treat the single-word case as a trivial case of the multi-word case.


* infrastructure

#+NAME: lens magic
#+begin_src haskell
  {-# LANGUAGE TemplateHaskell #-}
  {-# OPTIONS_GHC -ddump-splices -dsuppress-uniques #-}

  module Classy where

  import Control.Lens

#+end_src
