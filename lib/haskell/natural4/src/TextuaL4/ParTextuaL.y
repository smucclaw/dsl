-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module TextuaL4.ParTextuaL
  ( happyError
  , myLexer
  , pRule
  ) where

import Prelude

import qualified TextuaL4.AbsTextuaL
import TextuaL4.LexTextuaL

}

%name pRule Rule
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('         { PT _ (TS _ 1)     }
  ')'         { PT _ (TS _ 2)     }
  ','         { PT _ (TS _ 3)     }
  ';'         { PT _ (TS _ 4)     }
  '<'         { PT _ (TS _ 5)     }
  '<='        { PT _ (TS _ 6)     }
  '>'         { PT _ (TS _ 7)     }
  '>='        { PT _ (TS _ 8)     }
  'A'         { PT _ (TS _ 9)     }
  'ABOUT'     { PT _ (TS _ 10)    }
  'AFTER'     { PT _ (TS _ 11)    }
  'ALL'       { PT _ (TS _ 12)    }
  'AND'       { PT _ (TS _ 13)    }
  'ANY'       { PT _ (TS _ 14)    }
  'BEFORE'    { PT _ (TS _ 15)    }
  'BY'        { PT _ (TS _ 16)    }
  'DECIDE'    { PT _ (TS _ 17)    }
  'DECLARE'   { PT _ (TS _ 18)    }
  'DIVIDE'    { PT _ (TS _ 19)    }
  'EQUALS'    { PT _ (TS _ 20)    }
  'EVERY'     { PT _ (TS _ 21)    }
  'False'     { PT _ (TS _ 22)    }
  'GIVEN'     { PT _ (TS _ 23)    }
  'GIVETH'    { PT _ (TS _ 24)    }
  'HAS'       { PT _ (TS _ 25)    }
  'IF'        { PT _ (TS _ 26)    }
  'IN'        { PT _ (TS _ 27)    }
  'IS'        { PT _ (TS _ 28)    }
  'LIST'      { PT _ (TS _ 29)    }
  'MAP'       { PT _ (TS _ 30)    }
  'MAX'       { PT _ (TS _ 31)    }
  'MAY'       { PT _ (TS _ 32)    }
  'MEANS'     { PT _ (TS _ 33)    }
  'MIN'       { PT _ (TS _ 34)    }
  'MINUS'     { PT _ (TS _ 35)    }
  'MODULO'    { PT _ (TS _ 36)    }
  'MUST'      { PT _ (TS _ 37)    }
  'NOT'       { PT _ (TS _ 38)    }
  'OF'        { PT _ (TS _ 39)    }
  'ON'        { PT _ (TS _ 40)    }
  'ONE'       { PT _ (TS _ 41)    }
  'OR'        { PT _ (TS _ 42)    }
  'OTHERWISE' { PT _ (TS _ 43)    }
  'PRODUCT'   { PT _ (TS _ 44)    }
  'SET'       { PT _ (TS _ 45)    }
  'SHANT'     { PT _ (TS _ 46)    }
  'SUBJECT'   { PT _ (TS _ 47)    }
  'SUM'       { PT _ (TS _ 48)    }
  'TO'        { PT _ (TS _ 49)    }
  'True'      { PT _ (TS _ 50)    }
  'UNLESS'    { PT _ (TS _ 51)    }
  'WHO'       { PT _ (TS _ 52)    }
  L_doubl     { PT _ (TD $$)      }
  L_integ     { PT _ (TI $$)      }
  L_quoted    { PT _ (TL $$)      }
  L_Token     { PT _ (T_Token $$) }

%%

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

Token :: { TextuaL4.AbsTextuaL.Token }
Token  : L_Token { TextuaL4.AbsTextuaL.Token $1 }

Rule :: { TextuaL4.AbsTextuaL.Rule }
Rule
  : 'DECLARE' IsA Fields { TextuaL4.AbsTextuaL.TypeDecl $2 $3 }
  | 'GIVEN' ListIsA Rule { TextuaL4.AbsTextuaL.Given $2 $3 }
  | 'EVERY' BoolStruct Deontic BoolStruct { TextuaL4.AbsTextuaL.RegSimple $2 $3 $4 }
  | 'EVERY' BoolStruct Who Deontic BoolStruct { TextuaL4.AbsTextuaL.RegWho $2 $3 $4 $5 }
  | 'EVERY' BoolStruct Who InlineHornlike Deontic BoolStruct { TextuaL4.AbsTextuaL.RegWhoInline $2 $3 $4 $5 $6 }
  | Text 'MEANS' BoolStruct { TextuaL4.AbsTextuaL.HornlikeMeans $1 $3 }
  | 'DECIDE' ListHornClause { TextuaL4.AbsTextuaL.HornlikeDecide $2 }
  | 'GIVETH' IsA 'DECIDE' ListHornClause { TextuaL4.AbsTextuaL.HlikeGiveth $2 $4 }

IsA :: { TextuaL4.AbsTextuaL.IsA }
IsA
  : Text 'IS' 'A' Text { TextuaL4.AbsTextuaL.IsAType $1 $4 }
  | Text 'IS' 'ONE' 'OF' ListText { TextuaL4.AbsTextuaL.IsAEnum $1 $5 }
  | Text 'IS' 'LIST' 'OF' Text { TextuaL4.AbsTextuaL.IsAList $1 $5 }
  | Text 'IS' 'SET' 'OF' Text { TextuaL4.AbsTextuaL.IsASet $1 $5 }
  | Text { TextuaL4.AbsTextuaL.IsANoType $1 }

ListText :: { [TextuaL4.AbsTextuaL.Text] }
ListText : Text { (:[]) $1 } | Text ',' ListText { (:) $1 $3 }

ListIsA :: { [TextuaL4.AbsTextuaL.IsA] }
ListIsA : IsA { (:[]) $1 } | IsA ';' ListIsA { (:) $1 $3 }

Fields :: { TextuaL4.AbsTextuaL.Fields }
Fields
  : 'HAS' ListIsA { TextuaL4.AbsTextuaL.Has $2 }
  | {- empty -} { TextuaL4.AbsTextuaL.EmptyFields }

HornClause :: { TextuaL4.AbsTextuaL.HornClause }
HornClause
  : RelationalPredicate 'IF' BoolStruct { TextuaL4.AbsTextuaL.HeadBody $1 $3 }
  | RelationalPredicate 'OTHERWISE' { TextuaL4.AbsTextuaL.HeadOtherwise $1 }
  | RelationalPredicate { TextuaL4.AbsTextuaL.HeadOnly $1 }

ListHornClause :: { [TextuaL4.AbsTextuaL.HornClause] }
ListHornClause
  : HornClause { (:[]) $1 }
  | HornClause ';' ListHornClause { (:) $1 $3 }

Deontic :: { TextuaL4.AbsTextuaL.Deontic }
Deontic
  : 'MUST' { TextuaL4.AbsTextuaL.Deontic_MUST }
  | 'MAY' { TextuaL4.AbsTextuaL.Deontic_MAY }
  | 'SHANT' { TextuaL4.AbsTextuaL.Deontic_SHANT }

Who :: { TextuaL4.AbsTextuaL.Who }
Who : 'WHO' BoolStruct { TextuaL4.AbsTextuaL.WhoSimple $2 }

InlineHornlike :: { TextuaL4.AbsTextuaL.InlineHornlike }
InlineHornlike
  : 'MEANS' BoolStruct { TextuaL4.AbsTextuaL.MeansInline $2 }

RelationalPredicate :: { TextuaL4.AbsTextuaL.RelationalPredicate }
RelationalPredicate
  : ListMTExpr { TextuaL4.AbsTextuaL.RPMT $1 }
  | ListMTExpr RPRel BoolStruct1 { TextuaL4.AbsTextuaL.RPBoolStructR $1 $2 $3 }
  | RPRel1 '(' ListRelationalPredicate ')' { TextuaL4.AbsTextuaL.RPnary $1 $3 }

ListRelationalPredicate :: { [TextuaL4.AbsTextuaL.RelationalPredicate] }
ListRelationalPredicate
  : RelationalPredicate { (:[]) $1 }
  | RelationalPredicate ',' ListRelationalPredicate { (:) $1 $3 }

MTExpr :: { TextuaL4.AbsTextuaL.MTExpr }
MTExpr
  : Text { TextuaL4.AbsTextuaL.MTT $1 }
  | Integer { TextuaL4.AbsTextuaL.MTI $1 }
  | Double { TextuaL4.AbsTextuaL.MTF $1 }
  | Bool { TextuaL4.AbsTextuaL.MTB $1 }

Bool :: { TextuaL4.AbsTextuaL.Bool }
Bool
  : 'True' { TextuaL4.AbsTextuaL.Bool_True }
  | 'False' { TextuaL4.AbsTextuaL.Bool_False }

Text :: { TextuaL4.AbsTextuaL.Text }
Text
  : String { TextuaL4.AbsTextuaL.TextString $1 }
  | Token { TextuaL4.AbsTextuaL.TextToken $1 }

ListMTExpr :: { [TextuaL4.AbsTextuaL.MTExpr] }
ListMTExpr : MTExpr { (:[]) $1 } | MTExpr ListMTExpr { (:) $1 $2 }

BoolStruct1 :: { TextuaL4.AbsTextuaL.BoolStruct }
BoolStruct1
  : 'ANY' '(' ListBoolStruct ')' { TextuaL4.AbsTextuaL.Any $3 }
  | Text 'ANY' '(' ListBoolStruct ')' Text { TextuaL4.AbsTextuaL.AnyPrePost $1 $4 $6 }
  | Text 'ANY' '(' ListBoolStruct ')' { TextuaL4.AbsTextuaL.AnyPre $1 $4 }
  | 'ALL' '(' ListBoolStruct ')' { TextuaL4.AbsTextuaL.All $3 }
  | Text 'ALL' '(' ListBoolStruct ')' { TextuaL4.AbsTextuaL.AllPre $1 $4 }
  | Text 'ALL' '(' ListBoolStruct ')' Text { TextuaL4.AbsTextuaL.AllPrePost $1 $4 $6 }
  | 'NOT' BoolStruct1 { TextuaL4.AbsTextuaL.Not $2 }
  | RelationalPredicate { TextuaL4.AbsTextuaL.Leaf $1 }
  | '(' BoolStruct ')' { $2 }

BoolStruct :: { TextuaL4.AbsTextuaL.BoolStruct }
BoolStruct
  : BoolStruct1 'UNLESS' BoolStruct1 { TextuaL4.AbsTextuaL.Unless $1 $3 }
  | BoolStruct1 { $1 }

ListBoolStruct :: { [TextuaL4.AbsTextuaL.BoolStruct] }
ListBoolStruct
  : BoolStruct { (:[]) $1 }
  | BoolStruct ',' ListBoolStruct { (:) $1 $3 }

RPRel :: { TextuaL4.AbsTextuaL.RPRel }
RPRel
  : 'IS' { TextuaL4.AbsTextuaL.RPis }
  | 'HAS' { TextuaL4.AbsTextuaL.RPhas }
  | 'EQUALS' { TextuaL4.AbsTextuaL.RPeq }
  | '<' { TextuaL4.AbsTextuaL.RPlt }
  | '<=' { TextuaL4.AbsTextuaL.RPlte }
  | '>' { TextuaL4.AbsTextuaL.RPgt }
  | '>=' { TextuaL4.AbsTextuaL.RPgte }
  | 'IN' { TextuaL4.AbsTextuaL.RPelem }
  | 'NOT' 'IN' { TextuaL4.AbsTextuaL.RPnotElem }
  | 'NOT' { TextuaL4.AbsTextuaL.RPnot }
  | 'AND' { TextuaL4.AbsTextuaL.RPand }
  | 'OR' { TextuaL4.AbsTextuaL.RPor }
  | 'SUBJECT' 'TO' { TextuaL4.AbsTextuaL.RPsubjectTo }
  | TComparison { TextuaL4.AbsTextuaL.RPTC $1 }
  | RPRel1 { $1 }

RPRel1 :: { TextuaL4.AbsTextuaL.RPRel }
RPRel1
  : 'SUM' { TextuaL4.AbsTextuaL.RPsum }
  | 'PRODUCT' { TextuaL4.AbsTextuaL.RPproduct }
  | 'MINUS' { TextuaL4.AbsTextuaL.RPminus }
  | 'DIVIDE' { TextuaL4.AbsTextuaL.RPdivide }
  | 'MODULO' { TextuaL4.AbsTextuaL.RPmodulo }
  | 'MIN' { TextuaL4.AbsTextuaL.RPmin }
  | 'MAX' { TextuaL4.AbsTextuaL.RPmax }
  | 'MAP' { TextuaL4.AbsTextuaL.RPmap }
  | '(' RPRel ')' { $2 }

TComparison :: { TextuaL4.AbsTextuaL.TComparison }
TComparison
  : 'BEFORE' { TextuaL4.AbsTextuaL.TBefore }
  | 'AFTER' { TextuaL4.AbsTextuaL.TAfter }
  | 'BY' { TextuaL4.AbsTextuaL.TBy }
  | 'ON' { TextuaL4.AbsTextuaL.TOn }
  | 'ABOUT' { TextuaL4.AbsTextuaL.TVague }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

