-- File generated by the BNF Converter (bnfc 2.9.5).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}
{-# LANGUAGE QuasiQuotes #-}

module TextuaL4.Transform where

--import Prelude (($), (<$>), fmap, Bool(..), Maybe(..), error)
import qualified TextuaL4.AbsTextuaL as TL4
import LS.Rule
import LS.Types
import AnyAll (BoolStruct(..), Label(..))
import Data.List.NonEmpty (NonEmpty ((:|)))
import Data.String.Interpolate (i)
import Data.Text qualified as Text

transText :: TL4.Text -> Text.Text
transText (TL4.Text string) = Text.pack string

transRule :: TL4.Rule -> Rule
transRule x = case x of
  TL4.RegSimple sbj deont act ->
    defaultReg {
      subj = transBoolStructP sbj
    , deontic = transDeontic deont
    , action = transBoolStructP act
    }
  TL4.RegWho text who deontic action ->
    let simple = transRule $ TL4.RegSimple text deontic action
    in simple {who = Just $ transWho who }
  TL4.RegWhoInline text who hlike deontic action ->
    let simple = transRule $ TL4.RegWho text who deontic action
    in simple {wwhere = [transInlineHornlike who hlike]}
  TL4.Hornlike text bsr -> mkHlike (transText text) bsr
  TL4.TypeDecl text fields ->
    defaultTypeDecl {
      name = [MTT $ transText text]
    , has = transFields fields
    }
  TL4.TypeDeclIs isa fields ->
    let isaRule = transIsA isa
    in isaRule {
      has = transFields fields
    }


mkSuper :: TL4.Text -> TypeSig
mkSuper = SimpleType TOne . transText -- TODO: lists, sets, enums

transIsA :: TL4.IsA -> Rule
transIsA x = case x of
  TL4.MkIsA rname typesig ->
    defaultTypeDecl {
      name = [MTT $ transText rname]
    , super = Just $ mkSuper typesig
    }

transFields :: TL4.Fields -> [Rule]
transFields x = case x of
  TL4.Has isas -> transIsA <$> isas
  TL4.EmptyFields -> []

mkHlike text bsr = defaultHorn {
    clauses = [HC (bsr2rp text bsr) Nothing]
  }

bsr2rp :: Text.Text -> TL4.BoolStruct -> RelationalPredicate
bsr2rp text bsr = RPBoolStructR [MTT text] RPis (transBoolStructR bsr)

transDeontic :: TL4.Deontic -> Deontic
transDeontic x = case x of
  TL4.Deontic_MUST -> DMust
  TL4.Deontic_MAY -> DMay
  TL4.Deontic_SHANT -> DShant

transWho :: TL4.Who -> BoolStructR
transWho x = case x of
  TL4.WhoSimple bsr -> transBoolStructR bsr

transInlineHornlike :: TL4.Who -> TL4.InlineHornlike -> Rule
transInlineHornlike (TL4.WhoSimple whoBSR) (TL4.MeansInline meansBSR) =
  mkHlike (bsr2text $ transBoolStructR whoBSR) meansBSR

transRelationalPredicate :: TL4.RelationalPredicate -> RelationalPredicate
transRelationalPredicate x = case x of
  TL4.RPMT mtes
    -> RPMT (transMTExpr <$> mtes)
  TL4.RPBoolStructR xs rprel (TL4.Leaf (TL4.RPMT ys))
    -> RPConstraint (transMTExpr <$> xs) (transRPRel rprel) (transMTExpr <$> ys)
  TL4.RPBoolStructR mtes rprel bsr
    -> RPBoolStructR (transMTExpr <$> mtes) (transRPRel rprel) (transBoolStructR bsr)

transParamText :: TL4.RelationalPredicate -> ParamText
transParamText x = case x of
  TL4.RPMT (mte:mtes)
    -> (transMTExpr mte :| fmap transMTExpr mtes, Nothing) :| []
  _ -> error [i|transParamText: #{x} not supported as ParamText|]

transMTExpr :: TL4.MTExpr -> MTExpr
transMTExpr x = case x of
  TL4.MTT text -> MTT $ transText text
  TL4.MTI integer -> MTI integer
  TL4.MTF double -> MTF double
  TL4.MTB bool -> MTB $ transBool bool

transBool :: TL4.Bool -> Bool
transBool x = case x of
  TL4.Bool_True -> True
  TL4.Bool_False -> False

transBoolStructP :: TL4.BoolStruct -> BoolStructP
transBoolStructP x = case x of
  TL4.Leaf rp -> Leaf $ transParamText rp
  TL4.Not bs -> Not $ transBoolStructP bs
  TL4.Any bss
    -> Any Nothing (transBoolStructP <$> bss)
  TL4.AnyPre text bss
    -> Any (Just $ Pre $ transText text) (transBoolStructP <$> bss)
  TL4.AnyPrePost pr bss pst
    -> Any (Just $ PrePost (transText pr) (transText pst)) (transBoolStructP <$> bss)
  TL4.All bss
    -> All Nothing (transBoolStructP <$> bss)
  TL4.AllPre text bss
    -> All (Just $ Pre $ transText text) (transBoolStructP <$> bss)
  TL4.AllPrePost pr bss pst
    -> All (Just $ PrePost (transText pr) (transText pst)) (transBoolStructP <$> bss)

transBoolStructR :: TL4.BoolStruct -> BoolStructR
transBoolStructR x = case x of
  TL4.Any bsrs
    -> Any Nothing (transBoolStructR <$> bsrs)
  TL4.AnyPre text bsrs
    -> Any (Just $ Pre $ transText text) (transBoolStructR <$> bsrs)
  TL4.AnyPrePost pr bsrs pst
    -> Any (Just $ PrePost (transText pr) (transText pst)) (transBoolStructR <$> bsrs)
  TL4.All bsrs
    -> All Nothing (transBoolStructR <$> bsrs)
  TL4.AllPre text bsrs
    -> All (Just $ Pre $ transText text) (transBoolStructR <$> bsrs)
  TL4.AllPrePost pr bsrs pst
    -> All (Just $ PrePost (transText pr) (transText pst)) (transBoolStructR <$> bsrs)
  TL4.Not bsr -> Not $ transBoolStructR bsr
  TL4.Leaf rp -> Leaf $ transRelationalPredicate rp

transRPRel :: TL4.RPRel -> RPRel
transRPRel x = case x of
  TL4.RPis -> RPis
  TL4.RPhas -> RPhas
  TL4.RPeq -> RPeq
  TL4.RPlt -> RPlt
  TL4.RPlte -> RPlte
  TL4.RPgt -> RPgt
  TL4.RPgte -> RPgte
  TL4.RPelem -> RPelem
  TL4.RPnotElem -> RPnotElem
  TL4.RPnot -> RPnot
  TL4.RPand -> RPand
  TL4.RPor -> RPor
  TL4.RPsum -> RPsum
  TL4.RPproduct -> RPproduct
  TL4.RPminus -> RPminus
  TL4.RPdivide -> RPdivide
  TL4.RPmodulo -> RPmodulo
  TL4.RPsubjectTo -> RPsubjectTo
  TL4.RPmin -> RPmin
  TL4.RPmax -> RPmax
  TL4.RPmap -> RPmap
  TL4.RPTC tc -> RPTC $ transTComparison tc

transTComparison :: TL4.TComparison -> TComparison
transTComparison x = case x of
  TL4.TBefore -> TBefore
  TL4.TAfter -> TAfter
  TL4.TBy -> TBy
  TL4.TOn -> TOn
  TL4.TVague -> TVague
