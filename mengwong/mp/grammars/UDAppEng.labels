#word is   be  Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin
#word are  be  Mood=Ind|Tense=Pres|VerbForm=Fin
#word am   be  Mood=Ind|Number=Sing|Person=1|Tense=Pres|VerbForm=Fin
#word was  be  Mood=Ind|Number=Sing|Person=3|Tense=Past|VerbForm=Fin
#word were be  Mood=Ind|Tense=Past|VerbForm=Fin
#word been be  Tense=Past|VerbForm=Part
#word be   be  VerbForm=Inf
#word has  have  Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin
#word have have  VerbForm=Inf
#word had  have  Mood=Ind|Tense=Past|VerbForm=Fin
#word does  do  Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin
#word do do  VerbForm=Inf
#word did  do  Mood=Ind|Tense=Past|VerbForm=Fin
#word would would  VerbForm=Fin
#word will  will   VerbForm=Fin
#word to to _
#word that that _
#word there there _
#word not not Polarity=Neg
#word n't not Polarity=Neg
#word 's 's _
#word ' ' _
#word , , _

#lemma DEFAULT_ be cop cop head


------------------------------------------------------------------
-- The following copied from gf-ud/grammars/ShallowParseEng.labels

-- To handle "my hovercraft": i_Pron is not by default parsed as Det
#auxfun PossSgNP_ pron cn : Pron -> CN -> NP = DetCN (DetQuant (PossPron pron) NumSg) cn ; nmod:poss[PronType=Prs] head[Number=Sing]
#auxfun PossPlNP_ pron cn : Pron -> CN -> NP = DetCN (DetQuant (PossPron pron) NumPl) cn ; nmod:poss[PronType=Prs] head[Number=Plur]

-- disable plurals as mass terms
#auxfun MassNP_sg cn : CN -> NP = MassNP cn ; head[Number=Sing]
#auxfun DetCN_aPl cn : CN -> NP = DetCN aPl_Det cn ; head[Number=Plur]
#disable MassNP

#auxcat The DET
#auxfun DetCN_theSg det cn : The -> CN -> NP = DetCN the_Det cn ; det head[Number=Sing]
#auxfun DetCN_thePl det cn : The -> CN -> NP = DetCN thePl_Det cn ; det head[Number=Plur]
#disable the_Det thePl_Det

#auxfun UttImpSg_Pos vp : VP -> Utt = UttImpSg PPos (ImpVP vp) ; head[VerbForm=Inf]
#auxfun UttImpSg_Neg do neg vp : Do -> Neg -> VP -> Utt = UttImpSg PNeg (ImpVP vp) ; aux[VerbForm=Inf] advmod head[VerbForm=Inf]

#auxfun PositA_ a : A -> AP = PositA a ; head[Degree=Pos]
#auxfun UseComparA_ a : A -> AP = UseComparA a ; head[Degree=Cmp]
#auxfun SuperlA_ a : A -> AP = AdjOrd (OrdSuperl a) ; head[Degree=Sup]
#disable UseComparA OrdSuperl AdjOrd

#auxcat Comma PUNCT
#auxfun ExtAdvS_ adv comma s : Adv -> Comma -> S -> S = ExtAdvS adv s ; advmod punct head

-----------------------
-- Inari's additions --
-----------------------

-- ** more than **
-- This whole set of auxfuns is to parse the structure "more than 500 people",
-- which is nested differently from RGL funs

#auxcat More ADJ
#auxcat Than ADP
#auxfun MoreThan_ more than : More -> Than -> Quant = more_than_Quant ; head[Degree=Cmp] fixed
#disable than_Prep

-- This relation is head advmod, and default DetQuant is head nummod
#auxfun DetQuantAdvmod_ moreThan five : Quant -> Num -> Det = DetQuant moreThan five ; advmod head

-- This is not like normal DetCN, which is det head
#auxfun DetCNNummod_ moreThan5 people : Det -> CN -> NP = DetCN moreThan5 people ; nummod head

--#auxfun PredetNP_ more_than x_people : Quant -> Num -> NP = PredetNP more_than x_people ; advmod head

-- #auxcat Num_ NUM -- can be Card or Num or any GF cat
-- #auxfun MoreThanXCN_ more than x cn : More -> Than -> Num_ -> CN -> NP = PredetNP more_Predet (DetCN (DetQuant IndefArt x) cn) ; ((head fixed):advmod  head):nummod  head

-- ((more than) 500  )    people
--   head  fix
--   advmod     head
--      nummod            head

-- ** 5 people **
--#auxfun NumCN_ num cn : Card -> CN -> NP = DetCN (DetQuant IndefArt (NumCard num)) cn ; nummod head


-- ** acl **
-- [personal data]:CN [stored in electronic formats]:acl
#auxfun PPartCN_ cn vp : CN -> VP -> CN = AdjCN (PastPartAP vp) cn ; head acl[Tense=Past|VerbForm=Part]

-- [data breach]:CN [affecting 500 people]:acl
#auxfun PPresCN_ cn vp : CN -> VP -> CN = AdjCN (PresPartAP vp) cn ; head acl[VerbForm=Ger]

#disable PresPartAP PastPartAP


-- The construction "whose X" in the RGL is done using FunRP with possess_Prep.

-- (the person) [whose data]:RP (is affected)
#auxcat RelPron PRON
#auxfun FunRP_ whose data : RelPron -> CN -> RP = FunRP possess_Prep (MassNP data) IdRP ; nmod:poss[PronType=Int|Poss=Yes] head
#disable FunRP

-- the person [who is affected]:RS
#auxfun PassRelPres_ affected who is : V -> RP -> auxPass -> RS = UseRCl (TTAnt TPres ASimul) PPos (RelVP who (PassV affected)) ; head[Voice=Pass] nsubj:pass aux:pass[Tense=Pres]

-- … [who was affected]:RS
#auxfun PassRelPast_ affected who was : V -> RP -> auxPass -> RS = UseRCl (TTAnt TPast ASimul) PPos (RelVP who (PassV affected)) ; head[Voice=Pass] nsubj:pass aux:pass[Tense=Past]

-- … [who has been affected]:RS
#auxfun PassRelPart_ affected who has been : V -> RP -> aux -> auxPass -> RS = UseRCl (TTAnt TPres AAnter) PPos (RelVP who (PassV affected)) ; head[Voice=Pass] nsubj:pass aux[Tense=Pres] aux:pass[VerbForm=Part]

-- the data [which is stored in electronic formats]:RS
#auxfun PassRelOblPres_ stored which is in_formats : V -> RP -> auxPass -> Adv -> RS = UseRCl (TTAnt TPres ASimul) PPos (RelVP which (AdvVP (PassV stored) in_formats)) ; head[Voice=Pass] nsubj:pass aux:pass obl

-- [which has been stored in electronic formats]:RS
#auxfun PassRelOblPart_ stored which has been in_formats : V -> RP -> aux -> auxPass -> Adv -> RS = UseRCl (TTAnt TPres AAnter) PPos (RelVP which (AdvVP (PassV stored) in_formats)) ; head[Voice=Pass] nsubj:pass aux[Tense=Pres] aux:pass[VerbForm=Part] obl

-- TODO: ideally would choose this, if we saw the preposition "by" attaching to the obl. But that doesn't seem to be possible? Allowing this rule changes "stored in formats" to "stored by formats"
-- the person [whose data is affected by the breach]:RCl
--#auxfun PassRelClAgent_ affected whose_data is breach : V -> RP -> auxPass -> NP -> RCl = RelVP whose_data (PassVAgent affected breach) ; head[Voice=Pass] nsubj:pass aux:pass obl

-- be notified -- TODO: is this rule used on its own?
#auxfun PassV_ v : V -> VP = PassV v ; head[Voice=Pass]

#disable PassV

-- attach RCl to a NP
-- everyone who is affected
#auxfun RelNP_ np rs : NP -> RS -> NP = RelNP np rs ; head acl:relcl


-- ** obl **
-- stored [in electronic formats]:obl
-- default for AdvVP is head advmod, this is for head obl (i.e. Adv made by PrepNP)
#auxfun OblVP_ vp adv : VP -> Adv -> VP = AdvVP vp adv ; head obl

